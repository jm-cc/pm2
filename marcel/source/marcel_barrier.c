
/* This file has been autogenerated from source/nptl_barrier.c.m4 */
/*
 * PM2: Parallel Multithreaded Machine
 * Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */


#include "marcel.h"
#include "marcel_pmarcel.h"


DEF_MARCEL_PMARCEL(int, barrierattr_init, (marcel_barrierattr_t * attr), (attr),
{
	MARCEL_LOG_IN();

	attr->pshared = MARCEL_PROCESS_PRIVATE;
	attr->mode = MARCEL_BARRIER_SLEEP_MODE;

	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL_PMARCEL(int, barrierattr_destroy, (marcel_barrierattr_t * attr TBX_UNUSED), (attr),
{
	MARCEL_LOG_IN();
	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL_PMARCEL(int, barrierattr_getpshared, (__const marcel_barrierattr_t * attr, int *pshared),
		   (attr, pshared),
{
	MARCEL_LOG_IN();
	*pshared = attr->pshared;
	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL_PMARCEL(int, barrierattr_setpshared, (marcel_barrierattr_t * attr, int pshared),
		   (attr, pshared),
{
	MARCEL_LOG_IN();

	if (pshared != MARCEL_PROCESS_PRIVATE
	    && __builtin_expect(pshared != MARCEL_PROCESS_SHARED, 0)) {
		MARCEL_LOG_RETURN(EINVAL);
	}
	if (pshared == MARCEL_PROCESS_SHARED) {
		MARCEL_LOG_RETURN(ENOTSUP);
	}
	attr->pshared = pshared;

	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL(int, barrierattr_getmode, (__const marcel_barrierattr_t * attr, marcel_barrier_mode_t * mode),
	   (attr, mode),
{
	MARCEL_LOG_IN();
	*mode = attr->mode;
	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL(int, barrierattr_setmode, (marcel_barrierattr_t * attr, marcel_barrier_mode_t mode),
	   (attr, mode),
{
	MARCEL_LOG_IN();

	if (mode == MARCEL_BARRIER_SLEEP_MODE || 
	    mode == MARCEL_BARRIER_YIELD_MODE) {
		attr->mode = mode;
		MARCEL_LOG_RETURN(0);
	}

	MARCEL_LOG_RETURN(EINVAL);
})

DEF_MARCEL(int, barrier_setcount, (marcel_barrier_t * b, unsigned int count), (b, count),
{
	MARCEL_LOG_IN();

	ma_fastlock_acquire(&b->lock);
	b->init_count = count;
	ma_atomic_set(&b->leftB, count);
	ma_atomic_set(&b->leftE, 0);
	ma_fastlock_release(&b->lock);

	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL(int, barrier_getcount, (const marcel_barrier_t * b, unsigned int *count), (b, count),
{
	MARCEL_LOG_IN();
	*count = b->init_count;
	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL(int, barrier_addcount, (marcel_barrier_t * b, int v), (b, v),
{
	MARCEL_LOG_IN();

	ma_fastlock_acquire(&b->lock);
	b->init_count += v;
	ma_atomic_add(v, &b->leftB);
	ma_fastlock_release(&b->lock);

	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL_PMARCEL(int, barrier_init, (marcel_barrier_t * b, __const marcel_barrierattr_t * attr, unsigned int count),
		   (b, attr, count),
{
	MARCEL_LOG_IN();

	if (tbx_unlikely(0 == count))
		MARCEL_LOG_RETURN(EINVAL);

	if (attr != NULL) {
		if (attr->pshared != MARCEL_PROCESS_PRIVATE
		    && attr->pshared != MARCEL_PROCESS_SHARED)
			MARCEL_LOG_RETURN(EINVAL);

		if (attr->pshared == MARCEL_PROCESS_SHARED)
			MARCEL_LOG_RETURN(ENOTSUP);

		b->mode = attr->mode;
	} else
		b->mode = MARCEL_BARRIER_SLEEP_MODE;
	

	__marcel_init_lock(&b->lock);
	b->init_count = count;
	ma_atomic_init(&b->leftB, count);
	ma_atomic_init(&b->leftE, 0);

	MARCEL_LOG_RETURN(0);
})

DEF_MARCEL_PMARCEL(int, barrier_destroy, (marcel_barrier_t * b), (b),
{
	int ret;

	MARCEL_LOG_IN();

	if (b->mode == MARCEL_BARRIER_SLEEP_MODE) {
		ma_fastlock_acquire(&b->lock);
		while (ma_atomic_read(&b->leftE))
			__marcel_lock_wait(&b->lock, ma_self(), 0);
	} else {
		while (ma_atomic_read(&b->leftE))
			marcel_yield();
	}

	if (tbx_unlikely(ma_atomic_read(&b->leftB) != (int) b->init_count))
		ret = EBUSY;
	else
		ret = 0;

	if (b->mode == MARCEL_BARRIER_SLEEP_MODE) {
		ma_fastlock_release(&b->lock);
		__marcel_destroy_lock(&b->lock);
	}

	MARCEL_LOG_RETURN(ret);
})

DEF_MARCEL_PMARCEL(int, barrier_wait, (marcel_barrier_t * b), (b),
{
	int ret;

	MARCEL_LOG_IN();

	marcel_barrier_wait_begin(b);
	if (!marcel_barrier_wait_end(b))
		ret = MARCEL_BARRIER_SERIAL_THREAD;
	else
		ret = 0;

	MARCEL_LOG_RETURN(ret);
})

DEF_MARCEL(int, barrier_wait_begin, (marcel_barrier_t * b), (b),
{
	int ret;

	MARCEL_LOG_IN();

	if (b->mode == MARCEL_BARRIER_SLEEP_MODE) {
		ma_fastlock_acquire(&b->lock);
		while (ma_atomic_read(&b->leftE))
			__marcel_lock_wait(&b->lock, ma_self(), 0);
	} else {
		while (ma_atomic_read(&b->leftE))
			marcel_yield();
	}

	ret = ma_atomic_dec_return(&b->leftB);
	if (!ret) {
		ma_atomic_set(&b->leftB, b->init_count);
		ma_atomic_set(&b->leftE, b->init_count);
	}

	if (b->mode == MARCEL_BARRIER_SLEEP_MODE) {
		__marcel_lock_broadcast(&b->lock, -1);
		ma_fastlock_release(&b->lock);
	}

	MARCEL_LOG_RETURN(ret);
})

DEF_MARCEL(int, barrier_wait_end, (marcel_barrier_t * b), (b),
{
	int ret;

	MARCEL_LOG_IN();

	if (b->mode == MARCEL_BARRIER_SLEEP_MODE) {
		ma_fastlock_acquire(&b->lock);
		while (!ma_atomic_read(&b->leftE))
			__marcel_lock_wait(&b->lock, ma_self(), 0);
	} else {
		while (!ma_atomic_read(&b->leftE))
			marcel_yield();
	}

	ret = ma_atomic_dec_return(&b->leftE);

	if (b->mode == MARCEL_BARRIER_SLEEP_MODE) {
		__marcel_lock_broadcast(&b->lock, -1);
		ma_fastlock_release(&b->lock);
	}

	MARCEL_LOG_RETURN(ret);
})
