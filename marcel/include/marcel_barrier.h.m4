dnl -*- linux-c -*-
include(scripts/marcel.m4)
dnl /***************************
dnl  * This is the original file
dnl  * =========================
dnl  ***************************/
/* This file has been autogenerated from __file__ */
/*
 * PM2: Parallel Multithreaded Machine
 * Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */

#depend "linux_spinlock.h[macros]"

#section types
typedef enum marcel_barrier_mode { 
  MA_BARRIER_SLEEP_MODE, 
  MA_BARRIER_YIELD_MODE 
} ma_barrier_mode_t;

#section macros

REPLICATE([[dnl
#define PREFIX_BARRIER_SERIAL_THREAD (-1)
]])


REPLICATE([[dnl
#define PREFIX_BARRIER_INITIALIZER(count) \
  { \
    .init_count = (count),\
    .lock = (struct _prefix_fastlock) MA_PREFIX_FASTLOCK_UNLOCKED, \
    .leftB = MA_ATOMIC_INIT(count), \
    .leftE = MA_ATOMIC_INIT(0), \
    .mode = MA_BARRIER_SLEEP_MODE, \
  }
]], [[MARCEL PMARCEL]])

#section types
#depend "asm/linux_atomic.h[marcel_types]"
#depend "marcel_fastlock.h[structures]"
#depend "marcel_threads.h[types]"

REPLICATE([[dnl
/* Barrier variable attribute data structure: internaltypes.h */
typedef struct prefix_barrierattr
{
	int pshared;
	ma_barrier_mode_t mode;
} prefix_barrierattr_t;
]], [[MARCEL PMARCEL]])

REPLICATE([[dnl
/* Barrier data structure : internaltypes.h */
typedef struct prefix_barrier
{
  unsigned int init_count;
  struct _prefix_fastlock lock;
  ma_atomic_t leftB;
  ma_atomic_t leftE;
  ma_barrier_mode_t mode;
} prefix_barrier_t;
]], [[MARCEL PMARCEL]])

#section functions

int marcel_barrier_setcount(marcel_barrier_t *barrier, unsigned int count);
int marcel_barrier_addcount(marcel_barrier_t *barrier, int addcount);
int marcel_barrier_getcount(__const marcel_barrier_t *barrier, unsigned int *count);

REPLICATE([[dnl 
int prefix_barrier_wait_begin(prefix_barrier_t *barrier);
int prefix_barrier_wait_end(prefix_barrier_t *barrier);
]])

REPLICATE([[dnl
extern int prefix_barrier_init (prefix_barrier_t *__restrict barrier,
                                __const prefix_barrierattr_t *__restrict attr, unsigned num) __THROW;

extern int prefix_barrier_destroy (prefix_barrier_t *barrier) __THROW;

extern int prefix_barrier_wait (prefix_barrier_t *__restrict barrier) __THROW;

extern int prefix_barrierattr_init (prefix_barrierattr_t *attr) __THROW;

extern int prefix_barrierattr_destroy (prefix_barrierattr_t *attr) __THROW;

extern int prefix_barrierattr_getpshared (__const prefix_barrierattr_t *
                                        __restrict attr,
                                        int *__restrict pshared) __THROW;

extern int prefix_barrierattr_setpshared (prefix_barrierattr_t *attr,
                                        int pshared) __THROW;

extern int prefix_barrierattr_getmode (__const prefix_barrierattr_t *
                                        __restrict attr,
                                        ma_barrier_mode_t *__restrict mode) __THROW;

extern int prefix_barrierattr_setmode (prefix_barrierattr_t *attr,
                                        ma_barrier_mode_t mode) __THROW;

]])dnl END_REPLICATE
