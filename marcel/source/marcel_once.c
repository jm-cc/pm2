
/* This file has been autogenerated from source/nptl_mutex.c.m4 */
/*
 * PM2: Parallel Multithreaded Machine
 * Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */
#ifdef MARCEL_ONCE_ENABLED
#  include "marcel.h"
#  include <errno.h>
#  include "marcel_fastlock.h"
#  include <limits.h>

// XXX Vince, à corriger. On n'a pas lpt_mutex sur toutes les archis pour l'instant, donc j'ai mis un pmarcel_mutex pour que ça marchouille.
static marcel_mutex_t once_masterlock = MARCEL_MUTEX_INITIALIZER;
static marcel_cond_t once_finished = MARCEL_COND_INITIALIZER;
static int fork_generation = 0;	/* Child process increments this after fork. */

enum { NEVER = 0, IN_PROGRESS = 1, DONE = 2 };

/* If a thread is canceled while calling the init_routine out of
   marcel once, this handler will reset the once_control variable
   to the NEVER state. */

static void marcel_once_cancelhandler(void *arg)
{
	marcel_once_t *once_control = arg;

	marcel_mutex_lock(&once_masterlock);
	*once_control = NEVER;
	marcel_mutex_unlock(&once_masterlock);
	marcel_cond_broadcast(&once_finished);
}
int marcel_once(marcel_once_t * once_control, 
	void (*init_routine)(void))
{
        LOG_IN();
	/* flag for doing the condition broadcast outside of mutex */
	int state_changed;

	static int _inited = 0;
	if (!_inited) {
		marcel_init_section(MA_INIT_MAIN_LWP);
		_inited = 1;
	}

	/* Test without locking first for speed */
	if (*once_control == DONE) {
		READ_MEMORY_BARRIER();
                LOG_RETURN(0);
	}
	/* Lock and test again */
	
	state_changed = 0;
	
	marcel_mutex_lock(&once_masterlock);
	
	/* If this object was left in an IN_PROGRESS state in a parent
	   process (indicated by stale generation field), reset it to NEVER. */
	if ((*once_control & 3) == IN_PROGRESS && (*once_control & ~3) != fork_generation)
		*once_control = NEVER;
	
	/* If init_routine is being called from another routine, wait until
	   it completes. */
	while ((*once_control & 3) == IN_PROGRESS) {
		marcel_cond_wait(&once_finished, &once_masterlock);
	}
	/* Here *once_control is stable and either NEVER or DONE. */
	if (*once_control == NEVER) {
		*once_control = IN_PROGRESS | fork_generation;
		marcel_mutex_unlock(&once_masterlock);
		marcel_cleanup_push(marcel_once_cancelhandler, once_control);
		init_routine();
		marcel_cleanup_pop(0);
		marcel_mutex_lock(&once_masterlock);
		WRITE_MEMORY_BARRIER();
		*once_control = DONE;
		state_changed = 1;
	}
	marcel_mutex_unlock(&once_masterlock);
	
	if (state_changed)
		marcel_cond_broadcast(&once_finished);
	
        LOG_RETURN(0);
}

#  ifdef MA__IFACE_PMARCEL
int pmarcel_once(pmarcel_once_t * once_control, 
	void (*init_routine)(void))
{
        LOG_IN();
	/* flag for doing the condition broadcast outside of mutex */
	int state_changed;

	static int _inited = 0;
	if (!_inited) {
		marcel_init_section(MA_INIT_MAIN_LWP);
		_inited = 1;
	}

	/* Test without locking first for speed */
	if (*once_control == DONE) {
		READ_MEMORY_BARRIER();
                LOG_RETURN(0);
	}
	/* Lock and test again */
	
	state_changed = 0;
	
	marcel_mutex_lock(&once_masterlock);
	
	/* If this object was left in an IN_PROGRESS state in a parent
	   process (indicated by stale generation field), reset it to NEVER. */
	if ((*once_control & 3) == IN_PROGRESS && (*once_control & ~3) != fork_generation)
		*once_control = NEVER;
	
	/* If init_routine is being called from another routine, wait until
	   it completes. */
	while ((*once_control & 3) == IN_PROGRESS) {
		marcel_cond_wait(&once_finished, &once_masterlock);
	}
	/* Here *once_control is stable and either NEVER or DONE. */
	if (*once_control == NEVER) {
		*once_control = IN_PROGRESS | fork_generation;
		marcel_mutex_unlock(&once_masterlock);
		marcel_cleanup_push(marcel_once_cancelhandler, once_control);
		init_routine();
		marcel_cleanup_pop(0);
		marcel_mutex_lock(&once_masterlock);
		WRITE_MEMORY_BARRIER();
		*once_control = DONE;
		state_changed = 1;
	}
	marcel_mutex_unlock(&once_masterlock);
	
	if (state_changed)
		marcel_cond_broadcast(&once_finished);
	
        LOG_RETURN(0);
}
#  endif

#endif /* MARCEL_ONCE_ENABLED */

