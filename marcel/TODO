TODOs dans le code :)

sem_P/sem_V est coûteux par rapport à un yield

pmarcel + valgrind a l'air de merder sur la TLS: valgrind met 0x3 pour le gs du main, mais dans le traitant de signal on se retrouve avec un gs = 0

Ajouter des fonctions printf, malloc etc. dans Marcel qui appelle
marcel_extlib_protect puis __printf, __malloc, etc. -> pukabi

examples/create: mesurer séparément création sur le même processeur et sur un autre processeur

topologie: pouvoir demander à utiliser seulement un processeur logique par core à l'aide d'une option --marcel-.

dans marcel.h,
#include <stdio.h>
#define printf marcel_printf
#define fprintf marcel_fprintf
#define read marcel_read
...
?

Faire une libtopology, du genre pouvoir faire
const struct topo_info *info;
int i,j;
libtopo_init();
for (i = 0; i < libtopo_nblevels(); i++) {
	printf("level %d has %d items\n", libtopo_level_nbelems(i));
	for (j = 0; j < libtopo_level_nbelems(i); j++) {
		info = libtopo_item(i,j);
		printf("%*s: \n", 2*i, "", j);
		switch(info->type) {
		case LIBTOPO_NODE: printf("node %lu", info->node.num); break;
		case LIBTOPO_CORE: printf("core %lu", info->core.num); break;
		...
		}
	}
}
i = libtopo_node_level();
for (j = 0; j < libtopo_level_nbelems(i); j++) {
	info = libtopo_item(i,j);
	printf("node %lu has %luGB mem\n", info->node.num, info->node.mem>>20);
}
libtopo_fini();

Traquer les régressions: cf ~benchmarks/results/marcel/*.png. Parfois c'est des changements de libc/gcc, parfois changement de stratégie d'ordonnancement par défaut.

Mettre en place un cron qui lance posixtestsuite et trace un courbe

Benchs OpenMP EPCC.

Signaux: SA_RESETHAND

topology: implémenter un tri topologique pour qu'on n'ait pas à donner les niveaux dans l'ordre.

Nettoyer distinction LWP/VP: les VP (Processeurs Virtuels) sont quasiment toujours ce que l'on considère. Les LWP ne sont que les threads noyaux qui permettent de les implémenter, dans le cas de détournement d'un appel bloquant sur un VP par exemple, le LWP courant est remplacé par un autre LWP.

Problème: la doc d'AIX indique qu'on ne devrait pas utiliser de fonction pthread dans les traitants de signaux.... Apparemment un problème de réentrance (pthread_* prennent un gros mutex global). Il suffirait sans doute juste masquer les signaux autour des appels pthread_()

marcel dont_use_pthread: ajouter les hooks pour prévenir gdb quand on appelle clone().

messages de debug: les préfixer avec Marcel (pour les gens qui utilisent à la fois Marcel, Madeleine, Padico, ...)

Utiliser les builtin atomics __sync_* de gcc >= 4.1 (dans info gcc, C Extensions, Atomic builtins). Vérifier s'ils sont au moins aussi efficaces que nos static inline, auquel cas enlever ces derniers.
Ou bien utiliser plutôt la libatomic-ops (en l'incluant dans les sources pour les nombreux cas où il n'est pas dispo sur la machine de compil) et lui ajouter le support des builtin atomics de gcc. Attention, il leur manque des opérations par rapport à ce que l'on a (e.g. alpha)

Déplacer dans tbx les trucs qui n'ont rien à faire dans marcel (atomic, bitops, testandset, compareexchange, spinlock de base).

pmarcel_spin_* en mono.

Attributs de threads ou de bulles: une fonction marcel_(bubble_)?attr_read(const char *filename, marcel_attr_t *attr); qui lit dans un fichier les attributs à donner.

pmarcel_create() avec PTHREAD_SCOPE_SYSTEM: les paramètres du lwp supplémentaire devraient être ceux d'attr.

Réécrire la tambouille split de Vince pour générer un bête marcel.h et marcel-internal.h

changement de contexte/pile: dans asm-generic, utiliser make context & co comme implémentation par défaut.

Compiler avec g++ pour les cas (rares) où c'est le seul moyen de linker avec du code c++. Pb: il y a plein de casts implicites en void* partout, des opérations arithmétiques sur void*... Demander à Marc sur quels systèmes c'est nécessaire.

Émulation d'un graphe de tâches: des threads qu'on ne réveille pas initialement, mais qu'on met en liste d'attente sur une variable conditionnelle qui est broadcastée à la fin du précédent. Pb: une tâche qui dépend de plusieurs...

Supporter le cpu hotplug, pour des systèmes qui nous préviendrait de la préemption, ou avec qui on pourrait négocier le nombre de LWPs.

RCU lists

Utiliser /dev/rtc sous linux pour avoir une fréquence de préemption plus grande que par défaut (100-1000Hz).

Tout ce qui est dans marcel_config.h devrait etre configurable dans la flavor.

Windows-smp:
Accepter une pile fournie par l'os pour les kthread.

