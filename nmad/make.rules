
# -*-makefile-*-

# NewMadeleine
# Copyright (C) 2006 (see AUTHORS file)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

.PHONY: all vars shlibs libs so_deps clean

# toplevel rule
# ----
ifdef APP
all: $(APP)
else
all: libs
endif

# variable display rule
# ----
vars:
	@echo -e MODULES          \\t$(MODULES)
	@echo -e EMODULES         \\t$(EMODULES)
	@echo
	@echo -e MOD_CPPFLAGS     \\t$(MOD_CPPFLAGS)
	@echo -e MOD_INCDIRS      \\t$(MOD_INCDIRS)
	@echo -e MOD_SRCDIRS      \\t$(MOD_SRCDIRS)
	@echo -e MOD_CFLAGS       \\t$(MOD_CFLAGS)
	@echo -e MOD_LDFLAGS      \\t$(MOD_LDFLAGS)
	@echo -e MOD_ELIBS        \\t$(MOD_ELIBS)
	@echo -e MOD_PATHS        \\t$(MOD_PATHS)
	@echo
	@echo -e PM2_CFLAGS       \\t$(PM2_CFLAGS)
	@echo -e PM2_LDFLAGS      \\t$(PM2_LDFLAGS)
	@echo -e PM2_SYS          \\t$(PM2_SYS)
	@echo
	@echo -e CPPFLAGS         \\t$(CPPFLAGS)
	@echo -e CFLAGS           \\t$(CFLAGS)
	@echo -e LDFLAGS          \\t$(LDFLAGS)
	@echo -e LIBS_FLAGS       \\t$(LIBS)
	@echo -e LIBS_DEP         \\t$(LIBS_DEP)


# main rule for building all selected libs
# ----
#
# the foreach loops build a string on the following pattern:
# libx.a(m/a.o m/b.o m/c.o) libx.a(n/d.o n/e.o n/f.o) liby.a(...) ...
# - first loop is on the modules
# - second loop is on the source dirs of each module
# the list of .o is generated out of the .c files found in each directory
#
libs: $(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(NM_PREFIX)lib$(NM_$(M)_LIB).a($(patsubst %.c,%.o,$(wildcard $(D)/*.c))))))

# main rule for building shared version of all selected libs
# ----
shlibs: $(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(NM_PREFIX)lib$(NM_$(M)_LIB).so))

# example rule for replacing 'eval' if the version of Make does not support it
# ----
so_deps:
	@echo -e "$(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),\n$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(NM_PREFIX)lib$(NM_$(M)_LIB).so: $(patsubst %.c,%.lo,$(wildcard $(D)/*.c))\n\t\$\$$(LD) -shared -o \$\$$@ \$\$$^)))"

ifeq ($(CONFIG_VERBOSE), y)
#/////////////////////////////| Verbose version |/////////////////////////////#
# library making rule
# ----
(%.o): %.o
	$(AR) cr $@ $<

# shared library making rules (generated, needs 'eval' func)
# ----
#
# arg 1: module
define SHLIB_verb_tmpl
ifndef RULE_$(1)
RULE_$(1):=1
$(NM_PREFIX)lib$(NM_$(1)_LIB).so: $(foreach D,$(NM_$(1)_PATH)/src $(NM_$(1)_SRCPATH),$(patsubst %.c,%.lo,$(wildcard $(D)/*.c)))
	$(LD) -shared -o $$@  $$^
endif
endef

$(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(eval $(call SHLIB_verb_tmpl,$(M)))))

# single file application building rule
# ----
#
# Note: "%:%.o" and "%:%.c" disables the corresponding implicit rules
%:	%.c
%:	%.o
%:	%.o $(LIBS_DEP)
	$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $< $(LDFLAGS) $(LIBS)

# compiling rule
# ----
#
# Note: "%.o:%.c" disables the implicit rule which does not
# chain the rule %.d
#
%.o:	%.c
%.o:	%.c %.d
	$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<

%.lo:	%.c %.d
	$(CC) -c $(CPPFLAGS) $(CFLAGS) $(PIC) -o $@ $<

# dependency generation rule
# ----
%.d:	%.c $(BUILD_CFG)
	set -e; rm -f $@; \
	$(CC) -MT $(patsubst %.c,%.o,$<) -MP -MM $(CPPFLAGS) $< | \
	sed 's,:,: $(MAKE_CONF) $(BUILD_CFG),' | \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' > $@;

# cleaning rule
# ----
clean:
	rm -vf $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.lo,$(wildcard $(D)/*.c))))
	rm -vf $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.o,$(wildcard $(D)/*.c))))
	rm -vf $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.d,$(wildcard $(D)/*.c))))
	rm -vf $(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(NM_PREFIX)lib$(NM_$(M)_LIB).a))
	rm -vf $(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(NM_PREFIX)lib$(NM_$(M)_LIB).so))
	rm -vf $(APP) $(patsubst %,%.o,$(APP)) $(patsubst %,%.d,$(APP))

else
#/////////////////////////////|  Terse version  |/////////////////////////////#

# library making rule
# ----
(%.o): %.o
	@echo -e "  [AR]\t  "$@ $<
	@$(AR) cr $@ $<

# shared library making rules (generated, needs 'eval' func)
# ----
#
# arg 1: module
define SHLIB_tmpl
ifndef RULE_$(1)
RULE_$(1):=1
$(NM_PREFIX)lib$(NM_$(1)_LIB).so: $(foreach D,$(NM_$(1)_PATH)/src $(NM_$(1)_SRCPATH),$(patsubst %.c,%.lo,$(wildcard $(D)/*.c)))
	@echo -e "  [LD]\t  "$$@ $$^
	@$(LD) -shared -o $$@  $$^
endif
endef

$(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(eval $(call SHLIB_tmpl,$(M)))))

# single file application building rule
# ----
#
# Note: "%:%.o" and "%:%.c" disables the corresponding implicit rules
%:	%.c
%:	%.o
%:	%.o  $(LIBS_DEP)
	@echo -e "  [LINK]\t  "$@
	@$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $< $(LDFLAGS) $(LIBS)

# compiling rule
# ----
#
# Note: "%.o:%.c" disables the implicit rule which does not
# chain the rule %.d
#
%.o:	%.c
%.o:	%.c %.d
	@echo -e "  [CC]\t  "$@
	@$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<

%.lo:	%.c %.d
	@echo -e "  [CC]\t  "$@
	@$(CC) -c $(CPPFLAGS) $(CFLAGS) $(PIC) -o $@ $<

# dependency generation rule
# ----
%.d:	%.c $(BUILD_CFG)
	@echo -e "  [DEP]\t  "$@
	@set -e; rm -f $@; \
	$(CC) -MT $(patsubst %.c,%.o,$<) -MP -MM $(CPPFLAGS) $< | \
	sed 's,:,: $(MAKE_CONF) $(BUILD_CFG),' | \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' > $@;

# cleaning rule
# ----
clean:
	@rm -f $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.o,$(wildcard $(D)/*.c))))
	@rm -f $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.lo,$(wildcard $(D)/*.c))))
	@rm -f $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.d,$(wildcard $(D)/*.c))))
	@rm -f $(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(NM_PREFIX)lib$(NM_$(M)_LIB).so))
	@rm -f $(foreach M,$(EMODULES),$(if $(NM_$(M)_LIB),$(NM_PREFIX)lib$(NM_$(M)_LIB).a))
	@rm -f $(APP) $(patsubst %,%.o,$(APP)) $(patsubst %,%.d,$(APP))

#/////////////////////////////////////////////////////////////////////////////#
endif

# echo rules
# ----
echo_CPPFLAGS:
	@echo $(CPPFLAGS)

echo_CFLAGS:
	@echo $(CFLAGS)

echo_LDFLAGS:
	@echo $(LDFLAGS)	

echo_LIBS:
	@echo $(LIBS)

echo_LIBS_DEP:
	@echo $(LIBS_DEP)

echo_NM_PREFIX:
	@echo $(NM_PREFIX)


# disabling of automatic intermediate file deletion
# ----
.SECONDARY: $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.o,$(wildcard $(D)/*.c))))
.SECONDARY: $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.lo,$(wildcard $(D)/*.c))))
.SECONDARY: $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.d,$(wildcard $(D)/*.c))))
.SECONDARY: $(APP:%=%.d)

# include the dependency files
# ====
ifneq ($(MAKECMDGOALS),clean)
-include $(APP:%=%.d) $(foreach M,$(EMODULES),$(foreach D,$(NM_$(M)_PATH)/src $(NM_$(M)_SRCPATH),$(patsubst %.c,%.d,$(wildcard $(D)/*.c))))
endif

#====================================================================

