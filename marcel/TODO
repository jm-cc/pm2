dans marcel.h,
#include <stdio.h>
#define printf marcel_printf
#define fprintf marcel_fprintf
#define read marcel_read
...
?

Nettoyer distinction LWP/VP: les VP (Processeurs Virtuels) sont quasiment toujours ce que l'on considère. Les LWP ne sont que les threads noyaux qui permettent de les implémenter, dans le cas de détournement d'un appel bloquant sur un VP par exemple, le LWP courant est remplacé par un autre LWP.

Problème: la doc d'AIX indique qu'on ne devrait pas utiliser de fonction pthread dans les traitants de signaux.... Apparemment un problème de réentrance (pthread_* prennent un gros mutex global). Il suffirait sans doute juste masquer les signaux autour des appels pthread_()

messages de debug: les préfixer avec Marcel (pour les gens qui utilisent à la fois Marcel, Madeleine, Padico, ...)

Utiliser les builtin atomics __sync_* de gcc >= 4.1 (dans info gcc, C Extensions, Atomic builtins). Vérifier s'ils sont au moins aussi efficaces que nos static inline, auquel enlever ces derniers

pmarcel_spin_* en mono.

Attributs de threads ou de bulles: une fonction marcel_(bubble_)?attr_read(const char *filename, marcel_attr_t *attr);

Émulation d'un graphe de tâches: des threads qu'on ne réveille pas initialement, mais qu'on met en liste d'attente sur une variable conditionnelle qui est broadcastée à la fin du précédent. Pb: une tâche qui dépend de plusieurs...

pmarcel_create() avec PTHREAD_SCOPE_SYSTEM: les paramètres du lwp supplémentaire devraient être ceux d'attr.

Réécrire la tambouille split de Vince pour générer un bête marcel.h et marcel-internal.h

changement de contexte/pile: dans asm-generic, utiliser make context & co comme implémentation par défaut.

Compiler avec g++ pour les cas (rares) où c'est le seul moyen de linker avec du code c++. Pb: il y a plein de casts implicites en void* partout, des opérations arithmétiques sur void*...

Supporter le cpu hotplug, pour des systèmes qui nous préviendrait de la préemption, ou avec qui on pourrait négocier le nombre de LWPs.

RCU lists

Utiliser /dev/rtc sous linux pour avoir une fréquence de préemption plus grande que par défaut (~1KHz).

Windows-smp:
Accepter une pile fournie par l'os pour les kthread.
