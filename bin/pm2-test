#!/usr/bin/env pm2sh

# PM2: Parallel Multithreaded Machine
# Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.


_PM2TEST_PROGNAME=pm2-test

_ALL_MODULES="`${PM2_ROOT}/bin/pm2-module modules`"

_DIRTY_ORDERED_MODULES="tbx marcel ntbx mad2 mad3 mad4 pm2 dsm"

pm2test_error() # msg
{
    echo $* >&2
    exit 1
}

pm2test_usage() # exit_code
{
    cat <<EOF
Usage: $_PM2TEST_PROGNAME { option } { modules }
  option:
    -h,--help      : show this help
    -q,--quiet     : do not be verbose
    -l1,--basic    : run a basic number of tests
    -l2,--normal    : run a reasonable number of tests for each PM2 module (default)
    -l3,--advanced : run a lot of tests to check more advanced features
    -l4,--torture  : check each line of C code to search for hidden bugs ;-)))
    -j N --jobs=N  : pass -j parameter to make so as to speed up compilation
  modules:
    "all" (default) or a subset of "$_ALL_MODULES"
EOF
    exit $1
}

to_be_tested() # module
{
    case " $_to_test " in
	*\ $1\ *)
	    echo "yes"
	    ;;
	*)
	    echo "no"
	    ;;
    esac
}

do_the_test()
{
    nbl=`wc -l < /tmp/pm2test_${USER}_expected`
    nbl=`expr $nbl + 0`

    # Compilation
    echo "Compiling program $prog..."
    #(cd $appdir; ${PM2_MAKE:-make} clean FLAVOR=$flavor)
    (cd $appdir; ${PM2_MAKE:-make} $jobs $prog FLAVOR=$flavor PM2_FLAVOR=$flavor) | sed -e 's/^/..../'
    [ $? -eq 0 ] || pm2test_error "Compilation failed"

    # Execution
    echo "Running program $prog..."
    ${PM2_ROOT}/bin/pm2conf -f $flavor $hosts
    if [ -z "$net" ] ; then
        (${PM2_ROOT}/bin/pm2load -f $flavor $prog $args; echo "$?" > /tmp/pm2test_${USER}_status) 2>&1 | tee /tmp/pm2test_${USER}_result | grep '^####'
    else
        (${PM2_ROOT}/bin/pm2load --protocol $net -f $flavor $prog $args; echo "$?" > /tmp/pm2test_${USER}_status) 2>&1 | tee /tmp/pm2test_${USER}_result | grep '^####'
    fi
#    ${PM2_ROOT}/bin/pm2load -f $flavor $prog $args > /tmp/pm2test_${USER}_result 2>&1
    [ `cat /tmp/pm2test_${USER}_status` -eq 0 ] || pm2test_error "Execution failed"

    # Le moment de verite
    echo "Checking results..."
    if [ "$sort_output" == "1" ] ; then
        echo "Sorting output"
        sort_command="sort"
    else
        sort_command="cat"
    fi
    grep -v '^####' /tmp/pm2test_${USER}_result | grep -v ".ssh.rc" | grep -v "X11 forwarding" | grep -v xauth | head -$nbl | $sort_command > /tmp/pm2test_${USER}_filtered
    if diff -u /tmp/pm2test_${USER}_expected /tmp/pm2test_${USER}_filtered ; then
	echo "Test ok!"
    else
	pm2test_error "Test failed: unexpected result (see /tmp/pm2test_${USER}_result)"
    fi

    # Destruction de la flavor
    #echo "Cleaning flavor & files..."
    #${PM2_ROOT}/bin/pm2-clean $flavor
    #${PM2_ROOT}/bin/pm2-flavor delete --flavor=$flavor

    # Destruction des fichiers residuels
    rm -rf /tmp/pm2test_${USER}_*
}

# Programme principal

_init_level=1 # first level to test
_level=2 # normal
_output_redirect=""
jobs=""

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
	    pm2test_usage 0
	    ;;
	-q|--quiet)
	    _output_redirect="> /dev/null 2>&1"
	    shift
	    ;;
	--basic|-l1)
	    _level=1
	    shift
	    ;;
	--normal|-l2)
	    _level=2
	    shift
	    ;;
	--advanced|-l3)
	    _level=3
	    shift
	    ;;
	--torture|-l4)
	    _level=4
	    shift
	    ;;
	-L1)
	    _level=1
	    _init_level=$_level
	    shift
	    ;;
	-L2)
	    _level=2
	    _init_level=$_level
	    shift
	    ;;
	-L3)
	    _level=3
	    _init_level=$_level
	    shift
	    ;;
	-L4)
	    _level=4
	    _init_level=$_level
	    shift
	    ;;
	--jobs|-j)
	    jobs="$1 $2"
	    shift
	    shift
	    ;;
	--jobs=*|-j*)
	    jobs=$1
	    shift
	    ;;
	--)
	    shift; break
	    ;;
	-*)
	    pm2test_error "Invalid option: $1"
	    ;;
	*)
	    break
	    ;;
    esac
done

if [ $# -eq 0 -o "$1" = all ] ; then
    _to_test="$_ALL_MODULES"
else
    _to_test=""
    for m in ${@:+"$@"}; do
	case " $_ALL_MODULES " in
	    *\ $m\ *)
		_to_test="${_to_test:+$_to_test }$m"
		;;
	    *)
		pm2test_error "\"$m\" is not a valid module name"
		;;
	esac
    done
fi

# Reordering of modules
_prefix=""
for _m in $_DIRTY_ORDERED_MODULES ; do
    case " $_to_test " in
	*\ $_m\ *)
	    _prefix="${_prefix:+${_prefix} }$_m"
	    ;;
	*)
	    ;;
    esac
done

_suffix=""
for _m in $_to_test ; do
    case " $_DIRTY_ORDERED_MODULES " in
	*\ $_m\ *)
	    ;;
	*)
	    _suffix="${_suffix:+${_suffix} }$_m"
	    ;;
    esac
done

_to_test="$_prefix $_suffix"

_l=$_init_level
while [ $_l -le $_level ]; do

    echo "*** Performing level $_l tests ***"

    for _m in $_to_test ; do

	if [ -d ${PM2_ROOT}/modules/$_m/test ]; then

	    cd ${PM2_ROOT}/modules/$_m/test
	    _tests=`ls test_*.level_$_l 2> /dev/null`
	    if [ -n "$_tests" ]; then

		for _f in $_tests ; do

		    # Affichage
		    _tst_name=`echo $_f | sed -e 's/test_\(.*\).level_.*/\1/g'`
		    echo "Level [$_l], module [$_m], Test [$_tst_name]"

                    # by default, do not sort the output
                    sort_output=0

		    # Source
		    . ./$_f

		    # Compilation, execution et verification des resultats
		    eval do_the_test $_output_redirect

		    echo "   [$_tst_name] did succeed."

		done

		echo ">>> Level [$_l] tests for module [$_m] did succeed!"
	    fi

	fi
    done

    echo ">>>>>> All Level [$_l] tests did succeed!"

    _l=`expr $_l + 1`
done

# ########## Happy end ##########
echo "         ************************"
echo "         *** Congratulations! ***"
echo "         ************************"

exit 0
