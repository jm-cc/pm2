handle SIGXFSZ noprint nostop
set $marcel_saved=0

define save-ctx
  if $marcel_saved==1
    printf "already saved ctx\n"
  else
    __save-ctx
    set $marcel_saved=1
  end
end
document save-ctx
Saves the current marcel context
Use rest-ctx to restore it
end

define set-ctx
  if $marcel_saved==0
    save-ctx
  end
  printf "switching to $arg0(0x%lx)\n", $arg0
  __set-ctx $arg0
end
document set-ctx
Switch to another marcel thread's context
end

define rest-ctx
  if $marcel_saved==0
    echo no context saved !\n
  else
    __rest-ctx
  end
end
document rest-ctx
Restores a previously-saved marcel context,
so as to be able to continue execution
end

define marcel-continue
  handle SIGALRM pass
  handle SIGVTALRM pass
  if $marcel_saved==1
    __rest-ctx
  end
end

define marcel-step
  handle SIGALRM nopass
  handle SIGVTALRM nopass
  if $marcel_saved==1
    __rest-ctx
  end
end

define hook-stop
  marcel-step
end

define hook-run
  marcel-continue
end
define hook-continue
  marcel-continue
end

define hook-step
  marcel-step
end
define hook-stepi
  marcel-step
end
define hook-next
  marcel-step
end
define hook-nexti
  marcel-step
end

define hook-finish
  marcel-continue
end
define hook-until
  marcel-continue
end
define hook-advance
  marcel-continue
end

define ma-printrq
  printf " %s", ($arg0)->name
end

define ma_rq_holder
  set $rq = ((ma_runqueue_t *)(((char*)$arg0)-(unsigned)(&(((ma_runqueue_t *)0)->hold))))
  print *$rq
  print $rq
end

define ma_holder_rq
  set $h = &((ma_holder_t *)$arg0)->hold
  print *$h
  print $h
end

define ma_bubble_holder
  set $b = ((marcel_bubble_t *)(((char*)$arg0)-(unsigned)(&(((marcel_bubble_t *)0)->hold))))
  print *$b
  print $b
end

define ma_holder_bubble
  set $h = &((marcel_bubble_t *)$arg0)->hold
  print *$h
  print $h
end

define ma_bubble_entity
  set $b = ((marcel_bubble_t *)(((char*)$arg0)-(unsigned)(&(((marcel_bubble_t *)0)->sched))))
  print *$b
  print $b
end

define ma_entity_bubble
  set $e = &((marcel_bubble_t *)$arg0)->sched
  print *$e
  print $e
end

define ma_task_entity
  set $t = ((marcel_task_t *)(((char*)$arg0)-(unsigned)(&(((marcel_task_t *)0)->sched.internal.entity))))
  print *$t
  print $t
end

define ma_entity_task
  set $e = &((marcel_task_t *)$arg0)->sched.internal.entity
  print *$e
  print $e
end

define ma-printholder
  if ($arg0) && ($arg0)->type == 0
    set $rq = ((ma_runqueue_t *)(((char*)$arg0)-(unsigned)(&(((ma_runqueue_t *)0)->hold))))
    ma-printrq $rq
  else
    printf " 0x%lx", $arg0
  end
end

define marcel-printthread
  set $state='?'
  if $arg0->sched.state == 0
    set $state='R'
  end
  if $arg0->sched.state == 1
    set $state='I'
  end
  if $arg0->sched.state == 2
    set $state='U'
  end
  if $arg0->sched.state == 16
    set $state='D'
  end
  if $arg0->sched.state == 64
    set $state='M'
  end
  if $arg0->sched.state == 128
    set $state='F'
  end
  if $arg0->sched.state == 256
    set $state='B'
  end
  if $arg0->sched.internal.entity.run_holder
    if $arg0->sched.internal.entity.holder_data
      set $sched_state='r'
    else
      set $sched_state='R'
    end
  else
    set $sched_state='B'
  end
  printf "0x%lx %16s %2d %c%c", \
    $arg0, $arg0->name, $arg0->sched.internal.entity.prio, $state, $sched_state
  if $arg0->sched.lwp
    printf " %2d", $arg0->sched.lwp->number
  end
  ma-printholder $arg0->sched.internal.entity.init_holder
  ma-printholder $arg0->sched.internal.entity.sched_holder
  ma-printholder $arg0->sched.internal.entity.run_holder
  printf "\n"
end
document marcel-printthread
Prints the state of a thread
end

define marcel-threads
  set $num=0
  while $num<ma__nb_vp
    set $vp=&marcel_topo_vp_level[$num]
    set $all_threads=&$vp->leveldata.vpdata.all_threads
    set $threade=$all_threads->next
    while $threade!=$all_threads
      set $thread=(marcel_t)(((char*)$threade)-(unsigned)(&(((marcel_t)0)->all_threads)))
      marcel-printthread $thread
      set $threade=$threade->next
    end
    set $num = $num + 1
  end
end

document marcel-threads
Prints a list of marcel threads
end

define marcel-allthreads
  marcel-threads
  set $first = &ma_list_lwp_head
  set $lwp = (ma_lwp_t) $first->next
  while $lwp != $first
    marcel-printthread $lwp->idle_task
    set $lwp = (ma_lwp_t) $lwp->lwp_list.next
  end
  set $first = &ma_list_lwp_head
  set $lwp = (ma_lwp_t) $first->next->next
  while $lwp != $first
    marcel-printthread $lwp->run_task
    set $lwp = (ma_lwp_t) $lwp->lwp_list.next
  end
  set $first = &ma_list_lwp_head
  set $lwp = (ma_lwp_t) $first->next
  while $lwp != $first
    marcel-printthread $lwp->postexit_task
    set $lwp = (ma_lwp_t) $lwp->lwp_list.next
  end
  set $first = &ma_list_lwp_head
  set $lwp = (ma_lwp_t) $first->next
  while $lwp != $first
    marcel-printthread $lwp->ksoftirqd_task
    set $lwp = (ma_lwp_t) $lwp->lwp_list.next
  end
end

document marcel-threads
Prints a list of all marcel threads (including Marcel-private threads)
end

#document marcel
#List of marcel-specific gdb functions:
#marcel-threads    -- shows Marcel user threads
#marcel-allthreads -- shows Marcel user and Marcel-private threads and
#set-ctx           -- switch context to a blocked thread
#rest-ctx          -- restore the context of the currently running thread
#
#Note: you can't switch context to a running thread through set-ctx: use the
#thread gdb command instead.
#end
