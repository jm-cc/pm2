dnl -*- linux-c -*-
include(scripts/marcel.m4)
dnl /***************************
dnl  * This is the original file
dnl  * =========================
dnl  ***************************/
/* This file has been autogenerated from __file__ */
/*
 * PM2: Parallel Multithreaded Machine
 * Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */
#include "marcel.h"

#include <errno.h>

#include "marcel_fastlock.h"

/************************BARRIERS**********************/
 
/********************/
/* barrierattr_init */
/********************/
PRINT_PTHREAD([[dnl
DEF_LIBPTHREAD(int, barrierattr_init,
	  (pthread_barrierattr_t * attr),
	  (attr))
DEF___LIBPTHREAD(int, barrierattr_init,
	  (pthread_barrierattr_t * attr),
	  (attr))
]])

REPLICATE_CODE([[dnl
int prefix_barrierattr_init(prefix_barrierattr_t *attr)
{
        LOG_IN();  
  ((struct prefix_barrierattr *)attr)->pshared = PREFIX_PROCESS_PRIVATE;
  ((struct prefix_barrierattr *)attr)->mode = MA_BARRIER_SLEEP_MODE;
        LOG_RETURN(0); 
}
]])

/***********************/
/* barrierattr_destroy */
/***********************/
PRINT_PTHREAD([[dnl
DEF_LIBPTHREAD(int, barrierattr_destroy,
	  (pthread_barrierattr_t * attr),
	  (attr))
DEF___LIBPTHREAD(int, barrierattr_destroy,
	  (pthread_barrierattr_t * attr),
	  (attr))
]])

REPLICATE_CODE([[dnl
int prefix_barrierattr_destroy (prefix_barrierattr_t *attr)
{
        LOG_IN();       
        /* Nothing to do.  */
        LOG_RETURN(0);
}
]])

/**************************/
/* barrierattr_getpshared */
/**************************/
PRINT_PTHREAD([[dnl
DEF_LIBPTHREAD(int, barrierattr_getpshared,
	  (pthread_barrierattr_t * __restrict attr, int* __restrict pshared),
	  (attr, pshared))
]])

REPLICATE_CODE([[dnl
int prefix_barrierattr_getpshared(__const prefix_barrierattr_t *attr, int *pshared)
{
	LOG_IN();
	*pshared = ((__const struct prefix_barrierattr *) attr)->pshared;
	LOG_RETURN(0);
}
]])

/**************************/
/* barrierattr_setpshared */
/**************************/
PRINT_PTHREAD([[dnl
DEF_LIBPTHREAD(int, barrierattr_setpshared,
	  (pthread_barrierattr_t * attr, int pshared),
	  (attr, pshared))
]])

REPLICATE_CODE([[dnl
int prefix_barrierattr_setpshared (prefix_barrierattr_t *attr, int pshared)
{
	LOG_IN();
	struct prefix_barrierattr *iattr;

	if (pshared != PREFIX_PROCESS_PRIVATE
	    && __builtin_expect(pshared != PREFIX_PROCESS_SHARED, 0)) {
		mdebug
		    ("prefix_barrierattr_setpshared : valeur pshared(%d)  invalide\n",
		    pshared);
		LOG_RETURN(EINVAL);
	}

	if (pshared == PREFIX_PROCESS_SHARED) {
		fprintf(stderr,
		    "prefix_barrierattr_setpshared : valeur PROCESS_SHARED non supportÃ©\n");
		LOG_RETURN(ENOTSUP);
	}
	iattr = (struct prefix_barrierattr *) attr;
	iattr->pshared = pshared;

	LOG_RETURN(0);
}
]])

/**************************/
/* barrierattr_getmode */
/**************************/
PRINT_PTHREAD([[dnl
DEF_LIBPTHREAD(int, barrierattr_getmode,
	  (pthread_barrierattr_t * __restrict attr, ma_barrier_mode_t * __restrict mode),
	  (attr, mode))
]])

REPLICATE_CODE([[dnl
int prefix_barrierattr_getmode(__const prefix_barrierattr_t *attr, ma_barrier_mode_t *mode)
{
	LOG_IN();
	*mode = ((__const struct prefix_barrierattr *) attr)->mode;
	LOG_RETURN(0);
}
]])

/**************************/
/* barrierattr_setmode */
/**************************/
PRINT_PTHREAD([[dnl
DEF_LIBPTHREAD(int, barrierattr_setmode,
	  (pthread_barrierattr_t * attr, ma_barrier_mode_t mode),
	  (attr, mode))
]])

REPLICATE_CODE([[dnl
int prefix_barrierattr_setmode (prefix_barrierattr_t *attr, ma_barrier_mode_t mode)
{
	LOG_IN();
	struct prefix_barrierattr *iattr;
	iattr = (struct prefix_barrierattr *) attr;
	iattr->mode = mode;
	LOG_RETURN(0);
}
]])


/***************************/
/* marcel_barrier_setcount */
/***************************/

int marcel_barrier_setcount(marcel_barrier_t * barrier, unsigned int count)
{
	LOG_IN();
	struct marcel_barrier *ibarrier;

	ibarrier = (struct marcel_barrier *) barrier;

	marcel_lock_acquire(&ibarrier->lock.__spinlock);
	ibarrier->init_count = count;
	ma_atomic_set(&ibarrier->leftB, count);
	ma_atomic_set(&ibarrier->leftE, 0);
	marcel_lock_release(&ibarrier->lock.__spinlock);

	LOG_RETURN(0);
}

/***************************/
/* marcel_barrier_getcount */
/***************************/

int marcel_barrier_getcount(const marcel_barrier_t * barrier,
    unsigned int *count)
{
	LOG_IN();
	*count = ((__const struct marcel_barrier *) barrier)->init_count;
	LOG_RETURN(0);
}

/***************************/
/* marcel_barrier_addcount */
/***************************/

int marcel_barrier_addcount(marcel_barrier_t * barrier, int addcount)
{
	LOG_IN();

	struct marcel_barrier *ibarrier;
	ibarrier = (struct marcel_barrier *) barrier;

	marcel_lock_acquire(&ibarrier->lock.__spinlock);
	ibarrier->init_count += addcount;
	ma_atomic_add(addcount, &ibarrier->leftB);
	marcel_lock_release(&ibarrier->lock.__spinlock);

	LOG_RETURN(0);
}
/****************/
/* barrier_init */
/****************/

PRINT_PTHREAD([[dnl
versioned_symbol (libpthread, lpt_barrier_init,
                  pthread_barrier_init, GLIBC_2_2);
]])

REPLICATE_CODE([[dnl
int prefix_barrier_init(prefix_barrier_t *barrier,
                        __const prefix_barrierattr_t *attr,
                        unsigned int count)
{
	LOG_IN();
	ma_barrier_mode_t mode = MA_BARRIER_SLEEP_MODE;
	struct prefix_barrier *ibarrier;

	if (__builtin_expect(count == 0, 0)) {
		mdebug("prefix_barrier_init : valeur count(%d) invalide\n",
		    count);
		LOG_RETURN(EINVAL);
	}

	if (attr != NULL) {
		struct prefix_barrierattr *iattr;
		iattr = (struct prefix_barrierattr *) attr;

		if (iattr->pshared != PREFIX_PROCESS_PRIVATE
		    && __builtin_expect(iattr->pshared != PREFIX_PROCESS_SHARED,
			0)) {
			/* Invalid attribute.  */
			mdebug
			    ("prefix_barrier_init : valeur attr->pshared(%d) invalide\n",
			    iattr->pshared);
			LOG_RETURN(EINVAL);
		}

		if (iattr->pshared == PREFIX_PROCESS_SHARED) {
			fprintf(stderr,
			    "prefix_barrier_init : process shared nt supported\n");
			LOG_RETURN(ENOTSUP);
		}
		
		mode = iattr->mode;
	}
	ibarrier = (struct prefix_barrier *) barrier;

	/* Initialize the individual fields.  */
	ibarrier->lock = (struct _prefix_fastlock) MA_PREFIX_FASTLOCK_UNLOCKED;
	ibarrier->init_count = count;
	ma_atomic_init(&ibarrier->leftB, count);
	ma_atomic_init(&ibarrier->leftE, 0);
	ibarrier->mode = mode;

	LOG_RETURN(0);
}
]])

/*******************/
/* barrier_destroy */
/*******************/

PRINT_PTHREAD([[dnl
versioned_symbol (libpthread, lpt_barrier_destroy,
                  pthread_barrier_destroy, GLIBC_2_2);
]])

REPLICATE_CODE([[dnl
int prefix_barrier_destroy (prefix_barrier_t *barrier)
{
	LOG_IN();
	struct prefix_barrier *ibarrier;
	int result = 0;

	ibarrier = (struct prefix_barrier *) barrier;

	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE)
	  prefix_lock_acquire(&ibarrier->lock.__spinlock);

	/* Are these all?  */
	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE) {
	  while (ma_atomic_read(&ibarrier->leftE)) {
	    blockcell c;
	    __prefix_register_spinlocked(&ibarrier->lock, marcel_self(),
					 &c);
	    INTERRUPTIBLE_SLEEP_ON_CONDITION_RELEASING(c.blocked,
		      prefix_lock_release(&ibarrier->lock.__spinlock),
		      prefix_lock_acquire(&ibarrier->lock.__spinlock));
	  }
	} else {	
	  while (ma_atomic_read(&ibarrier->leftE))
	    marcel_yield();
	}
	if (__builtin_expect(ma_atomic_read(&ibarrier->leftB) != ibarrier->init_count, 0)) {
	  /* Still used, return with an error.  */
	  result = EBUSY;
	}
	
	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE)
	  prefix_lock_release(&ibarrier->lock.__spinlock);
	LOG_RETURN(result);
}
]])

/****************/
/* barrier_wait */
/****************/

PRINT_PTHREAD([[dnl
versioned_symbol (libpthread, lpt_barrier_wait,
                  pthread_barrier_wait, GLIBC_2_2);
]])

REPLICATE_CODE([[dnl
int prefix_barrier_wait(prefix_barrier_t *barrier)
{
	LOG_IN();
	int result = 0;

	prefix_barrier_wait_begin(barrier);

	if (!prefix_barrier_wait_end(barrier))
		result = PREFIX_BARRIER_SERIAL_THREAD;
	LOG_RETURN(result);
}
]])


/**********************/
/* barrier_wait_begin */
/**********************/

REPLICATE_CODE([[dnl
int prefix_barrier_wait_begin(prefix_barrier_t *barrier)
{
	LOG_IN();
	struct prefix_barrier *ibarrier = (struct prefix_barrier *) barrier;

	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE)
	   prefix_lock_acquire(&ibarrier->lock.__spinlock);

	/* Are these all?  */
	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE)
	  while (ma_atomic_read(&ibarrier->leftE)) {
	    blockcell c;
	    __prefix_register_spinlocked(&ibarrier->lock, marcel_self(),
					 &c);
	    INTERRUPTIBLE_SLEEP_ON_CONDITION_RELEASING(c.blocked,
		      prefix_lock_release(&ibarrier->lock.__spinlock),
		      prefix_lock_acquire(&ibarrier->lock.__spinlock));
	  }
	else
	   while(ma_atomic_read(&ibarrier->leftE))
		marcel_yield();

	int ret = ma_atomic_dec_return(&ibarrier->leftB);

	if (!ret) {
	  if (ibarrier->mode == MA_BARRIER_SLEEP_MODE) {
	    /* Wake up everybody.  */
	    do {
	    }
	    while (__prefix_unlock_spinlocked(&ibarrier->lock));
	  }
	  ma_atomic_set(&ibarrier->leftB, ibarrier->init_count);
	  ma_atomic_set(&ibarrier->leftE, ibarrier->init_count);	
	}
	
	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE)
	  prefix_lock_release(&ibarrier->lock.__spinlock);

	LOG_RETURN(ret);
}
]])

/********************/
/* barrier_wait_end */
/********************/

REPLICATE_CODE([[dnl
int prefix_barrier_wait_end(prefix_barrier_t *barrier)
{
	struct prefix_barrier *ibarrier = (struct prefix_barrier *) barrier;

	LOG_IN();

	/* Make sure we are alone.  */
	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE)
	  prefix_lock_acquire(&ibarrier->lock.__spinlock);

	/* Are these all?  */
	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE) {
	  while (!ma_atomic_read(&ibarrier->leftE)) {
	    blockcell c;
	    __prefix_register_spinlocked(&ibarrier->lock, marcel_self(),
					 &c);
	    INTERRUPTIBLE_SLEEP_ON_CONDITION_RELEASING(c.blocked,
		    prefix_lock_release(&ibarrier->lock.__spinlock),
		    prefix_lock_acquire(&ibarrier->lock.__spinlock));
	  }
	} else {
	  while(!ma_atomic_read(&ibarrier->leftE))
	    marcel_yield();
	}
	int ret = ma_atomic_dec_return(&ibarrier->leftE);

	if (ibarrier->mode == MA_BARRIER_SLEEP_MODE) {
	  if (!ret) {
	    /* Wake up everybody.  */
	    do {
	    }
	    while (__prefix_unlock_spinlocked(&ibarrier->lock));
	  }
	
	  prefix_lock_release(&ibarrier->lock.__spinlock);
	}

	LOG_RETURN(ret);
}
]])
