\chapter{Customizing and debugging PM2}

\stamp $Id: customizing.tex,v 1.2 2001/04/12 16:00:58 bouge Exp $

\section{Introducing PM2 flavors}

You have now compiled and run a few PM2 programs. It is time to have a
look at the underlying machinery. The key feature is the notion of
\emph{flavor}, which we explain in detail below. Techically speaking,
a PM2 module is a library to be linked with your program. For
instance, module \|pm2| is library \|libpm2.a|. It is the job of the
\|pm2-config| utility to automagically generate the right compiling
and linking set of directives for the various libraries.
\begin{shell}
# Assuming you use csh...
setenv CC       "`pm2-config --cc`"
setenv CFLAGS   "`pm2-config --cflags`"
setenv LIBS     "`pm2-config --libs`" 
$CC $CFLAGS hello.c $LIBS -o hello
\end{shell}

It is important to realize at this point that the various PM2 modules
are independently compiled into \emph{separate} libraries. Yet, these
libraries are \emph{strongly} dependent one on each other, and they
are moreover dependent on the directives used in compiling the main
program. Therefore, uttermost care is needed in managing the various
sets of compiling and linking directives, as they \emph{must} be
consistent. 

Another aspect is that many users are interested in using
\emph{several} versions of PM2 at a time. For instance, you may wish
to compare the performance of a given user program on a Myrinet and on
a SCI network within the same benchmarking session. Or, you may use a
version of the program compiled with all the debugging features turned
on, and another one aggressively optimized. You may even compare a
version of PM2 compiled with some C~compiler against another version
compiled with another one.  Such kind of decisions have a strong
influence on the resulting PM2 libraries. Changing the network from
Myrinet to SCI amounts to recompiling the Madeleine module.  Changing
the mode from debugging to optimizing actually results in recompiling
all the libraries from scratch. This is a not trivial operation, which
consumes time and resources.

\begin{note}
  LB to RN: Is the name of the C compiler included in the flavor?
\end{note}

These two motivations have led to the notion of \emph{PM2 flavors}. A PM2
flavor is simply a set of compiling and linking options for the user
program and the various modules of PM2: Marcel, Madeleine, DSM, and
various other ancilliary modules. It is always assumed that the user
program and the modules have been compiled and linked with the
\emph{same} flavor. Unfortunately, there is no easy way to enforce
this in the C/Unix framework. The method used in PM2 to enforce global
consistency is following. 
\begin{itemize}
  
\item The list of all currently available flavors is provided by
  command \|pm2-flavor list|.

\item At any point, the currently active flavor is the value of shell
  variable \|PM2_FLAVOR|. Alternatively, most PM2 commands honor a
  \|--flavor=xxx| flag, so that you can easily manage several flavors
  at the same time within a makefile or a script. The default of
  \|xxx| is the value of variable \|PM2_FLAVOR|.
  
  \begin{warning}
    The \|PM2_FLAVOR| variable should most preferably be set to
    something! Remember to \|export| it if you use \|sh|-like
    shells.
  \end{warning}
  
\item Flavor \|xxx| is kept in file \|${PM2_HOME}/.pm2/flavors/xxx|, as
  provided by command \|pm2-flavor find --flavor=xxx|.
  \begin{warning}
    These files are automagically generated by the tools to be presented
    below. Do not edit by hand!
  \end{warning}
  
\item The list of options defined by flavor \|xxx| is provided by
  command \|pm2-flavor get --flavor=xxx|.

\item The internal consistency of flavor \|xxx| can be check by
  command  \|pm2-flavor check --flavor=xxx|. A flavor may be
  regenerated using command \|pm2-flavor regenerate --flavor=xxx|.

\item When a module is compiled with  flavor \|xxx|, then the
  resulting object code is placed into directory
  \|${PM2_BUILD_DIR}/xxx|. You may thus have several versions of PM2
  ready for use at the same time. 
  
\item To compile and link a user program with flavor \|xxx|, use the
  flags generated by commands \|pm2-config --cflags| and \|pm2-config
  --libs|, as examplified in the Makefile on
  Figure~\ref{prog:Makefile1}.

\end{itemize}

\section{Making your own, personal PM2 flavors}

You know \emph{what} a flavor is, and more or less \emph{why} it is
so. Let us now learn \emph{how} they can be used. Assume for instance
that you have been using flavor \|pm2| since your (PM2-)birth:
\|setenv PM2_FLAVOR pm2|. After having grown up, you are now starting
feeling somehow unsatisfied with it, almost frustrated. No problem:
PM2 has something for you: \|ezflavor|! (To be pronounced:
\emph{ee-zee-flavor}.)

The \|ezflavor| is a graphic interface to list, modify, check,
regenerate flavors all in once. As it is highly dependent on the
operating system you are running, you first have to compile it:
\begin{shell}
ravel% cd ${PM2_ROOT}/ezflavor 
ravel% make 
\end{shell}
The binary will be installed in
\|${PM2_HOME}/.pm2/bin/ezflavor_AAA_SSS|, where \|AAA| is your
architecture and \|SSS| is your system. The root script
\|${PM2_ROOT}/bin| automagically detects these parameters and redirect
your call to the right binary fil.  Therefore, you can use \|ezflavor|
from different platform without conflict.

\begin{figure}
\begin{center}
\includegraphics[width=0.7\linewidth]{Figures/ezflavor.eps}
\end{center}
\caption{The \|ezflavor| graphic interface to manage PM2 flavors}
\label{fig:ezflavor}
\end{figure}

The first step is to analyze your PM2-frustration. 
\begin{shell}
ravel% ezflavor &       # Better run it in background!
\end{shell}
Load in the current flavor \|pm2|.
\begin{itemize}
  
\item Select the \|pm2| module. The result is displayed on
  Figure~\ref{fig:ezflavor}. As you can see, only one option is turned
  on for this module: \|opt|, which makes the module run in optimized
  mode. 
  
\item Select the \|mad2| module: you can observe that the \|tcp|
  option is turned on, which makes Madeleine use the TCP/IP interface.
  
\item Select the \|marcel| module: you can observe the \|mono| option
  is turned on, which makes Marcel run on a single processor at each
  node (even though the node may be have multiple processors). Also,
  you can observe that the \|marcel_main| option is on, which
  specifies that the \|main| function of the C~program is provided by
  PM2 (actually, by Marcel). The user only specifies the auxiliary
  \|pm2_main| function, which is called by the real main function
  after some initialization. See for instance
  program~\ref{prog:hello}.
  
\item Finally, you can observe that the \|opt| option is enabled for
  the application itself: the user code is compiled with the
  \|-O6| option of the \|gcc| compiler.

\end{itemize}

Assume now that the real PM2 you are striving after is a PM2 with
fully-fledged debugging facilities. That right: what you need is a
\|pm2-debug| flavor, man! 

Check in the \|debug| option in the \|pm2| module.  Do
it for the application, too, and also for the \|mad2| module and
the \|dsm| module, too. Edit the name of the new flavor from \|pm2| to
\|pm2-debug|, and save it. The new flavor is checked for consistency
and saved under into the \|${PM2_HOME}/.pm2/flavors/pm2-debug|
file. You may check that the file actually contains the modified
flavor:
\begin{shell}
ravel% more ${PM2_HOME}/.pm2/flavors/pm2-debug
# Flavor pm2-debug
[...]
### SETTINGS: --pm2=debug --pm2=opt
[...]
### SETTINGS: --common=debug --common=opt
\end{shell}
Now, you have to recompile PM2 for this new flavor. Observe that you
do not have to explicitely set the \|PM2_FLAVOR| shell variable to
this new value. Just specify it in-line to the \|make| facility.
\begin{shell}
ravel% cd ${PM2_ROOT}
ravel% make PM2_FLAVOR=pm2-debug
[...]           # Well, a bunch of lines here...
\end{shell}
Everything should run smoothly, without any warning...

Once you are done, set the \|PM2_FLAVOR| variable to \|pm2-debug| and
compile your favorite PM2 program using a
``dynamic'' Makefile as the one on Figure~\ref{prog:Makefile1}. Well,
ideally, should you not make any difference with the \|pm2| run. 

Just for fun, modify the \|pm2-debug| flavor so as to enable the
\|isoaddr_trace| in the \|pm2| module, for instance. Recompile PM2
with this modified flavor. Recompile your program, for instance the
simplistic \|hello| on Figure~\ref{prog:hello} and run it. You should
see a lot of rather cryptic debugging information:
\begin{shell}
ravel% pm2load hello
Alloc page table(6291456)
index 0: 1
index 1: 1
index 2: 1      
[...]
isoaddr_malloc(65536)
isoaddr_malloc: got 16 slots locally
[...]
Hello World!
isoaddr_free: added to stack cache: affe0000 (index = 15)
[Threads : 2 created, 0 imported (0 cached)]
Flushing slot cache...
Flushing stack cache...
Flushing migration cache...
Isoaddr exited
\end{shell}

\begin{warning}
  be careful that the simple Makefile of Figure~\ref{prog:Makefile1}
  is not able to spot that the flavor has been modified. You will have
  to explicitely delete the object file to create a fresh, consistent
  one. 
\end{warning}

\paragraph{A note to the wizards.}

Experienced and hurried users may find that the ezflavor interface is
too heavy with respect to their needs. A tty-oriented  interface is
also available. It is called \|pm2-config-flavor|. The default is a 
line-oriented inteface:
\begin{shell}
ravel% pm2-config-flavor --text
================= Flavors management ==================
Existing flavors :
default leonie leoparse mad1 mad2 
marcel marcel-act marcel-actsmp marcel-mono marcel-smp 
pm2 pm2-mad1 pm2-mad2 pm2-marcel swann 

******************************************************
You can :
 0) create a flavor
 1) modify a flavor
 2) export a flavor
 3) import a flavor
 4) see    a flavor
 5) check  a flavor
 6) remove a flavor
 7) regenerate the flavors
 8) quit this program
\end{shell}

\begin{warning}
  In the current version of the system, no backup copy of a flavor is
  done prior editing. Be careful! 
\end{warning}

\begin{note}
  LB to RN: How should the user could recover the setting of the
  initial \|pm2| flavors?
\end{note}


\section{Debugging a PM2 program}

You may have already experienced problems in designing PM2 programs.
Debugging distributed, multithreaded programs is a difficult task, and
few tools already exist to assist the programmer in it. One of the
goal of the PM2 project is to contribute to the design of such tools,
but we have rather concentrated on \emph{performance} debugging.
Actually, PM2 is equipped with powerful profiling facilities, to be
introduced in Section~\ref{sec:profiling}. In this section, we rather
concentrate on the tools available at the level of programming.

The first step is to derive a sepcific flavor from your current one.
It should enable the options \|debug| and \|gdb| for all modules. With
the \|debug| option enabled, the modules of PM2 are careful to check
consistency conditions along the execution, so that abnormal situation
may be detected early. You may also wish to concentrate on memory
allocations by enabling the \|safe_malloc| and the \|parano_malloc|
options of module \|tbx|, the toolbox common to all PM2 modules. If
you suspect a problem with synchronization objects, you will find
useful options in the \|marcel| module, and in the \|dsm| module for
the inter-node synchronization actions induced by the DSM consistency
protocols.

Assuming that you are using the \|pm2| flavor, make up a
\|pm2-debug| one. Set your \|PM2_FLAVOR| shell variable to this value,
and recompile PM2 with this new flavor. 
\begin{shell}
ravel% setenv PM2_FLAVOR pm2-debug
ravel% cd ${PM2_ROOT}
ravel% make
\end{shell}
Then, recompile the programs of interest with this new flavor. (Make
sure that they are \emph{actually} recompiled: better delete the
objects files by hand!) 

A second step is to insert additional trace outputs within your source
code. Your are strongly advised to print on the \|stderr| error
descriptor instead of regular \|stdout| one. Also, you should always
use the \emph{thread-safe} version of \|(f)printf|, called \|t(f)printf|.
This will prevent multiple Marcel thread to print concurrently,
leading to scrambled text. Use the \|pm2logs| utility to view the
remote logs. It may be useful to force logging also on the main
node~0.: use \|pm2load -l|. Then, \|pm2logs| will recover exactly one
log per (logical) node.

You may also require ``immediate'' output from remote node by using
the \|pm2_(f)printf| routine. Each time it is called, the output is
packed into a buffer and sent to main node~0 to be immediately
displayed there. The output is prefixed by \|[t<i>]|, where |<i>| is
the logical number of the origin node.  This is quite convenient, but
the user has to be aware that the additional messages generated in
this way \emph{do interfere} with the original communication scheme of
the program under debugging. In particular, they may generate
additional deadlocks! Also, these additional message have to be
considered when designing the termination scheme of the program. The
\|pm2_halt| function should not be called by a node \emph{before} it
is guaranteed that all communications, whatever their origin, have
been handled by the daemon service threads. Deadlock may otherwise
occurred.

The \|pm2load| utility honors a number of options.  The most useful
one in a first place is \|pm2load -d|. It can be used with any flavor,
but it is most rewarding when the current flavor enables the \|gdb|
for all the modules and for the application. If run with the \|-d|
option, \|pm2load| opens a \|gdb| session on each (logical) node
declared in the configuration, with a display on your console. Just
typing \|r| (for \|run|) in the window will start the execution.
Observe that your have to type it in \emph{each} window!  Before
debugging your program at this level, you'd better downsize your code
to some manageable configuration, say~3 or 4~nodes. Observe also that
the windows of nodes other than the main one will only pop up after
the main node has started and called its \|pm2_main| routine. Then,
the node is blocked until you have typed \|r| in the window of each
subsidiary node. Before starting the nodes, you may add breakpoints
and require all kind of funcionalities provided by \|gdb|.  PM2 does
not close the windows at the end of the run, so that you can inspect
the final state of each node. Typing \|^D| in each window will close
it and terminate the program.

\begin{warning}
  A note to eye-impaired Solaris users. The \|gdb| facility is run
  within a \|xterm|. In certain recent versions of Solaris, the
  default for the \|xterm| background is a dark grey, which makes
  debugging *very* painful. You can change it to white by adding the
  following line to your \|${HOME}/.Xdefaults| file:
\begin{shell}
xterm*background: White
\end{shell}
Once it is done, reload your Xdefaults by issuing:
\begin{shell}
xrdb -load < ${HOME}/.Xdefaults
\end{shell}
\end{warning}

The user should be aware that \|gdb| is \emph{not} aware of the Marcel
threads, so that one cannot rely upon the value of the local variables
of the threads in general. Only the values of the global variables are
certified. Therefore, you may wish to equip your program with
additional debugging code to spy into static, global variables the
contents of dynamic, local variables.

\begin{note}
  LB to RN: Is the paragraph above correct?
\end{note}
