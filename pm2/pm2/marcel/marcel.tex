\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage[french]{babel}

\usepackage{xspace}

\newcommand{\marcel}{Marcel\xspace}

\newcommand{\f}[1]{\texttt{#1}}
\def\|#1|{\f{#1}}
\newcommand{\etc}{\ldots}

\title{Marcel intrinsic}
\begin{document}

\maketitle

\section{Événements extérieurs}
\subsection{Signaux}
\subsubsection{Signaux synchrones}
Aucun ne doit survenir durant l'exécution du code Marcel

Ils peuvent survenir en contexte utilisateur

\subsubsection{Signaux asynchrones}
Les handlers doivent être exécutés à travers
\|marcel\_signal\_execute\_handler| pour être retardés si nécessaire.

Exeption : le timer (voir plus bas)
\subsection{Upcalls}
\subsubsection{Upcalls synchrones}
\begin{description}
\item[block/new] peuvent être interrompu avec \|marcel\_upcall\_disable|
\end{description}

\subsubsection{Upcalls asynchrones}
\begin{description}
\item[unblock] 
\item[timer] 
\end{description}


\subsection{Timer}
\begin{itemize}
\item upcall ou signal
\item appel \|marcel\_timer\_timeslice\_expired()|
\end{itemize}


\section{Interfaces}
Les plus basses en premier.

\subsection{Contextes}
Les manipulations de contexte (changement de pile) doivent être faites
par l'intermédiaire des fonctions \texttt{marcel\_cxt\_*}. Ces
fonctions gèrent correctement le cas de l'Itanium avec sa pile et son
espace de stockage des registres.

\texttt{set\_sp()} \emph{ne doit jamais} être directement utilisé.

\subsection{Internal Locking}


\subsubsection{marcel\_preempt}
\begin{itemize}
\item authorise ou non la préemption de la tâche courante
\item peut être emboîté
\item la tâche courante ne peut pas bloquer en cas de préemption
  interdite [pour ACTIVATIONS]
\end{itemize}

\subsubsection{marcel\_raw\_spinlock}
\begin{itemize}
\item défini par architecture en assembleur
\item attente active
\item Pour en prendre un, la tâche en cours ne doit pas pouvoir être
  préemptée
\end{itemize}

\subsubsection{marcel\_spinlock}
les deux précédents en même temps



\subsection{Scheduler}

\subsection{Marcel}

\subsection{Posix}

\subsection{Pthread}


\section{Structures}

\subsection{Thread}
\begin{description}
\item[initialisation] \t{marcel\_create}
\item[destruction] \t{marcel\_exit}
\end{description}
marcel\_t

\subsection{LWP}

\subsection{File d'ordonancement}

\section{Locking}

\subsection{\texttt{lock\_task}}
\texttt{lock\_task} bloque l'ordonnanceur d'un LWP. Les autres LWP
continuent normalement.

\texttt{lock\_task} est réentrant. Il \emph{doit} être appelé une
seule fois lors de tout changement de contexte.

\texttt{lock\_task} \emph{doit} être pris avant toute utilisation de
spinlock (les autres verrous \marcel)

\texttt{lock\_task} empêche l'arrivé d'upcalls.

Si \texttt{lock\_task} est pris avant une interruption,
\texttt{marcel\_self()} n'est pas nécessairement valide.

\subsection{\texttt{sched\_lock}}
Privé à la file d'ordonnancement.

Verrouille l'accès à la file d'ordonnancement du LWP courrant.

Doit être pris quand on parcours cette file pour choisir un/des
threads.

\subsection{\texttt{state\_lock}}
Privé au thread.

Protège les changements d'états impliquant des changements de files
pour le thread courrant.

Verrouille l'accès à l'état d'un thread. (\emph{à compléter}).

Pris dans :
\begin{itemize}
\item \texttt{marcel\_set\_sleeping}
\item \texttt{marcel\_set\_frozen}
\item \texttt{marcel\_wake\_task}
\item \texttt{marcel\_give\_hand}
\item \texttt{marcel\_deviate}
\end{itemize}
Relaché dans :
\begin{itemize}
\item \texttt{marcel\_give\_hand}
\item ou \texttt{marcel\_unchain\_task\_and\_find\_next}
\item \texttt{marcel\_wake\_task}
\item \texttt{marcel\_deviate}
\end{itemize}

\newpage
\newenvironment{fonction}[2]{%
  \begin{description}%
  \item[\f{#1}]\textit{#2}%
    \begin{enumerate}%
    }{%
    \end{enumerate}%
  \end{description}%
}


\section{Démarrage}
\begin{enumerate}
\item la pile est placée à un endroit où \f{marcel\_self()} marche
\item \f{\marcel\_init\_data}
\item \etc
\item \f{\marcel\_start\_sched}
\end{enumerate}


\begin{fonction}{marcel\_init\_data}{}
\item \f{marcel\_win\_sys\_init}
\item \f{marcel\_debug\_init}
\item \f{marcel\_parse\_cmdline}
\item \f{marcel\_slot\_init}
\item \f{marcel\_sched\_init}
\item \f{marcel\_io\_init}
\end{fonction}

\begin{fonction}{marcel\_sched\_init}{}
\item main\_struct
\end{fonction}

\begin{fonction}{marcel\_lwp\_init}{Crée un LWP et l'insère dans la
    liste des LWPs}
\item \f{\_locked = 1}

\end{fonction}

\subsection{trace}

\begin{verbatim}
marcel_sched_init: -->
  marcel_sched_internal_init_marcel_thread: -->
  marcel_sched_internal_init_marcel_thread: <--
  marcel_lwp_init: -->
    marcel_create_internal: -->
      marcel_sched_internal_init_marcel_thread: -->
      marcel_sched_internal_init_marcel_thread: <--
      marcel_postexit_internal: -->
      marcel_postexit_internal: <--
      [Creation      : -1 (pid=0x3ffffc40:48). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
      marcel_sched_create: -->
      marcel_sched_create: <--
      marcel_sched_internal_create: -->
        marcel_sched_internal_create: -->
          [On new stack  : -1 (pid=0x3ffffc40:48). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
        marcel_sched_internal_create: <--
        [Father Restart:  0 (pid=0xbffefc40: 0). [3],   0 A,  0 S,  0 B,  0 F /  2 T]
      marcel_sched_internal_create: <--
    marcel_create_internal: <--
    [RunTask       : -1 (pid=0x3ffffc40:48). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
    marcel_sched_lwp_init: -->
      marcel_create_internal: -->
        marcel_sched_internal_init_marcel_thread: -->
        marcel_sched_internal_init_marcel_thread: <--
        marcel_postexit_internal: -->
        marcel_postexit_internal: <--
        [Creation      : -2 (pid=0x3ffefc40:1A). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
        marcel_sched_create: -->
        marcel_sched_create: <--
        marcel_sched_internal_create: -->
          marcel_sched_internal_create: -->
            [On new stack  : -2 (pid=0x3ffefc40:1A). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
          marcel_sched_internal_create: <--
          [Father Restart:  0 (pid=0xbffefc40: 0). [3],   0 A,  0 S,  0 B,  0 F /  2 T]
        marcel_sched_internal_create: <--
      marcel_create_internal: <--
      [IdleTask      : -2 (pid=0x3ffefc40:1A). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
      marcel_sched_internal_lwp_init: -->
      marcel_sched_internal_lwp_init: <--
    marcel_sched_lwp_init: <--
  marcel_lwp_init: <--
marcel_sched_init: <--

(0xbffefc40) marcel_pollid_create: -->
(0xbffefc40) marcel_pollid_create: <--
(0xbffefc40) marcel_sched_start: -->
(0x3ffffc40) [Preemption    : -1 (pid=0x3ffffc40:48). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) marcel_sched_internal_create: <--
(0x3ffffc40) marcel_lwp_start: -->
(0x3ffffc40) marcel_sched_lwp_start: -->
(0x3ffffc40) marcel_sched_internal_lwp_start: -->
(0x3ffffc40) marcel_insert_task: -->
(0x3ffffc40) [INSERT        : -1 (pid=0x3ffffc40:48). [0],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) [Activation    : -1 (pid=0x3ffffc40:48). [0],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) marcel_insert_task: <--
(0x3ffffc40) marcel_sched_internal_lwp_start: <--
(0x3ffffc40) marcel_sched_lwp_start: <--
(0x3ffffc40) marcel_threads_postexit_start: -->
(0x3ffffc40) marcel_create_internal: -->
(0x3ffffc40) marcel_sched_internal_init_marcel_thread: -->
(0x3ffffc40) marcel_sched_internal_init_marcel_thread: <--
(0x3ffffc40) marcel_postexit_internal: -->
(0x3ffffc40) marcel_postexit_internal: <--
(0x3ffffc40) [Creation      : -3 (pid=0x3ffdfc40: 8). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) marcel_sched_create: -->
(0x3ffffc40) marcel_sched_create: <--
(0x3ffffc40) marcel_sched_internal_create: -->
(0x3ffdfc40) marcel_sched_internal_create: -->
(0x3ffdfc40) [On new stack  : -3 (pid=0x3ffdfc40:28). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffdfc40) marcel_sched_internal_create: <--
(0x3ffffc40) [Father Restart: -1 (pid=0x3ffffc40:48). [0],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) marcel_sched_internal_create: <--
(0x3ffffc40) marcel_create_internal: <--
(0x3ffffc40) marcel_insert_task: -->
(0x3ffffc40) [INSERT        : -3 (pid=0x3ffdfc40:28). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) [Activation    : -3 (pid=0x3ffdfc40:28). [1],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) marcel_insert_task: <--
(0x3ffffc40) marcel_threads_postexit_start: <--
(0x3ffffc40) marcel_insert_task: -->
(0x3ffffc40) [INSERT        :  0 (pid=0xbffefc40: 0). [2],   0 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) [Activation    :  0 (pid=0xbffefc40: 0). [2],   1 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffffc40) marcel_insert_task: <--
(0x3ffffc40) marcel_exit_internal: -->
(0x3ffffc40) marcel_sem_P: -->
(0x3ffffc40) marcel_sem_P: <--
(0x3ffffc40) marcel_sem_V: -->
(0x3ffffc40) ma__marcel_find_and_yield_to_rt_task: -->
(0x3ffdfc40) [Preemption    : -3 (pid=0x3ffdfc40:28). [1],   1 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffdfc40) marcel_sched_internal_create: <--
(0x3ffdfc40) postexit_thread_func: -->
(0x3ffdfc40) [Start Postexit: -3 (pid=0x3ffdfc40:28). [0],   1 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffdfc40) marcel_atexit: -->
(0x3ffdfc40) marcel_atexit: <--
(0x3ffdfc40) marcel_sem_P: -->
(0x3ffdfc40) marcel_sem_P: <--
(0x3ffdfc40) [Postexit      : -3 (pid=0x3ffdfc40:28). [0],   1 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffdfc40) marcel_sem_V: -->
(0x3ffdfc40) marcel_sem_V: <--
(0x3ffdfc40) marcel_sem_P: -->
(0x3ffdfc40) marcel_give_hand: -->
(0x3ffdfc40) marcel_unchain_task_and_find_next: -->
(0x3ffdfc40) radical_next_task: -->
(0x3ffdfc40) next_runnable_task: -->
(0x3ffdfc40) next_runnable_task: <--
(0x3ffdfc40) radical_next_task: <--
(0x3ffdfc40) display_sched_queue: -->
(0x3ffdfc40) display_sched_queue: <--
(0x3ffdfc40) [UNCHAIN       : -3 (pid=0x3ffdfc40:28). [1],   1 A,  0 S,  0 B,  0 F /  2 T]
(0x3ffdfc40) [Blocking      : -3 (pid=0x3ffdfc40:28). [1],   1 A,  0 S,  1 B,  0 F /  2 T]
(0x3ffdfc40) marcel_unchain_task_and_find_next: <--
(0xbffefc40) [Preemption    :  0 (pid=0xbffefc40: 0). [2],   1 A,  0 S,  1 B,  0 F /  2 T]
(0xbffefc40) [MainTask      :  0 (pid=0xbffefc40: 0). [1],   1 A,  0 S,  1 B,  0 F /  2 T]
(0xbffefc40) marcel_sig_start_timer: -->
(0xbffefc40) marcel_sig_reset_timer: -->
(0xbffefc40) marcel_sig_reset_timer: <--
(0xbffefc40) marcel_sig_start_timer: <--
(0xbffefc40) marcel_sched_start: <--
(0xbffefc40) marcel_set_activity: -->
(0xbffefc40) marcel_set_activity: <--
(0xbffefc40) marcel_create_internal: -->
(0xbffefc40) marcel_sched_internal_init_marcel_thread: -->
(0xbffefc40) marcel_sched_internal_init_marcel_thread: <--
(0xbffefc40) marcel_postexit_internal: -->
(0xbffefc40) marcel_postexit_internal: <--
(0xbffefc40) [Creation      :  1 (pid=0x3ffffc40: 0). [1],   1 A,  0 S,  1 B,  0 F /  3 T]
(0xbffefc40) marcel_sched_create: -->
(0xbffefc40) marcel_sched_create: <--
(0xbffefc40) marcel_sched_internal_create: -->
(0x3ffffc40) marcel_sched_internal_create: -->
(0x3ffffc40) [On new stack  :  1 (pid=0x3ffffc40: 0). [1],   1 A,  0 S,  1 B,  0 F /  3 T]
(0x3ffffc40) marcel_sched_internal_create: <--
(0xbffefc40) [Father Restart:  0 (pid=0xbffefc40: 0). [2],   1 A,  0 S,  1 B,  0 F /  3 T]
(0xbffefc40) marcel_sched_internal_create: <--
(0xbffefc40) marcel_insert_task: -->
(0xbffefc40) [INSERT        :  1 (pid=0x3ffffc40: 0). [1],   1 A,  0 S,  1 B,  0 F /  3 T]
(0xbffefc40) [Activation    :  1 (pid=0x3ffffc40: 0). [1],   2 A,  0 S,  1 B,  0 F /  3 T]
(0xbffefc40) marcel_insert_task: <--
(0xbffefc40) marcel_create_internal: <--
(0xbffefc40) marcel_create_internal: -->
(0xbffefc40) marcel_sched_internal_init_marcel_thread: -->
(0xbffefc40) marcel_sched_internal_init_marcel_thread: <--
(0xbffefc40) marcel_postexit_internal: -->
(0xbffefc40) marcel_postexit_internal: <--
(0xbffefc40) [Creation      :  2 (pid=0x3ffcfc40: 0). [1],   2 A,  0 S,  1 B,  0 F /  4 T]
(0xbffefc40) marcel_sched_create: -->
(0xbffefc40) marcel_sched_create: <--
(0xbffefc40) marcel_sched_internal_create: -->
(0x3ffcfc40) marcel_sched_internal_create: -->
(0x3ffcfc40) [On new stack  :  2 (pid=0x3ffcfc40: 0). [1],   2 A,  0 S,  1 B,  0 F /  4 T]
(0x3ffcfc40) marcel_sched_internal_create: <--
(0xbffefc40) [Father Restart:  0 (pid=0xbffefc40: 0). [2],   2 A,  0 S,  1 B,  0 F /  4 T]
(0xbffefc40) marcel_sched_internal_create: <--
(0xbffefc40) marcel_insert_task: -->
(0xbffefc40) [INSERT        :  2 (pid=0x3ffcfc40: 0). [1],   2 A,  0 S,  1 B,  0 F /  4 T]
(0xbffefc40) [Activation    :  2 (pid=0x3ffcfc40: 0). [1],   3 A,  0 S,  1 B,  0 F /  4 T]
(0xbffefc40) marcel_insert_task: <--
(0xbffefc40) marcel_create_internal: <--
(0xbffefc40) marcel_create_internal: -->
(0xbffefc40) marcel_sched_internal_init_marcel_thread: -->
(0xbffefc40) marcel_sched_internal_init_marcel_thread: <--
(0xbffefc40) marcel_postexit_internal: -->
(0xbffefc40) marcel_postexit_internal: <--
(0xbffefc40) [Creation      :  3 (pid=0x3ffbfc40: 0). [1],   3 A,  0 S,  1 B,  0 F /  5 T]
(0xbffefc40) marcel_sched_create: -->
(0xbffefc40) marcel_sched_create: <--
(0xbffefc40) marcel_sched_internal_create: -->
(0x3ffbfc40) marcel_sched_internal_create: -->
(0x3ffbfc40) [On new stack  :  3 (pid=0x3ffbfc40: 0). [1],   3 A,  0 S,  1 B,  0 F /  5 T]
(0x3ffbfc40) marcel_sched_internal_create: <--
(0xbffefc40) [Father Restart:  0 (pid=0xbffefc40: 0). [2],   3 A,  0 S,  1 B,  0 F /  5 T]
(0xbffefc40) marcel_sched_internal_create: <--
(0xbffefc40) marcel_insert_task: -->
(0xbffefc40) [INSERT        :  3 (pid=0x3ffbfc40: 0). [1],   3 A,  0 S,  1 B,  0 F /  5 T]
(0xbffefc40) [Activation    :  3 (pid=0x3ffbfc40: 0). [1],   4 A,  0 S,  1 B,  0 F /  5 T]
(0xbffefc40) marcel_insert_task: <--
(0xbffefc40) marcel_create_internal: <--
(0xbffefc40) __marcel_join: -->
(0xbffefc40) marcel_sem_P: -->
(0xbffefc40) marcel_give_hand: -->
\end{verbatim}

\end{document}
