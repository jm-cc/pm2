\chapter{Installing PM2}

\stamp $Id: installing.tex,v 1.4 2001/04/18 15:13:13 bouge Exp $

This section describe how to install PM2 on your own machine.
Please, first check that your system configuration fits the
installation pre-requisites, especially with respect to the GNU
utilities as mentioned in Section~\ref{sec:tools}.

\section{PM2 pre-requisites}

PM2 is a highly portable and efficient environment and the current
software is yet available on a wide range of architectures. The
implementation is built on top of several distinct software
components: Marcel and Madeleine. we briefly review the currently
supported architectures and systems. 

\begin{note}
  Luc: There should be something alike for Madeleine.
  \|${PM2_ROOT}/INTERFACES|?
\end{note}

\subsection{Multithreading: Marcel}

Marcel is a POSIX-compliant thread package which provides extra
features, such as thread migration.  Marcel is currently available on
the following platforms, listed in the \|ARCHITECTURES| file of the
distribution:
\begin{shell}
ravel% more ${PM2_ROOT}/ARCHITECTURES
AIX/RS6K
FREEBSD/X86
IRIX/MIPS
LINUX/ALPHA
LINUX/PPC
LINUX/X86
OSF/ALPHA
SOLARIS/SPARC
SOLARIS/X86
UNICOS/ALPHA
\end{shell}


\subsection{Communication: Madeleine}

PM2 was initially designed with a preliminary version of the
Madeleine. This version is now obsolete and not maintained any longer;
it is referred to as \emph{Madeleine~I}. The current version of the
interface is called \emph{Madeleine~II}. The internal design is completely
different, and the new version is only partly compatible with the
preliminary one. This manual only introduces the Madeleine~II
communication interface, simply referred to as \emph{Madeleine} hereafter
when no confusion may occur.

Madeleine (that is, Madeleine~II) is a generic communication interface
which is able to fully exploit the low latency and the high bandwidth
of high-speed networks such as Myrinet or SCI. This PM2 communication
subsystem currently supports the following communication interfaces:
TCP, MPI (LAM-MPI, MPI-BIP), VIA, BIP (on top of Myrinet), SISCI (on
top of SCI) and SBP (on top of Fast-Ethernet).

\subsection{Required development tools}
\label{sec:tools}

As previously mentioned, PM2 as been designed to be easily portable
and only relies on the availability of the two following development
tools:
\begin{itemize}
  \small
\item GNU C Compiler \|gcc| (versions \|2.7.2.3|, \|2.8.1| and higher,
  or \|Egcs| versions);
\item GNU \|make| (versions \|3.7x.x|).
\end{itemize}
Also, PM2 includes a large number of shell scripts, which are assumed
to be run with the \emph{GNU utilities}. This is specially important
for \|expr|, \|tr|, \|head|, \|cut|, \|test|, etc. (version 2.0 or
higher), \|grep| (version 2.3), \|tar|, etc. 

\begin{warning}
  If you encounter installation problems, first make sure that you
  actually use the right version of these utilities!
\end{warning}
 
\begin{note}
  Luc: There should be a way of listing all utilities used in the
  scripts.
\end{note}

\begin{note}
  Luc: I do not understand what \|Egcs| means here. Olivier, please
  correct.
\end{note}

\section{Getting the PM2 software and help}

The PM2 archive containing all the necessary sources is available
from the PM2 web site at:
\begin{quote}
  \url{http://runtime.futurs.inria.fr/pm2/}
\end{quote}

Please, send an email to \url{pm2-users@ens-lyon.fr} if you encounter
problems with the PM2 software. However, please make sure first that
your problem is not already listed in the \emph{Frequently Asked
  Questions} Section~\ref{sec:faq}.

\section{Unpacking the PM2 distribution}

The PM2 archive can be extracted with one of the following commands
entered at the shell prompt:
\begin{shell}
ravel% tar xvfz pm2.tar.gz         # Using the GNU tar utility
\end{shell}
Once extracted, the PM2 distribution should be available under the
\|./pm2/| directory. This PM2 distribution is organized as follows:
\begin{center}
\begin{tabular}{|l|l|}
\hline 
\|bin| &        PM2 scripts \\
\|common| &     ??? \\
\|console| &    ??? \\
\|doc| &        Documentation files \\
\|ezflavor| &   Flavor configuration graphic interface \\
\|generic| &    ??? \\
\|leonie| &     ??? \\
\|leoparse| &   ??? \\
\|mad3| &       Communication subsystem \\
\|make| &       PM2 makefiles \\
\|marcel| &     Multithreading subsystem \\
\|modules| &    ??? \\
\|ntbx| &       Generic network management utility toolbox \\
\|pm2| &        PM2 \emph{en personne}! \\
\|pm2debug| &   PM2 debugging utilities (useful!) \\
\|profile| &    PM2 profiling utilities \\
\|sigmund| &    ??? \\
\|tbx| &        Generic PM2 utility toolbox \\
\hline
\end{tabular}
\end{center}
The \|mad1| directory contains the obsolete Madeleine~I communication
subsystem for backward reference, but should not be used any
longer. Just ignore it.

\begin{note}
  Luc to Olivier: Please fill up the holes!
\end{note}

\section{Setting the environment variables}

Several environment variables have to be set so that PM2 correctly.
\begin{itemize}
  
\item The \|PM2_HOME| variable must contain the path to the PM2
  administrative directory. The default is your home directory
  \|${HOME}|.  There, a \|.pm2| directory will be created to store
  various PM2 configuration files such as flavors, etc. and some
  system-dependent binary files such as \|ezflavor|, etc.
    
\item The \|PM2_ROOT| variable must contain the path to the PM2
  distribution root directory. Observe that PM2 does not write
  anything into this directory: a write-protected directory is OK.
  
\item The \|${PM2_ROOT}/bin| directory has to be included in
  the active search path.
  
\item Finally, all the files generated within the compilation process
  will be placed by default in the \|${PM2_HOME}/build| directory. Though
  this may be convenient in a first place, you may wish to keep these
  files in a more dedicated place. Just define the \|PM2_BUILD_DIR|
  shell variable to the desired value. Just note that this directory
  has to be reachable from any machine used in running PM2 programs.
  Be careful that \|/tmp| does not work in general!

\end{itemize}
You may wish to insert the following lines in your \|.cshrc| file (if
your default shell is \|csh|):
\begin{shell}
setenv PM2_HOME          ${HOME}
setenv PM2_ROOT          ${PM2_HOME}/pm2
setenv PATH              ${PATH}:${PM2_ROOT}/bin
setenv PM2_BUILD_DIR     ${PM2_HOME}/build  
\end{shell}

\begin{warning}
  Please make sure that these variables are correctly set within
  remote shell commands (i.e., scripts invoked by \|rsh|).
\end{warning} 

\section{Creating the standard PM2 flavors}
\label{subsec:compiling}

You should now create your own, private configuration database. It is
stored in the \|${PM2_HOME}/.pm2| file in your home directory. It is made
of a list of \emph{flavors}. A flavor is simply a (rather complex!)
series of options to be passed to the PM2 modules at compile-time
and/or at run-time. Flavors are organized so as to let you easily
maintain several versions of the PM2 system at the same time: for
instance, one compiled for the TCP protocol and one compiled for the
BIP/Myrinet protocol. Or, one compiled with the debugging checks on,
and one with the checks turned off for performance. 

\begin{warning}
  Do not forget to re-source your \|.cshrc| file to activate the new
  environment variables and the new search \|PATH|.
\end{warning}

\begin{shell}
ravel% source ${HOME}/.cshrc           # If you are running csh
ravel% cd ${PM2_ROOT}
ravel% make init
\end{shell} 
This checks the whole source hierarchy for consistency extracting the
option sets for each PM2 module if necessary. Then, this creates the
the various flavors. You can just list them by
\begin{shell}
ravel% pm2-flavor list
\end{shell}

In the following, we will advise you to use the \|pm2| standard
flavor. Just have a look at it to get a feeling of your current
flavor. You'll probably never dare do it again!
\begin{shell}
ravel% pm2-flavor get --flavor=pm2
\end{shell}
There are many more way of using the \|pm2-flavor| command. See
\|pm2-flavor -h| for the extensive on-line help.

\section{Selecting your own PM2 flavor}
\label{subsec:configuring}

Configuring PM2 is quite straightforward. The underlying platform is
automatically detected. Hence, there is no need to specify the
operating system/processor pair.

Configuring flavors is done through a set of external utilities to be
introduced later. We strongly discourage you to edit the flavor files
by hand.

The only interesting setting at this time is the underlying network
protocol selection, which is currently not desirable to be
auto-detected by the Madeleine~II communication library of PM2.  It is
set to TCP by default in the \|pm2| flavor, which should fit your
needs at least for the first runs. 
\begin{shell}
ravel% setenv PM2_FLAVOR pm2
\end{shell}

\section{Compiling the library}

You are now ready for the big thing: compiling the whole library.  No
files are created in the \|${PM2_ROOT}| directory, so that you can
compile and install PM2 from a CDROM. All executable will be placed
into the \|${PM2_BUILD_DIR}| directory. 

\begin{warning}
Remember that this directory
has to be accessible from all machines included in the PM2
configuration. A local \|/tmp| directory will not work!
\end{warning}

To launch the whole compilation, just invoke \|make|. 

\begin{warning}
Make sure you
use the \emph{right} version of the program (see above for detailed
specification). Only recent GNU versions will make it!
\end{warning}

\begin{shell}
ravel% cd ${PM2_ROOT}/pm2
ravel% make
\end{shell}
You may wish to precisely follow the compilation process, just set the
\|VERB| variable of the makefile to \|verbose|.
\begin{shell}
ravel% make VERB=verbose
\end{shell}

\section{Cleaning out everything}

The directory tree of the PM2 distribution may be cleaned at any time
from compiled objects and libraries using the command \|pm2clean|.
This may be needed to free some disk space when PM2 is not in use or
to force the whole PM2 distribution to be completely remade by a
subsequent \|make| call.
\begin{shell}
ravel% cd ${PM2_ROOT}/pm2
ravel% make clean
\end{shell}
Note that this does not affect your private \|.pm2| flavor file, nor
your \|build| directory. If wanted, they have to be removed by hand.

\begin{note}
  Luc: Is this still correct?
\end{note}


\section{Solving problems}

If something goes wrong at any point below this point, then you can
always activate the emergency repair tool provided by PM2.
\begin{shell}
ravel% cd ${PM2_ROOT}
ravel% make sos
\end{shell} 
This result into a listing of your current configuration, attempts to
rebuild the flavor database and clears the compiled PM2 library as
cleanly as possible. It should restore a fresh and safe configuration
for you, ready to restart the whole compilation. The output of the
command may look like:
\begin{shell}
********* Checking environment variables *********
PM2_HOME = 
FLAVOR = pm2
CURDIR = .../pm2
PM2_ROOT = .../pm2
PM2_BUILD_DIR = .../pm2/build
********* Refreshing files for current flavor *********
make[1]: Entering directory `.../pm2'
Re-generating flavor pm2...
flavor 'pm2' unmodified
Cleaning for flavor pm2...
make[1]: Leaving directory `.../pm2'
Humm... Well, all should be ok now!
\end{shell}
(Note that the final message is automatically generated!)

\section{Testing your first PM2 program}

\begin{warning}
  Please, make sure that your flavor is actually set to \|pm2|:
\begin{shell}
ravel% echo ${PM2_FLAVOR}
\end{shell}
\end{warning}

The PM2 library should now fully configured.  You are ready to compile
the example programs of the distribution.  Let's start with the
simplest one: \emph{Hello world!}, located in file \|hello.c|.
\begin{shell}
ravel% cd ${PM2_ROOT}/pm2/examples/simple
ravel% make hello
\end{shell}

The compiled version of our program is automatically placed into your
private \|build/${PM2_FLAVOR}| directory, but you need not bother with
this detail at this point: PM2 cares about it for you! Use the
\|pm2-which| command to learn where a file is physically located;
\begin{shell}
ravel% pm2-which hello
\end{shell}

\section{Specifying the configuration for execution}

The final step before execution is to specify the list of host names on
which the PM2 application is going to run. For this, use the
\|pm2-conf| command. My current machine is called \|ravel|, and the two
neighboring ones are called \|debussy| and \|faure| (well, this should
actually read \emph{Faur\'e}!).
\begin{shell}
ravel% pm2-conf ravel debussy faure
The current PM2 configuration contains 3 host(s) :
0 : ravel
1 : debussy
2 : faure
\end{shell}
PM2 will consider that processing node~0 is a process run by \|ravel|,
node~1 by \|debussy| and node~2 by \|faure|.  Observe that I select
here my current workstation as node~0. This is for convenience only,
but may machine could make it. Indeed, there is no reason why my local
machine should get enrolled in the execution of the program. In
running a PM2 on a dedicated cluster, the local machine is most
preferably out of the configuration.

\begin{warning}
  Just to avoid disturbing problems in the sequel, please make sure
  that you local machine is allowed to issue \|rsh| commands to each
  machine in the configuration, and that the directory \|${PM2_ROOT}|
  is actually shared by all of them. For instance, try:
\begin{shell}
ravel% pm2-all 'ls ${PM2_ROOT}'
\end{shell}
(Note the \|'| characters!)  This script issues a rsh command to each
node in the current configuration.  If you do not get the list of the
files in your current \|${PM2_ROOT}| directory, that is, either you
get nothing or a message like \|permission denied|, etc., then you are
in trouble!
\end{warning}

If \|rsh| does not work because of right permissions, a possible
turnaround is to use \|ssh| instead of \|rsh|:
\begin{shell}
ravel% setenv PM2_RSH ssh
\end{shell}

If it does not output the right list of files, then the remote
machines in the configuration are not correctly served by the network
fil system. PM2 cannot work, as it implicitely assumes that the
excutable of the program will be found on the remote machines at the
same place as it is on the local one.

If this is not possible to correct such problems, then it is still
possible to run all three PM2 \emph{virtual nodes} as three processes
of your local machine:
\begin{shell}
ravel% pm2-conf ravel ravel ravel
The current PM2 configuration contains 3 host(s) :
0 : ravel
1 : ravel
2 : ravel
\end{shell}

\section{Loading the program}

It remains to actually load and run the program.
\begin{shell}
ravel% pm2-load hello
[Threads : 2 created, 0 imported (0 cached)]
Hello world!
\end{shell}
Congratulations, you've run your first PM2 program! \|;-)|

You can see that our program generates two messages. The first one is
the expected \emph{Hello World!} message coming from the master
process with a call to the \|tprintf| PM2 routine. It is a simple
wrapper of the regular \|printf| Unix routine, to be used in
multithreaded context. The second one is some PM2 running statistics
related to the master process. Note that the output of the nodes
different from node~0 does not show up at the terminal. We will see
later how to get them.

\section{If everything else fails...}

Feedback from PM2 users showed that several common pitfalls may be
encountered at this time. If this is your case, please refer to
Section~\ref{sec:commonpitfalls}: \emph{Common Pitfalls}. 
