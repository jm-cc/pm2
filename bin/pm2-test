#!/usr/bin/env pm2-sh
#-*-sh-*-

# PM2: Parallel Multithreaded Machine
# Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.


_PM2_TEST_PROGNAME=pm2-test

_ALL_MODULES="`${PM2_ROOT}/bin/pm2-module modules`"

_DIRTY_ORDERED_MODULES="tbx marcel ntbx mad3 nmad pm2"

pm2_test_error() # msg
{
    echo $* >&2
    exit 1
}

pm2_test_error_file() # msg file
{
    echo "----------------------------------------" >&2
    cat $2
    echo "----------------------------------------" >&2
    pm2_test_error $1
}

pm2_test_usage() # exit_code
{
    cat <<EOF
Usage: $_PM2_TEST_PROGNAME { option } { modules }
  option:
    -h,--help      : show this help
    -q,--quiet     : do not be verbose
    -l1,--basic    : run a basic number of tests
    -l2,--normal   : run a reasonable number of tests for each PM2 module (default)
    -l3,--advanced : run a lot of tests to check more advanced features
    -l4,--torture  : check each line of C code to search for hidden bugs ;-)))
    -j N --jobs=N  : pass -j parameter to make so as to speed up compilation
    --tests XXX    : specify the tests to be run (by default all the tests of the specified level)
  modules:
    "all" (default) or a subset of "$_ALL_MODULES"
EOF
    exit $1
}

to_be_tested() # module
{
    case " $_to_test " in
	*\ $1\ *)
	    echo "yes"
	    ;;
	*)
	    echo "no"
	    ;;
    esac
}

do_the_test()
{
    file_prefix="/tmp/pm2test_${USER}"
    file_expected="${file_prefix}_expected"
    file_result="${file_prefix}_result"
    file_status="${file_prefix}_status"
    file_filtered="${file_prefix}_filtered"

    nbl=`wc -l < ${file_expected}`
    nbl=`expr $nbl + 0`

    # Compilation
    echo "Compiling program $prog..."
    CC=${CC:-$(pm2-config --flavor=$flavor --cc)}
    (cd $appdir && ${PM2_MAKE:-make} "CC=$CC" $jobs $prog FLAVOR=$flavor PM2_FLAVOR=$flavor; echo "$?" > $file_status) | sed -e 's/^/..../'
    [ `cat $file_status` -eq 0 ] || pm2_test_error "Compilation failed"

    # Execution
    echo "Running program $prog..."
    ${PM2_ROOT}/bin/pm2-conf -f $flavor $hosts
    if [ -z "$net" ] ; then
        (${PM2_ROOT}/bin/pm2-load --x11 -f $flavor $prog $args; echo "$?" > $file_status) 2>&1 | tee $file_result | grep '^####'
    else
        protocols=$(echo $net | tr ' ' '\012' | sed 's/^/--protocol /')
        (${PM2_ROOT}/bin/pm2-load --x11 $protocols -f $flavor $prog $args; echo "$?" > $file_status) 2>&1 | tee $file_result | grep '^####'
    fi
    [ `cat $file_status` -eq 0 ] || pm2_test_error_file "Execution failed" $file_result

    # Le moment de verite
    echo "Checking results..."
    if [ "$sort_output" == "1" ] ; then
        echo "Sorting output"
        sort_command="sort --ignore-case"
    else
        sort_command="cat"
    fi
    if [ "$check_all_lines" == "1" ] ; then
        # will compare all the lines of the output and not only the number
        # of lines present in the expected output file
        head_command="cat"
    else
        # will only compare the number of lines present in the
        # expected output file
        head_command="head -$nbl"
    fi
    grep -v '^####' $file_result | grep -v ".ssh.rc" | grep -v "X11 forwarding" | grep -v xauth | $head_command | $sort_command > $file_filtered
    if diff -u $file_expected $file_filtered ; then
	echo "Test ok!"
    else
	pm2_test_error_file "Test failed: unexpected result (see $file_result)" $file_filtered
    fi

    # Destruction des fichiers residuels
    rm -rf ${file_prefix}_*
}

# Programme principal

_init_level=1 # first level to test
_level=2 # normal
_output_redirect=""
jobs=""

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
	    pm2_test_usage 0
	    ;;
	-q|--quiet)
	    _output_redirect="> /dev/null 2>&1"
	    shift
	    ;;
	--basic|-l1)
	    _level=1
	    shift
	    ;;
	--normal|-l2)
	    _level=2
	    shift
	    ;;
	--advanced|-l3)
	    _level=3
	    shift
	    ;;
	--torture|-l4)
	    _level=4
	    shift
	    ;;
	-L1)
	    _level=1
	    _init_level=$_level
	    shift
	    ;;
	-L2)
	    _level=2
	    _init_level=$_level
	    shift
	    ;;
	-L3)
	    _level=3
	    _init_level=$_level
	    shift
	    ;;
	-L4)
	    _level=4
	    _init_level=$_level
	    shift
	    ;;
	-L5)
	    _level=5
	    _init_level=$_level
	    shift
	    ;;
	--jobs|-j)
	    jobs="$1 $2"
	    shift
	    shift
	    ;;
	--jobs=*|-j*)
	    jobs=$1
	    shift
	    ;;
        --tests)
            shift
            PM2_TESTS=$1
            shift
            ;;
	--)
	    shift; break
	    ;;
	-*)
	    pm2_test_error "Invalid option: $1"
	    ;;
	*)
	    break
	    ;;
    esac
done

if [ $# -eq 0 -o "$1" = all ] ; then
    _to_test="$_ALL_MODULES"
else
    _to_test=""
    for m in ${@:+"$@"}; do
	case " $_ALL_MODULES " in
	    *\ $m\ *)
		_to_test="${_to_test:+$_to_test }$m"
		;;
	    *)
		pm2_test_error "\"$m\" is not a valid module name"
		;;
	esac
    done
fi

# Reordering of modules
_prefix=""
for _m in $_DIRTY_ORDERED_MODULES ; do
    case " $_to_test " in
	*\ $_m\ *)
	    _prefix="${_prefix:+${_prefix} }$_m"
	    ;;
	*)
	    ;;
    esac
done

_suffix=""
for _m in $_to_test ; do
    case " $_DIRTY_ORDERED_MODULES " in
	*\ $_m\ *)
	    ;;
	*)
	    _suffix="${_suffix:+${_suffix} }$_m"
	    ;;
    esac
done

_to_test="$_prefix $_suffix"

_l=$_init_level
while [ $_l -le $_level ]; do

    echo "*** Performing level $_l tests ***"

    for _m in $_to_test ; do

	if [ -d ${PM2_ROOT}/modules/$_m/test ]; then

	    cd ${PM2_ROOT}/modules/$_m/test
	    _tests=`ls test_*.level_$_l 2> /dev/null`
	    if [ -n "$_tests" ]; then

		for _f in $_tests ; do

                    # Affichage
                    _tst_name=`echo $_f | sed -e 's/test_\(.*\).level_.*/\1/g'`

                    is_test_selected=1
                    if [ -n "$PM2_TESTS" ] ; then
                        if [ "$(echo $PM2_TESTS|tr ' ' '\012' | grep $_tst_name)" == "" ] ; then
                            is_test_selected=0
                        fi
                    fi

                    if [ $is_test_selected == 1 ] ; then
                        echo "Level [$_l], module [$_m], Test [$_tst_name]"

                        # by default, do not sort the output
                        sort_output=0

		        # Source
                        . ./$_f

		        # Compilation, execution et verification des resultats
                        eval do_the_test $_output_redirect

                        echo "   [$_tst_name] did succeed."

                    fi

                done

		echo ">>> Level [$_l] tests for module [$_m] did succeed!"
	    fi

	fi
    done

    echo ">>>>>> All Level [$_l] tests did succeed!"

    _l=`expr $_l + 1`
done

# ########## Happy end ##########
echo "         ************************"
echo "         *** Congratulations! ***"
echo "         ************************"

exit 0
