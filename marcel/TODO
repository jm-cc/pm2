TODOs dans le code :)

pmarcel + valgrind a l'air de merder sur la TLS: valgrind met 0x3 pour le gs du main, mais dans le traitant de signal on se retrouve avec un gs = 0

Ajouter des fonctions printf, malloc etc. dans Marcel qui appelle marcel_extlib_protect puis __printf, __malloc, etc.

Pouvoir choisir l'ordonnanceur à bulle par une option --marcel-.

examples/create: mesurer séparément création sur le même processeur et sur un autre processeur

topologie: pouvoir demander à utiliser seulement un processeur logique par core à l'aide d'une option --marcel-.

dans marcel.h,
#include <stdio.h>
#define printf marcel_printf
#define fprintf marcel_fprintf
#define read marcel_read
...
?

ajouter des options pour alléger la structure marcel_descr & marcel_attr: delayed_activation, rwlock, deviatable, signals (dépend de deviatable), vpmask.

Traquer les régressions: cf ~benchmarks/results/marcel/*.png. Parfois c'est des changements de libc/gcc, parfois changement de stratégie d'ordonnancement par défaut.

Mettre en place un cron qui lance posixtestsuite et trace un courbe

Benchs OpenMP EPCC.

Signaux: SA_RESETHAND

topology: on devrait pouvoir spécifier manuellement la topologie de la machine.

topology: implémenter un tri topologique pour qu'on n'ait pas à donner les niveaux dans l'ordre. Aller lire /sys/devices/system/cpu/cpu*/cache/index*/shared_cpu_map pour le partage de cache. Aller lire /sys/Devices/system/cpu/cpu*/topology/* plutôt que parser /proc/cpuinfo qui n'est pas portable.

Nettoyer distinction LWP/VP: les VP (Processeurs Virtuels) sont quasiment toujours ce que l'on considère. Les LWP ne sont que les threads noyaux qui permettent de les implémenter, dans le cas de détournement d'un appel bloquant sur un VP par exemple, le LWP courant est remplacé par un autre LWP.

Problème: la doc d'AIX indique qu'on ne devrait pas utiliser de fonction pthread dans les traitants de signaux.... Apparemment un problème de réentrance (pthread_* prennent un gros mutex global). Il suffirait sans doute juste masquer les signaux autour des appels pthread_()

marcel dont_use_pthread: ajouter les hooks pour prévenir gdb quand on appelle clone().

messages de debug: les préfixer avec Marcel (pour les gens qui utilisent à la fois Marcel, Madeleine, Padico, ...)

Utiliser les builtin atomics __sync_* de gcc >= 4.1 (dans info gcc, C Extensions, Atomic builtins). Vérifier s'ils sont au moins aussi efficaces que nos static inline, auquel cas enlever ces derniers.
Ou bien utiliser plutôt la libatomic-ops (en l'incluant dans les sources pour les nombreux cas où il n'est pas dispo sur la machine de compil) et lui ajouter le support des builtin atomics de gcc. Attention, il leur manque des opérations par rapport à ce que l'on a (e.g. alpha)

Déplacer dans tbx les trucs qui n'ont rien à faire dans marcel (atomic, bitops, testandset, compareexchange, spinlock de base).

pmarcel_spin_* en mono.

Attributs de threads ou de bulles: une fonction marcel_(bubble_)?attr_read(const char *filename, marcel_attr_t *attr); qui lit dans un fichier les attributs à donner.

pmarcel_create() avec PTHREAD_SCOPE_SYSTEM: les paramètres du lwp supplémentaire devraient être ceux d'attr.

Réécrire la tambouille split de Vince pour générer un bête marcel.h et marcel-internal.h

changement de contexte/pile: dans asm-generic, utiliser make context & co comme implémentation par défaut.

Compiler avec g++ pour les cas (rares) où c'est le seul moyen de linker avec du code c++. Pb: il y a plein de casts implicites en void* partout, des opérations arithmétiques sur void*... Demander à Marc sur quels systèmes c'est nécessaire.

Émulation d'un graphe de tâches: des threads qu'on ne réveille pas initialement, mais qu'on met en liste d'attente sur une variable conditionnelle qui est broadcastée à la fin du précédent. Pb: une tâche qui dépend de plusieurs...

Supporter le cpu hotplug, pour des systèmes qui nous préviendrait de la préemption, ou avec qui on pourrait négocier le nombre de LWPs.

RCU lists

Utiliser /dev/rtc sous linux pour avoir une fréquence de préemption plus grande que par défaut (100-1000Hz).

Windows-smp:
Accepter une pile fournie par l'os pour les kthread.
