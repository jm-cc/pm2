 
/* This file has been autogenerated from source/nptl_cond.c.m4 */
/*
 * PM2: Parallel Multithreaded Machine
 * Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */
#include "marcel.h"
#include <errno.h>
#include "marcel_fastlock.h"


#define ma_timercmp(a, b, CMP) \
  (((a)->tv_sec != (b)->tv_sec)? \
   ((a)->tv_sec CMP (b)->tv_sec): \
   ((a)->tv_usec CMP (b)->tv_usec))

int marcel_condattr_init (marcel_condattr_t *attr) {
        LOG_IN();
	memset (attr, '\0', sizeof (*attr));
	LOG_RETURN(0);
}
int marcel_condattr_destroy (marcel_condattr_t *attr) {
        LOG_IN();
        LOG_RETURN(0);
}
int marcel_cond_init (marcel_cond_t * __restrict cond,
	const marcel_condattr_t * __restrict attr) {
	LOG_IN();
	cond->__data.__lock =
	    (struct _marcel_fastlock) MA_MARCEL_FASTLOCK_UNLOCKED;
	cond->__data.__waiting = NULL;
	LOG_RETURN(0);
}
int marcel_cond_destroy (marcel_cond_t *cond) {
        LOG_IN();
        if (cond->__data.__waiting != NULL)
                LOG_RETURN(EBUSY);
        LOG_RETURN(0);
}
int marcel_cond_signal (marcel_cond_t *cond) {
	LOG_IN();
	__marcel_unlock(&cond->__data.__lock);
	LOG_RETURN(0);
}
int marcel_cond_broadcast (marcel_cond_t *cond) {
	LOG_IN();
	marcel_lock_acquire(&cond->__data.__lock.__spinlock);
	while (__marcel_unlock_spinlocked(&cond->__data.__lock));
	marcel_lock_release(&cond->__data.__lock.__spinlock);
	LOG_RETURN(0);
}
int marcel_cond_wait (marcel_cond_t * __restrict cond,
		marcel_mutex_t * __restrict mutex)
{
	LOG_IN();
	marcel_lock_acquire(&mutex->__data.__lock.__spinlock);
	marcel_lock_acquire(&cond->__data.__lock.__spinlock);
	__marcel_unlock_spinlocked(&mutex->__data.__lock);
	marcel_lock_release(&mutex->__data.__lock.__spinlock);
	{
		blockcell c;

		__marcel_register_spinlocked(&cond->__data.__lock,
				marcel_self(), &c);

		INTERRUPTIBLE_SLEEP_ON_CONDITION_RELEASING(c.blocked,
				marcel_lock_release(&cond->__data.__lock.__spinlock),
				marcel_lock_acquire(&cond->__data.__lock.__spinlock));
		marcel_lock_release(&cond->__data.__lock.__spinlock);
	}
	marcel_mutex_lock(mutex);
	LOG_RETURN(0);
}
int marcel_cond_timedwait(marcel_cond_t * __restrict cond,
	marcel_mutex_t * __restrict mutex,
	const struct timespec * __restrict abstime)
{
	struct timeval now, tv;
	unsigned long timeout;
	int ret = 0;
	LOG_IN();

	tv.tv_sec = abstime->tv_sec;
	tv.tv_usec = abstime->tv_nsec / 1000;

	gettimeofday(&now, NULL);

	if (ma_timercmp(&tv, &now, <=)) {
		LOG_RETURN(ETIMEDOUT);
	}

	timeout = JIFFIES_FROM_US(((tv.tv_sec * 1e6 + tv.tv_usec) -
		(now.tv_sec * 1e6 + now.tv_usec)));

	marcel_lock_acquire(&mutex->__data.__lock.__spinlock);
	marcel_lock_acquire(&cond->__data.__lock.__spinlock);
	__marcel_unlock_spinlocked(&mutex->__data.__lock);
	marcel_lock_release(&mutex->__data.__lock.__spinlock);
	{
		blockcell c;
		__marcel_register_spinlocked(&cond->__data.__lock,
		    marcel_self(), &c);

		mdebug("blocking %p (cell %p) in marcel_cond_timedwait %p\n",
		    marcel_self(), &c, cond);
		while (c.blocked && timeout) {
			ma_set_current_state(MA_TASK_INTERRUPTIBLE);
			marcel_lock_release(&cond->__data.__lock.__spinlock);
			timeout = ma_schedule_timeout(timeout);
			marcel_lock_acquire(&cond->__data.__lock.__spinlock);
		}
		if (c.blocked) {
			if (__marcel_unregister_spinlocked(&cond->__data.__lock,
				&c)) {
				pm2debug
				    ("Strange, we should be in the queue !!! (%s:%d)\n",
				    __FILE__, __LINE__);
			}
			ret = ETIMEDOUT;
		}
		marcel_lock_release(&cond->__data.__lock.__spinlock);
		mdebug("unblocking %p (cell %p) in marcel_cond_timedwait %p\n",
		    marcel_self(), &c, cond);
	}

	marcel_mutex_lock(mutex);
	LOG_RETURN(ret);
}

#ifdef MA__IFACE_PMARCEL
int pmarcel_condattr_init (pmarcel_condattr_t *attr) {
	return marcel_condattr_init(attr);
}
int pmarcel_condattr_destroy (pmarcel_condattr_t *attr) {
	return marcel_condattr_destroy(attr);
}
int pmarcel_condattr_getpshared (const pmarcel_condattr_t * __restrict attr,
	int* __restrict pshared) {
        LOG_IN();
	*pshared = attr->__data.value & 1;
        LOG_RETURN(0);
}
int pmarcel_condattr_setpshared (pmarcel_condattr_t *attr, int pshared) {
	int *valuep;
	LOG_IN();
	if (pshared != PMARCEL_PROCESS_PRIVATE
	    && __builtin_expect(pshared != PMARCEL_PROCESS_SHARED, 0)) {
		LOG_RETURN(EINVAL);
	}

	/* For now it is not possible to share a mutex variable.  */
	if (pshared != PMARCEL_PROCESS_PRIVATE) {
		LOG_RETURN(ENOTSUP);
	}

	valuep = &(attr)->__data.value;
	*valuep = (*valuep & ~1) | (pshared != PMARCEL_PROCESS_PRIVATE);
	LOG_RETURN(0);
}
int pmarcel_cond_init (pmarcel_cond_t * __restrict cond,
	const pmarcel_condattr_t * __restrict attr) {
	return marcel_cond_init(cond, attr);
}
int pmarcel_cond_destroy (pmarcel_cond_t *cond) {
	return marcel_cond_destroy(cond);
}
int pmarcel_cond_signal (pmarcel_cond_t *cond) {
	return marcel_cond_signal(cond);
}
int pmarcel_cond_broadcast (pmarcel_cond_t *cond) {
	return marcel_cond_broadcast(cond);
}
int pmarcel_cond_wait (pmarcel_cond_t * __restrict cond,
		pmarcel_mutex_t * __restrict mutex)
{
	LOG_IN();
	pmarcel_lock_acquire(&mutex->__data.__lock.__spinlock);
	pmarcel_lock_acquire(&cond->__data.__lock.__spinlock);
	mutex->__data.__owner = 0;
	__pmarcel_unlock_spinlocked(&mutex->__data.__lock);
	pmarcel_lock_release(&mutex->__data.__lock.__spinlock);
	{
		blockcell c;

		__pmarcel_register_spinlocked(&cond->__data.__lock,
				marcel_self(), &c);

		INTERRUPTIBLE_SLEEP_ON_CONDITION_RELEASING(c.blocked,
				pmarcel_lock_release(&cond->__data.__lock.__spinlock),
				pmarcel_lock_acquire(&cond->__data.__lock.__spinlock));
		pmarcel_lock_release(&cond->__data.__lock.__spinlock);
	}
	pmarcel_mutex_lock(mutex);
	LOG_RETURN(0);
}
int pmarcel_cond_timedwait(pmarcel_cond_t * __restrict cond,
	pmarcel_mutex_t * __restrict mutex,
	const struct timespec * __restrict abstime)
{
	struct timeval now, tv;
	unsigned long timeout;
	int ret = 0;
	LOG_IN();

	tv.tv_sec = abstime->tv_sec;
	tv.tv_usec = abstime->tv_nsec / 1000;

	gettimeofday(&now, NULL);

	if (ma_timercmp(&tv, &now, <=)) {
		LOG_RETURN(ETIMEDOUT);
	}

	timeout = JIFFIES_FROM_US(((tv.tv_sec * 1e6 + tv.tv_usec) -
		(now.tv_sec * 1e6 + now.tv_usec)));

	pmarcel_lock_acquire(&mutex->__data.__lock.__spinlock);
	pmarcel_lock_acquire(&cond->__data.__lock.__spinlock);
	mutex->__data.__owner = 0;
	__pmarcel_unlock_spinlocked(&mutex->__data.__lock);
	pmarcel_lock_release(&mutex->__data.__lock.__spinlock);
	{
		blockcell c;
		__pmarcel_register_spinlocked(&cond->__data.__lock,
		    marcel_self(), &c);

		while (c.blocked && timeout) {
			ma_set_current_state(MA_TASK_INTERRUPTIBLE);
			pmarcel_lock_release(&cond->__data.__lock.__spinlock);
			timeout = ma_schedule_timeout(timeout);
			pmarcel_lock_acquire(&cond->__data.__lock.__spinlock);
		}
		if (c.blocked) {
			if (__pmarcel_unregister_spinlocked(&cond->__data.__lock,
				&c)) {
				pm2debug
				    ("Strange, we should be in the queue !!! (%s:%d)\n",
				    __FILE__, __LINE__);
			}
			ret = ETIMEDOUT;
		}
		pmarcel_lock_release(&cond->__data.__lock.__spinlock);
	}

	pmarcel_mutex_lock(mutex);
	LOG_RETURN(ret);
}
#endif
