TODOs dans le code :)

sem_P/sem_V est coûteux par rapport à un yield

pmarcel + valgrind a l'air de merder sur la TLS: valgrind met 0x3 pour le gs du main, mais dans le traitant de signal on se retrouve avec un gs = 0
Possible que ce soit simplement
https://bugs.kde.org/show_bug.cgi?id=175984

examples/create: mesurer séparément création sur le même processeur et sur un autre processeur

topologie: pouvoir demander à utiliser seulement un processeur logique par core à l'aide d'une option --marcel-.

dans marcel.h,
#include <stdio.h>
#define printf marcel_printf
#define fprintf marcel_fprintf
#define read marcel_read
...
?

Traquer les régressions: cf ~benchmarks/results/marcel/*.png. Parfois c'est des changements de libc/gcc, parfois changement de stratégie d'ordonnancement par défaut.

Mettre en place un cron qui lance posixtestsuite et trace un courbe

Benchs OpenMP EPCC.

un mode PM2_BEGINNER avec des asserts partout

Compteurs de perfs: coloriser IPC -> séparer spinlock/rwlock/reste

cond_signal / mutex_unlock : attribut pour dire de passer la main tout de suite

mutex: attribut "prise courte (protection d'un objet)" -> endormissement "court"
pour les politiques de redistribution

piles des threads: localité par rapport aux n½uds, voire entre mami et
l'allocateur hiérarchique.

Signaux: SA_RESETHAND

Nettoyer distinction LWP/VP: les VP (Processeurs Virtuels) sont quasiment toujours ce que l'on considère. Les LWP ne sont que les threads noyaux qui permettent de les implémenter, dans le cas de détournement d'un appel bloquant sur un VP par exemple, le LWP courant est remplacé par un autre LWP.

Problème: la doc d'AIX indique qu'on ne devrait pas utiliser de fonction pthread dans les traitants de signaux.... Apparemment un problème de réentrance (pthread_* prennent un gros mutex global). Il suffirait sans doute juste masquer les signaux autour des appels pthread_()

marcel pthread: ajouter les hooks pour prévenir gdb quand on appelle clone().

messages de debug: les préfixer avec Marcel (pour les gens qui utilisent à la fois Marcel, Madeleine, Padico, ...)

Utiliser les builtin atomics __sync_* de gcc >= 4.1 (dans info gcc, C Extensions, Atomic builtins). Vérifier s'ils sont au moins aussi efficaces que nos static inline, auquel cas enlever ces derniers.
Ou bien utiliser plutôt la libatomic-ops (en l'incluant dans les sources pour les nombreux cas où il n'est pas dispo sur la machine de compil) et lui ajouter le support des builtin atomics de gcc. Attention, il leur manque des opérations par rapport à ce que l'on a (e.g. alpha)

Déplacer dans tbx les trucs qui n'ont rien à faire dans marcel (atomic, bitops, testandset, compareexchange, spinlock de base).

pmarcel_spin_* en mono.

Attributs de threads ou de bulles: une fonction marcel_(bubble_)?attr_read(const char *filename, marcel_attr_t *attr); qui lit dans un fichier les attributs à donner.

pmarcel_create() avec PTHREAD_SCOPE_SYSTEM: les paramètres du lwp supplémentaire devraient être ceux d'attr.

Réécrire la tambouille split de Vince pour générer un bête marcel.h et marcel-internal.h

changement de contexte/pile: dans asm-generic, utiliser make context & co comme implémentation par défaut.

Compiler avec g++ pour les cas (rares) où c'est le seul moyen de linker avec du code c++. Pb: il y a plein de casts implicites en void* partout, des opérations arithmétiques sur void*... Demander à Marc sur quels systèmes c'est nécessaire.

Émulation d'un graphe de tâches: des threads qu'on ne réveille pas initialement, mais qu'on met en liste d'attente sur une variable conditionnelle qui est broadcastée à la fin du précédent. Pb: une tâche qui dépend de plusieurs...

Supporter le cpu hotplug, pour des systèmes qui nous préviendrait de la préemption, ou avec qui on pourrait négocier le nombre de LWPs.

RCU lists

Utiliser /dev/rtc sous linux pour avoir une fréquence de préemption plus grande que par défaut (100-1000Hz).

Tout ce qui est dans marcel_config.h devrait etre configurable dans la flavor.

Windows-smp:
Accepter une pile fournie par l'os pour les kthread.

