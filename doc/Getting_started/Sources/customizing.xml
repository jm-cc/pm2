<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE TEXT SYSTEM "file:../xml2html/data/xml/DOCUMENT.dtd">

<TEXT>

<SUBSECTION TITLE="Introducing PM2 flavors">

<P>
You have now compiled and run a few PM2 programs. It is time to have a
look at the underlying machinery. The key feature is the notion of
<EM>flavor</EM>, which we will explain in detail below. Technically speaking,
a PM2 module is a library to be linked with your program. For
instance, the module <TT>pm2</TT> is attached to the library <TT>libpm2.a</TT>. It is the job of the
<TT>pm2-config</TT> utility to automatically generate the correct compiling
and linking set of directives for the various modules.

<PROGRAM FILE="./Progs/pm2config.txt"/>
</P>

<P>
It is important to realize at this point that the various PM2 modules
are independently compiled into <EM>separate</EM> libraries. Yet, these
libraries are <EM>strongly</EM> dependent one on each other, and they
are moreover dependent on the directives used in compiling the main
program. Therefore, uttermost care is needed in managing the various
sets of compiling and linking directives, as they <EM>must</EM> be
consistent. 
</P>

<P>
Another aspect is that many users are interested in using
<EM>several</EM> versions of PM2 at a time. For instance, you may wish
to compare the performance of a given user program on a Myrinet and on
a SCI network within the same benchmarking session. Or, you may use a
version of the program compiled with all the debugging features turned
on, and another one aggressively optimized. You may even compare a
version of PM2 compiled with some C<SPACE/>compiler against another
version compiled with another C<SPACE/>compiler.  Different decisions
will result in different PM2 libraries. Changing the network from
Myrinet to SCI requires a recompilation of the Madeleine module.  Changing
the mode from debugging to optimizing requires a total recompilation of
all the libraries from scratch. This is a not trivial operation, as it
consumes time and resources.
</P>

<P>
All these motivations have led to the notion of <EM>PM2 flavors</EM>. A PM2
flavor is simply a set of compiling and linking options for the user
program and the various modules of PM2: Marcel, Madeleine, DSM, and
various other ancillary modules. It is always assumed that the user
program and the modules have been compiled and linked with the
<EM>same</EM> flavor. Unfortunately, there is no easy way to enforce
this in the C/Unix framework. The method used in PM2 to enforce global
consistency is explained in the following.
<UL>
  
<LI>
<P>
 The list of all currently available flavors is provided by
  the command <TT>pm2-flavor list</TT>.

<PROGRAM FILE="./Progs/pm2flavorlist.txt"/>
</P>
</LI>

<LI>
<P>
 At any point, the currently active flavor is the value of the shell
  variable <TT>PM2_FLAVOR</TT>. Alternatively, most PM2 commands provide a
  <TT>--flavor=xxx</TT> flag, so that you can easily manage several flavors
  at the same time within a Makefile or a script. The default of
  <TT>xxx</TT> is the value of the variable <TT>PM2_FLAVOR</TT>.
  
  <WARNING>
    The <TT>PM2_FLAVOR</TT> variable should most preferably be set to
    a value! Remember to <TT>export</TT> it if you use <TT>sh</TT>-like
    shells.
  </WARNING>
</P>
</LI>

<LI>  
<P>
 The flavor <TT>xxx</TT> is kept in the file <TT>${PM2_HOME}/.pm2/flavors/xxx</TT>, as
  indicated by the command <TT>pm2-flavor find --flavor=xxx</TT>.

  <WARNING>
    These files are automatically generated by the tools to be presented
    below. Do not edit them by hand!
  </WARNING>

<PROGRAM FILE="./Progs/pm2flavorfind.txt"/>
</P>
</LI>

<LI>
<P>
 The list of options defined by the flavor <TT>xxx</TT> is provided by
  the command <TT>pm2-flavor get --flavor=xxx</TT>.

<PROGRAM FILE="./Progs/pm2flavorget.txt"/>
</P>
</LI>

<LI>
<P>
 The internal consistency of the flavor <TT>xxx</TT> can be checked with
  the command <TT>pm2-flavor check --flavor=xxx</TT>.

<PROGRAM FILE="./Progs/pm2flavorcheck.txt"/>
</P>
</LI>

<LI>
<P>
A flavor may be regenerated by using the command <TT>pm2-flavor regenerate --flavor=xxx</TT>.

<PROGRAM FILE="./Progs/pm2flavorregen.txt"/>
</P>
</LI>

<LI>
<P>
 When a module is compiled with the flavor <TT>xxx</TT>, then the
  resulting object code is created into the directory
  <TT>${PM2_BUILD_DIR}/xxx</TT>. You may thus have several versions of PM2
  ready for use at the same time.
</P>
</LI>

<LI>
<P>
 To compile and link a user program with the flavor <TT>xxx</TT>, use the
  flags generated by the commands <TT>pm2-config --cflags</TT> and <TT>pm2-config
  --libs</TT>, as shown in the Makefile in Program <REF LABEL="prog:Makefile1"/>.
</P>
</LI>
</UL>
</P>

</SUBSECTION>

<SUBSECTION TITLE="Creating your own, personal PM2 flavors" LABEL="sec:createFlavors">

<P>
You know now <EM>what</EM> a flavor is, and more or less <EM>why</EM> it is
so. Let us now learn <EM>how</EM> they can be used. Assume for instance
that you have been using the flavor <TT>pm2</TT> since your (PM2-)birth:
<TT>setenv PM2_FLAVOR pm2</TT>. After having grown up, you are now starting
feeling somehow unsatisfied with it, almost frustrated. No problem,
PM2 has something for you: <TT>ezflavor</TT>! (To be pronounced:
<EM>ee-zee-flavor</EM>)
</P>

<P>
The <TT>ezflavor</TT> utility is a graphic interface to list, modify, check,
and regenerate flavors all in once. As it is highly dependent on the
operating system you are running, you first have to compile it:

<PROGRAM FILE="./Progs/makeEzflavor.txt"/>
</P>

<P>
The binary will be created in the directory
<TT>${PM2_BUILD_DIR}/ezflavor/ezflavor/bin/</TT>. The root script to
invoke <TT>ezflavor</TT> is available from your <TT>PATH</TT> in
<TT>${PM2_ROOT}/bin/ezflavor</TT>, using your PM2 configuration, it
will automatically redirect your call to the binary file.
</P>

<P>
So now, let's start <TT>ezflavor</TT> so to analyze your PM2-frustration.

<PROGRAM FILE="./Progs/ezflavor.txt"/>
</P>

<IMAGE FILE="Figures/ezflavor" TITLE="The ezflavor graphic interface to manage PM2 flavors." SCALE="0.7" LABEL="fig:ezflavor"/>

<P>
Load in the current flavor <TT>pm2</TT>.
<UL>
  
<LI>
<P>
 Select the <TT>pm2</TT> module. The result is displayed on
  Figure <REF LABEL="fig:ezflavor"/>. As you can see, only one option is turned
  on for this module: <TT>opt</TT>, which makes the module run in optimized
  mode. 
</P>
</LI>

<LI>  
<P>
 Select the <TT>mad3</TT> module: you can observe that the <TT>tcp</TT>
  option is turned on, which makes Madeleine use the TCP/IP interface.
</P>
</LI>

<LI>
<P>  
 Select the <TT>marcel</TT> module: you can observe the <TT>mono</TT> option
  is turned on, which makes Marcel run on a single processor at each
  node (even though the node may be have multiple processors). Also,
  you can observe that the <TT>marcel_main</TT> option is on, which
  specifies that the <TT>main</TT> function of the C<SPACE/>program is provided by
  PM2 (actually, by Marcel). The user only specifies the auxiliary
  <TT>pm2_main</TT> function, which is called by the real <TT>main</TT> function
  after some initialization. See for instance
  Program <REF LABEL="prog:hello"/>.
</P>
</LI>

<LI>
<P>  
 Finally, you can observe that the <TT>opt</TT> option is enabled for
  the application itself: the user code is compiled with the
  <TT>-O6</TT> option of the <TT>gcc</TT> compiler.
</P>
</LI>

</UL>
</P>

<P>
Assume now that the real PM2 you are striving after is a PM2 with
fully-fledged debugging facilities. What you need is to create a new
flavor that we will called <TT>pm2-debug</TT> based on the
<TT>pm2</TT> one.
</P>

<P>
Select the <TT>debug</TT> option in the <TT>pm2</TT> module.  Do it
also for the application, and for the <TT>mad3</TT> and <TT>dsm</TT>
modules. Change the name of this new flavor from <TT>pm2</TT> to
<TT>pm2-debug</TT>, and save it (see Figure <REF LABEL="fig:ezflavor-create"/>).

<IMAGE FILE="Figures/ezflavor-create" TITLE="Creating a new flavor with ezflavor" SCALE="0.7" LABEL="fig:ezflavor-create"/>

The new flavor is checked for consistency and saved into the file
<TT>${PM2_HOME}/.pm2/flavors/pm2-debug</TT>. You may check that
the file actually contains the new settings:

<PROGRAM FILE="./Progs/flavor.txt"/>
</P>

<P>
Now, you have to recompile PM2 for this new flavor. Observe that you
do not have to explicitly set the <TT>PM2_FLAVOR</TT> shell variable to
this new value. Just specify it in-line to the <TT>make</TT> facility.

<PROGRAM FILE="./Progs/flavor2.txt"/>
</P>

<P>
Everything should run smoothly, without any warning...
</P>

<P>
Once you are done, set the <TT>PM2_FLAVOR</TT> variable to
<TT>pm2-debug</TT> and compile your favorite PM2 program using a
``dynamic'' Makefile as the one on Program <REF
LABEL="prog:Makefile1"/>. Ideally, you should not see any difference
with the <TT>pm2</TT> run.

<PROGRAM FILE="./Progs/flavor3.txt"/>
</P>

<P>
Just for fun, modify the <TT>pm2-debug</TT> flavor so as to enable the option
<TT>isoaddr_trace</TT> in the <TT>pm2</TT> module. Recompile PM2
with this modified flavor. Recompile your program, for instance the
simplistic <TT>hello</TT> on Program <REF LABEL="prog:hello"/> and run it. You should
see a lot of rather cryptic debugging information:

<PROGRAM FILE="./Progs/pm2loadflavor.txt"/>
</P>

<WARNING>
  Be careful that the simple Makefile of Program <REF LABEL="prog:Makefile1"/>
  is not able to spot that the flavor has been modified. You will have
  to explicitly delete the object file to create a fresh, consistent
  one. 
</WARNING>

<P>
It is often interesting to enable some options for <EM>all</EM> the
modules at the same time, together with the application. This can be
the case for example for the <TT>debug</TT>, <TT>gdb</TT>,
<TT>opt</TT> (optimization) and <TT>profile</TT> options.
<TT>ezflavor</TT> provides such a facility: click on
<TT>View</TT>/<TT>Common options/Display panel</TT> to open the
appropriate window, as shown on Figure <REF LABEL="fig:options"/>.
</P>

<IMAGE FILE="Figures/options" TITLE="The 'Common options' window of the ezflavor utility." SCALE="0.7" LABEL="fig:options"/>


<P>
<B>A note to the wizards.</B>

Experienced and hurried users may find that the <TT>ezflavor</TT> interface is
too heavy with respect to their needs. A tty-oriented interface is
also available. It is called <TT>pm2-config-flavor</TT>.

<PROGRAM FILE="./Progs/pm2configflavor.txt"/>
</P>

<P>
When modifying a flavor with the text version of
<TT>pm2-config-flavor</TT>, the commands to add and remove modules and
options are <TT>add [options/modules]</TT>, <TT>sub
[options/modules]</TT> and <TT>q</TT> to quit, as shown in the
following example:

<PROGRAM FILE="./Progs/pm2configflavor2.txt"/>
</P>

<WARNING>
  In the current version of the system, no backup copy of a flavor is
  done prior editing. Be careful! In case, you think you have really messed up with one of your flavors, it is always possible to delete it and regenerate it from scratch.

  <PROGRAM FILE="./Progs/pm2configflavorremove.txt"/>
</WARNING>

</SUBSECTION>

<SUBSECTION TITLE="Debugging a PM2 program">

<P>
You may have already experienced problems in designing PM2 programs.
Debugging distributed, multithreaded programs is a difficult task, and
only a few tools already exist to assist the programmer with this task. One of the
goal of the PM2 project is to contribute to the design of such tools,
but we have rather concentrated on <EM>performance</EM> debugging.
Actually, PM2 provides powerful profiling facilities, to be
introduced in Section <REF LABEL="sec:profiling"/>. In this section, we rather
concentrate on the available tools at the level of programming.
</P>

<P>
The first step is to derive a specific flavor from your current one.
It should enable the options <TT>debug</TT> and <TT>gdb</TT> for all the modules. By enabling
the <TT>debug</TT> option, PM2 modules will carefully check
consistency conditions at execution time, so that abnormal situations
may be detected early. You may also wish to concentrate on memory
allocations by enabling the <TT>safe_malloc</TT> and the <TT>parano_malloc</TT>
options of the module <TT>tbx</TT>, the toolbox used by all PM2 modules. If
you suspect a problem with synchronization objects, you will find
useful options in the <TT>marcel</TT> module, and in the <TT>dsm</TT> module for
the inter-node synchronization actions induced by the DSM consistency
protocols. If you wish to use the <TT>valgrind</TT> debugger on a program using
<TT>marcel</TT>, you need to set the <TT>valgrind</TT> option of the <TT>marcel</TT>
module to let <TT>valgrind</TT> know about <TT>marcel</TT> stacks. If your version
of <TT>valgrind</TT> is previous to 3.0, you will also need to recompile it
after setting, in the file <TT>coregrind/vg_memory.c</TT>, the
<TT>VG_PLAUSIBLE_STACK_SIZE</TT> constant to the size of <TT>marcel</TT> stacks
(65536 by default).
</P>

<P>
Assuming that you are using the <TT>pm2</TT> flavor, create a new
flavor <TT>pm2-debug</TT> based on it as explained in Section <REF
LABEL="sec:createFlavors"/>. Set the <TT>PM2_FLAVOR</TT> shell
variable to this value, and recompile PM2 with the new flavor.

<PROGRAM FILE="./Progs/pm2debug.txt"/>
</P>

<P>
You then need to recompile the programs you wish to execute with this new flavor.
</P>

<WARNING>
  Make sure that they are <EM>actually</EM> recompiled: it can be recommended to first delete
  the objects files by hand!
</WARNING>

<P>
A second step is to insert additional trace outputs within your source
code. Your are strongly advised to print on the <TT>stderr</TT> error
descriptor instead of the regular <TT>stdout</TT> one. Also, you should always
use the <EM>thread-safe</EM> version of <TT>(f)printf</TT>, called <TT>t(f)printf</TT>.
This will prevent multiple Marcel threads to print concurrently,
leading to scrambled text. 
<IGNORE>
Use the <TT>pm2logs</TT> utility to view the
remote logs. It may be useful to force logging also on the main
node<SPACE/>0: use <TT>pm2load -l</TT>. Then, <TT>pm2logs</TT> will recover exactly one
log per (logical) node.
</IGNORE>
</P>

<IGNORE>
<P>
You may also require ``immediate'' output from remote node by using
the <TT>pm2_(f)printf</TT> routine. Each time it is called, the output is
packed into a buffer and sent to main node<SPACE/>0 to be immediately
displayed there. The output is prefixed by <TT>t&lt;i&gt;</TT>, where <TT>&lt;i&gt;</TT> is
the logical number of the originator node.  This is quite convenient, but
the user has to be aware that the additional messages generated in
this way <EM>do interfere</EM> with the original communication scheme of
the program under debugging. In particular, they may generate
additional deadlocks! Also, these additional messages have to be
considered when designing the termination scheme of the program. The
<TT>pm2_halt</TT> function should not be called by a node <EM>before</EM> it
is guaranteed that all communications, whatever their origin, have
been handled by the daemon service threads. Deadlock may otherwise
occur.
</P>
</IGNORE>

<P>
The <TT>pm2load</TT> utility provides a number of options.  The most useful
one in a first place is <TT>pm2load -d</TT>. It can be used with any flavor,
but it is most rewarding when the current flavor enables the <TT>gdb</TT>
for all the modules and for the application. If run with the <TT>-d</TT>
option, <TT>pm2load</TT> opens a <TT>gdb</TT> session on each (logical) node
declared in the configuration, with a display on your console. Just
typing <TT>r</TT> (for <TT>run</TT>) in the window will start the execution.
Observe that your have to type it in <EM>each</EM> window!  Before
debugging your program at this level, you'd better downsize your code
to some manageable configuration, say<SPACE/>3 or 4<SPACE/>nodes.

<IGNORE>
Observe also that
the windows of nodes other than the main one will only pop up after
the main node has started and called its <TT>pm2_main</TT> routine. Then,
the node is blocked until you have typed <TT>r</TT> in the window of each
subsidiary node.
</IGNORE>

Before starting the execution on the different nodes, you may add breakpoints
and require all kind of functionalities provided by <TT>gdb</TT>.  PM2 does
not close the windows at the end of the run, so that you can inspect
the final state of each node. Typing <TT>Ctrl-D</TT> in each window will close
it and terminate the program.
</P>

<WARNING>
<P>
When running on different machines sharing the same file space, you
might encounter problems to start the different graphical consoles
hosting <TT>gdb</TT>. A solution to this problem is to set the shell
variable <TT>LEO_RSH</TT>:

<PROGRAM FILE="./Progs/setLeoRsh.txt"/>
</P>

<P>
Note that this setting must be done in your configuration connection
files such as <TT>$HOME/.cshrc</TT>.
</P>
</WARNING>

<WARNING>
  A note to eye-impaired Solaris users. The <TT>gdb</TT> facility is run
  within a <TT>xterm</TT>. In certain recent versions of Solaris, the
  default for the <TT>xterm</TT> background is a dark gray, which makes
  debugging *very* painful. You can change it to white by adding the
  following line to your <TT>${HOME}/.Xdefaults</TT> file:

<PROGRAM FILE="./Progs/xdefaults.txt"/>

Once it is done, reload your <TT>.Xdefaults</TT> file by issuing:

<PROGRAM FILE="./Progs/xdefaults2.txt"/>
</WARNING>

<P>
The user should be aware that <TT>gdb</TT> itself is <EM>not</EM> aware
of Marcel threads: <TT>info threads</TT> will only show LWPs,
<TT>thread &lt;num&gt;</TT> will only let switch between LWPs, and
<TT>backtrace</TT> will only show the backtrace of the <EM>current</EM>
Marcel thread running in the chosen LWPs.
</P>

<P>
However, if Marcel was compiled with the gdb option, Marcel provides
several gdb functions for printing thread state like the --marcel-xtop
option:

<PROGRAM FILE="./Progs/marcelTop.txt"/>
</P>

<P>
One may switch to not-running threads' context thanks PM2-provided
functions<FOOTNOTE>yet implemented on X86 only</FOOTNOTE>:

<PROGRAM FILE="./Progs/gdb.txt"/>
</P>

<P>
One can then use usual functions like <TT>frame</TT>, <TT>print</TT>,
etc. to inspect the thread.
</P>

<P>
The user should be aware that although <TT>set-ctx</TT> achieves a
context switch so as to get correct <TT>PC</TT> and <TT>SP</TT>,
<TT>continue</TT>-like commands automatically switch back to the
current running thread<FOOTNOTE>In theory, the PM2 process should
then continue properly, but it seems gdb does not yet let this work
correctly</FOOTNOTE>.
</P>

<P>
The user should be aware that some of the names of PM2 routine are in
fact on-line definitions in internal header files. Thus, one has to
know the <EM>actual</EM> name of the routine to set a breakpoint. The
following table provides the some useful translations.
</P>

<P>
<TABLE>
<TR>
<TH>External name</TH> <TH>Real name</TH> <TH>Origin module</TH>
</TR>
<TR>
<TD> <TT>pm2_init</TT></TD> <TD><TT>common_init</TT></TD> <TD><TT>pm2</TT></TD>
</TR>
<TR>
<TD><TT>pm2_main</TT></TD> <TD><TT>marcel_main</TT></TD> <TD><TT>pm2</TT></TD>
</TR>
<TR>
<TD><TT>tprintf</TT></TD>    <TD><TT>marcel_printf</TT></TD>      <TD><TT>tbx</TT></TD>
</TR>
<TR>
<TD><TT>tfprintf</TT></TD>     <TD><TT>marcel_fprintf</TT></TD>     <TD><TT>tbx</TT></TD>
</TR>
</TABLE>
</P>

</SUBSECTION>

<SUBSECTION TITLE="Using the debug facilities of Leonie">

<P>
The PM2 bootstrap code, <TT>leonie</TT>, is used by <TT>pm2load</TT>
to launch the application on the requested nodes. <TT>leonie</TT>
accepts different parameters for debug purpose. It is possible to
trace or log any of the modules used by PM2. The general syntax of
<TT>leonie</TT> is:

<PROGRAM FILE="./Progs/leonieSyntax.txt"/>
</P>

<P>
A simple call of <TT>leonie</TT> would be:

<PROGRAM FILE="./Progs/leonie1.txt"/>
</P>

<P>
where the option <TT>--x</TT> indicates that session processes should
not be started within a new graphical console (i.e. <TT>xterm</TT>),
and the option <TT>--p</TT> indicates there should be no pause
following the termination of the session processes. Start
<TT>leonie</TT> without these options to fully understand their
behavior. The call <TT>leonie --help</TT> shows the list of
all the available options.
</P>

<P>
Debug parameters allow to trace specific modules. The general format
of a debug parameter is
<TT>--debug:&lt;MODULE_NAME&gt;-&lt;TRACE_LEVEL&gt;</TT>. For example,
the debug parameter <TT>--debug:ntbx-trace</TT> will display all the
trace messages within the module <TT>ntbx</TT> either made by
<TT>leonie</TT> or by the processes started by <TT>leonie</TT>
(depending on the parameter is specified as a <TT>leonie</TT>
parameter or as a application parameter). <B>Note that the module
must have been compiled with the option <TT>debug</TT></B>. More
debug parameters are available, you can print the list as follows:

<PROGRAM FILE="./Progs/debugregister.txt"/>
</P>

<P>
The <TT>leonie</TT> parameter <TT>-l</TT> indicates the output of the
debug should be redirected to a file in the default temporary
directory. On a typical Unix system, the name of the file will be
similar to <TT>/tmp/pm2log-$USER-x</TT>.
</P>

<P>
When executing a Madeleine application, the flavor <TT>leonie</TT> is
used by <TT>leonie</TT> itself, and the flavor <TT>mad3</TT> is used
for the application started by <TT>leonie</TT>. The following command
will print the list of modules for a specific flavor:

<PROGRAM FILE="./Progs/leonie5.txt"/>
</P>

<P>
The debug parameters can be specified directly for <TT>leonie</TT>:

<PROGRAM FILE="./Progs/leonie2.txt"/>
</P>

<P>

or for the processes started by <TT>leonie</TT>:

<PROGRAM FILE="./Progs/leonie3.txt"/>
</P>

<P>
or for both <TT>leonie</TT> and the processes started by <TT>leonie</TT>:

<PROGRAM FILE="./Progs/leonie4.txt"/>

</P>

<SUBSUBSECTION TITLE="Debugging PM2 processes">

<P>
When starting <TT>leonie</TT>, you can specify processes should be
started under the debugger by using the option <TT>-d</TT> as in the
following example:

<PROGRAM FILE="./Progs/leonieGdb.txt"/>

</P>

<P>
This command will start the processes under the GNU debugger, each
within a new graphical console. If you do not have the option of
starting graphical tools, you should try the following command:

<PROGRAM FILE="./Progs/leonieGdb2.txt"/>

</P>

<P>
If your system allows users to create core files, this command will
dump the execution of the faulty processes into a core file. You can
then use the GNU debugger to examine the execution in more detail.

<PROGRAM FILE="./Progs/leonieGdb3.txt"/>

</P>

</SUBSUBSECTION>

<SUBSUBSECTION TITLE="Debugging Leonie">

<P>
You might need to start <TT>leonie</TT> itself under the debugger. To
do so, you need to set the environment variable <TT>LEO_DEBUG</TT> to
the value <TT>1</TT> before starting <TT>leonie</TT>.

<PROGRAM FILE="./Progs/debugLeonie.txt"/>
</P>

<P>
The debugger then waits for some user input, you can for example set
breakpoints or start the application. The file
<TT>$HOME/.leo_gdb_init</TT> can be used to define a list of GDB
commands to execute when starting the debugger. You can for example
automatically start the execution of the application.

<PROGRAM FILE="./Progs/debugLeonie2.txt"/>
</P>

</SUBSUBSECTION>

</SUBSECTION>

</TEXT>
