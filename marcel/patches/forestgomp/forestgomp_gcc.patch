diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-common.h gcc-4.2.2/gcc/c-common.h
--- gcc-4.2.2.orig/gcc/c-common.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-common.h	2007-11-07 14:17:49.000000000 +0100
@@ -947,6 +947,7 @@ extern tree c_finish_omp_master (tree);
 extern tree c_finish_omp_critical (tree, tree);
 extern tree c_finish_omp_ordered (tree);
 extern void c_finish_omp_barrier (void);
+extern void c_finish_omp_taskwait (void);
 extern tree c_finish_omp_atomic (enum tree_code, tree, tree);
 extern void c_finish_omp_flush (void);
 extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-omp.c gcc-4.2.2/gcc/c-omp.c
--- gcc-4.2.2.orig/gcc/c-omp.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-omp.c	2007-11-07 14:20:53.000000000 +0100
@@ -79,6 +79,18 @@ c_finish_omp_barrier (void)
   add_stmt (x);
 }
 
+/* Complete a #pragma omp taskwait construct.  */
+
+void
+c_finish_omp_taskwait (void)
+{
+  tree x;
+
+  x = built_in_decls[BUILT_IN_GOMP_TASKWAIT];
+  x = build_function_call_expr (x, NULL);
+  add_stmt (x);
+}
+
 
 /* Complete a #pragma omp atomic construct.  The expression to be 
    implemented atomically is LHS code= RHS.  The value returned is
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-parser.c gcc-4.2.2/gcc/c-parser.c
--- gcc-4.2.2.orig/gcc/c-parser.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-parser.c	2007-11-07 15:41:35.000000000 +0100
@@ -215,7 +215,9 @@ typedef enum pragma_omp_clause {
   PRAGMA_OMP_CLAUSE_PRIVATE,
   PRAGMA_OMP_CLAUSE_REDUCTION,
   PRAGMA_OMP_CLAUSE_SCHEDULE,
-  PRAGMA_OMP_CLAUSE_SHARED
+  PRAGMA_OMP_CLAUSE_SHARED,
+  PRAGMA_OMP_CLAUSE_CAPTUREPRIVATE,
+  PRAGMA_OMP_CLAUSE_SWITCH
 } pragma_omp_clause;
 
 
@@ -1035,6 +1037,7 @@ static tree c_parser_expr_list (c_parser
 static void c_parser_omp_construct (c_parser *);
 static void c_parser_omp_threadprivate (c_parser *);
 static void c_parser_omp_barrier (c_parser *);
+static void c_parser_omp_taskwait (c_parser *);
 static void c_parser_omp_flush (c_parser *);
 
 enum pragma_context { pragma_external, pragma_stmt, pragma_compound };
@@ -6517,6 +6520,17 @@ c_parser_pragma (c_parser *parser, enum 
 
   switch (id)
     {
+    case PRAGMA_OMP_TASKWAIT:
+      if (context != pragma_compound)
+	{
+	  if (context == pragma_stmt)
+	    c_parser_error (parser, "%<#pragma omp taskwait%> may only be "
+			    "used in compound statements");
+	  goto bad_stmt;
+	}
+      c_parser_omp_taskwait (parser);
+      return false;
+    
     case PRAGMA_OMP_BARRIER:
       if (context != pragma_compound)
 	{
@@ -7322,6 +7336,19 @@ c_parser_omp_barrier (c_parser *parser)
   c_finish_omp_barrier ();
 }
 
+/* OpenMP 3.0 draft:
+   # pragma omp taskwait new-line
+*/
+
+static void
+c_parser_omp_taskwait (c_parser *parser)
+{
+  c_parser_consume_pragma (parser);
+  c_parser_skip_to_pragma_eol (parser);
+
+  c_finish_omp_taskwait ();
+}
+
 /* OpenMP 2.5:
    # pragma omp critical [(name)] new-line
      structured-block
@@ -7715,6 +7742,31 @@ c_parser_omp_parallel (c_parser *parser)
   return stmt;
 }
 
+/* OpenMP 3.0 draft:
+   # pragma task task-clause new-line
+*/
+
+#define OMP_TASK_CLAUSE_MASK			\
+	( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)		\
+	| (1u << PRAGMA_OMP_CLAUSE_CAPTUREPRIVATE)	\
+	| (1u << PRAGMA_OMP_CLAUSE_SHARED)		\
+	| (1u << PRAGMA_OMP_CLAUSE_SWITCH))
+
+static tree
+c_parser_omp_task (c_parser *parser)
+{
+  const char *p_name = "#pragma omp task";
+  tree stmt, clauses, block;
+  unsigned int mask = OMP_TASK_CLAUSE_MASK;
+
+  clauses = c_parser_omp_all_clauses (parser, mask, p_name);
+  block = c_begin_omp_task ();
+  c_parser_statement (parser);
+  stmt = c_finish_omp_task (clauses, block);
+
+  return stmt;
+}
+
 /* OpenMP 2.5:
    # pragma omp single single-clause[optseq] new-line
      structured-block
@@ -7786,6 +7838,14 @@ c_parser_omp_construct (c_parser *parser
     case PRAGMA_OMP_SINGLE:
       stmt = c_parser_omp_single (parser);
       break;
+    case PRAGMA_OMP_TASK:
+      stmt = c_parser_omp_task (parser);
+      break;
+#if 0
+    case PRAGMA_OMP_TASKGROUP:
+      stmt = c_parser_omp_taskgroup (parser);
+      break;
+#endif
     default:
       gcc_unreachable ();
     }
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-pragma.c gcc-4.2.2/gcc/c-pragma.c
--- gcc-4.2.2.orig/gcc/c-pragma.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-pragma.c	2007-10-31 11:30:28.000000000 +0100
@@ -797,7 +797,10 @@ init_pragma (void)
 	{ "section", PRAGMA_OMP_SECTION },
 	{ "sections", PRAGMA_OMP_SECTIONS },
 	{ "single", PRAGMA_OMP_SINGLE },
-	{ "threadprivate", PRAGMA_OMP_THREADPRIVATE }
+	{ "threadprivate", PRAGMA_OMP_THREADPRIVATE },
+	{ "task", PRAGMA_OMP_TASK },
+	{ "taskwait", PRAGMA_OMP_TASKWAIT },
+	{ "taskgroup", PRAGMA_OMP_TASKGROUP }
       };
 
       const int n_omp_pragmas = sizeof (omp_pragmas) / sizeof (*omp_pragmas);
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-pragma.h gcc-4.2.2/gcc/c-pragma.h
--- gcc-4.2.2.orig/gcc/c-pragma.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-pragma.h	2007-10-31 11:29:12.000000000 +0100
@@ -42,6 +42,9 @@ typedef enum pragma_kind {
   PRAGMA_OMP_SECTIONS,
   PRAGMA_OMP_SINGLE,
   PRAGMA_OMP_THREADPRIVATE,
+  PRAGMA_OMP_TASK,
+  PRAGMA_OMP_TASKWAIT,
+  PRAGMA_OMP_TASKGROUP,
 
   PRAGMA_GCC_PCH_PREPROCESS,
 
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-tree.h gcc-4.2.2/gcc/c-tree.h
--- gcc-4.2.2.orig/gcc/c-tree.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-tree.h	2007-10-31 14:57:20.000000000 +0100
@@ -587,6 +587,8 @@ extern void c_end_vm_scope (unsigned int
 extern tree c_expr_to_decl (tree, bool *, bool *, bool *);
 extern tree c_begin_omp_parallel (void);
 extern tree c_finish_omp_parallel (tree, tree);
+extern tree c_begin_omp_task (void);
+extern tree c_finish_omp_task (tree, tree);
 extern tree c_finish_omp_clauses (tree);
 
 /* Set to 0 at beginning of a function definition, set to 1 if
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/c-typeck.c gcc-4.2.2/gcc/c-typeck.c
--- gcc-4.2.2.orig/gcc/c-typeck.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-typeck.c	2007-10-31 17:45:57.000000000 +0100
@@ -8582,6 +8582,32 @@ c_finish_omp_parallel (tree clauses, tre
   return add_stmt (stmt);
 }
 
+tree
+c_begin_omp_task (void)
+{
+  tree block;
+
+  keep_next_level ();
+  block = c_begin_compound_stmt (true);
+
+  return block;
+}
+
+tree
+c_finish_omp_task (tree clauses, tree block)
+{
+  tree stmt;
+
+  block = c_end_compound_stmt (block, true);
+
+  stmt = make_node (OMP_TASK);
+  TREE_TYPE (stmt) = void_type_node;
+  OMP_TASK_CLAUSES (stmt) = clauses;
+  OMP_TASK_BODY (stmt) = block;
+
+  return add_stmt (stmt);
+}
+
 /* For all elements of CLAUSES, validate them vs OpenMP constraints.
    Remove any elements from the list that are invalid.  */
 
@@ -8776,6 +8802,9 @@ c_finish_omp_clauses (tree clauses)
 		case OMP_CLAUSE_DEFAULT_PRIVATE:
 		  share_name = "private";
 		  break;
+		case OMP_CLAUSE_DEFAULT_CAPTUREPRIVATE:
+		  share_name = "captureprivate";
+		  break;
 		default:
 		  gcc_unreachable ();
 		}
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/gimple-low.c gcc-4.2.2/gcc/gimple-low.c
--- gcc-4.2.2.orig/gcc/gimple-low.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/gimple-low.c	2007-10-31 17:47:04.000000000 +0100
@@ -274,6 +274,7 @@ lower_stmt (tree_stmt_iterator *tsi, str
       }
       break;
 
+    case OMP_TASK:
     case OMP_PARALLEL:
       lower_omp_directive (tsi, data);
       return;
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/gimplify.c gcc-4.2.2/gcc/gimplify.c
--- gcc-4.2.2.orig/gcc/gimplify.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/gimplify.c	2007-10-31 15:26:15.000000000 +0100
@@ -271,6 +271,7 @@ new_omp_context (bool is_parallel, bool 
   c->location = input_location;
   c->is_parallel = is_parallel;
   c->is_combined_parallel = is_combined_parallel;
+  /* TODO: use DEFAULT_CAPTUREPRIVATE for tasks */
   c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;
 
   return c;
@@ -4685,6 +4686,8 @@ gimplify_scan_omp_clauses (tree *list_p,
 
       switch (OMP_CLAUSE_CODE (c))
 	{
+	case OMP_CLAUSE_CAPTUREPRIVATE:
+		/* TODO: implement */
 	case OMP_CLAUSE_PRIVATE:
 	  flags = GOVD_PRIVATE | GOVD_EXPLICIT;
 	  notice_outer = false;
@@ -4948,6 +4951,28 @@ gimplify_omp_parallel (tree *expr_p, tre
   return GS_ALL_DONE;
 }
 
+static enum gimplify_status
+gimplify_omp_task (tree *expr_p, tree *pre_p)
+{
+  tree expr = *expr_p;
+
+  gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p, true,
+			     0);
+
+  push_gimplify_context ();
+
+  gimplify_stmt (&OMP_TASK_BODY (expr));
+
+  if (TREE_CODE (OMP_TASK_BODY (expr)) == BIND_EXPR)
+    pop_gimplify_context (OMP_TASK_BODY (expr));
+  else
+    pop_gimplify_context (NULL_TREE);
+
+  gimplify_adjust_omp_clauses (&OMP_TASK_CLAUSES (expr));
+
+  return GS_ALL_DONE;
+}
+
 /* Gimplify the gross structure of an OMP_FOR statement.  */
 
 static enum gimplify_status
@@ -5804,6 +5829,10 @@ gimplify_expr (tree *expr_p, tree *pre_p
 	  ret = gimplify_omp_parallel (expr_p, pre_p);
 	  break;
 
+	case OMP_TASK:
+	  ret = gimplify_omp_task (expr_p, pre_p);
+	  break;
+
 	case OMP_FOR:
 	  ret = gimplify_omp_for (expr_p, pre_p);
 	  break;
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/omp-builtins.def gcc-4.2.2/gcc/omp-builtins.def
--- gcc-4.2.2.orig/gcc/omp-builtins.def	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/omp-builtins.def	2007-11-07 15:43:43.000000000 +0100
@@ -131,6 +131,12 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL
 		  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_END, "GOMP_parallel_end",
 		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK_START, "GOMP_task_start",
+		  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)
+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK_END, "GOMP_task_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT, "GOMP_taskwait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, "GOMP_sections_start",
 		  BT_FN_UINT_UINT, ATTR_NOTHROW_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_NEXT, "GOMP_sections_next",
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/omp-low.c gcc-4.2.2/gcc/omp-low.c
--- gcc-4.2.2.orig/gcc/omp-low.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/omp-low.c	2007-11-07 15:22:28.000000000 +0100
@@ -126,6 +126,14 @@ find_omp_clause (tree clauses, enum tree
   return NULL_TREE;
 }
 
+/* Return true if CTX is for an omp task.  */
+
+static inline bool
+is_task_ctx (omp_context *ctx)
+{
+  return TREE_CODE (ctx->stmt) == OMP_TASK;
+}
+
 /* Return true if CTX is for an omp parallel.  */
 
 static inline bool
@@ -935,14 +943,18 @@ scan_sharing_clauses (tree clauses, omp_
 
       switch (OMP_CLAUSE_CODE (c))
 	{
+	case OMP_CLAUSE_CAPTUREPRIVATE:
+	  /* TODO: implement correct behaviour instead of just copying
+	     the PRIVATE clause.  */
 	case OMP_CLAUSE_PRIVATE:
 	  decl = OMP_CLAUSE_DECL (c);
 	  if (!is_variable_sized (decl))
 	    install_var_local (decl, ctx);
 	  break;
 
+
 	case OMP_CLAUSE_SHARED:
-	  gcc_assert (is_parallel_ctx (ctx));
+	  gcc_assert (is_parallel_ctx (ctx) || is_task_ctx (ctx));
 	  decl = OMP_CLAUSE_DECL (c);
 	  gcc_assert (!is_variable_sized (decl));
 	  by_ref = use_pointer_for_field (decl, true);
@@ -960,7 +972,8 @@ scan_sharing_clauses (tree clauses, omp_
 	      break;
 	    }
 	  /* We don't need to copy const scalar vars back.  */
-	  OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_FIRSTPRIVATE);
+	  if (is_parallel_ctx (ctx))
+	    OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_FIRSTPRIVATE);
 	  goto do_private;
 
 	case OMP_CLAUSE_LASTPRIVATE:
@@ -1028,6 +1041,9 @@ scan_sharing_clauses (tree clauses, omp_
 	    break;
 	  /* FALLTHRU */
 
+	case OMP_CLAUSE_CAPTUREPRIVATE:
+	  /* TODO: implement correct behaviour instead of just copying
+	     the PRIVATE clause.  */
 	case OMP_CLAUSE_PRIVATE:
 	case OMP_CLAUSE_FIRSTPRIVATE:
 	case OMP_CLAUSE_REDUCTION:
@@ -1145,6 +1161,46 @@ create_omp_child_function (omp_context *
 }
 
 
+/* Scan an OpenMP task directive.  */
+
+static void
+scan_omp_task (tree *stmt_p, omp_context *outer_ctx)
+{
+  omp_context *ctx;
+  tree name;
+
+  /* Ignore task directives with empty bodies, unless there
+     are copyin clauses.  */
+  if (optimize > 0
+      && empty_body_p (OMP_PARALLEL_BODY (*stmt_p)))
+    {
+      *stmt_p = build_empty_stmt ();
+      return;
+    }
+
+  ctx = new_omp_context (*stmt_p, outer_ctx);
+  ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);
+  ctx->default_kind = OMP_CLAUSE_DEFAULT_CAPTUREPRIVATE;
+  ctx->record_type = lang_hooks.types.make_type (RECORD_TYPE);
+  name = create_tmp_var_name (".omp_data_s");
+  name = build_decl (TYPE_DECL, name, ctx->record_type);
+  TYPE_NAME (ctx->record_type) = name;
+  create_omp_child_function (ctx);
+  OMP_TASK_FN (*stmt_p) = ctx->cb.dst_fn;
+
+  scan_sharing_clauses (OMP_TASK_CLAUSES (*stmt_p), ctx);
+  scan_omp (&OMP_TASK_BODY (*stmt_p), ctx);
+
+  if (TYPE_FIELDS (ctx->record_type) == NULL)
+    ctx->record_type = ctx->receiver_decl = NULL;
+  else
+    {
+      layout_type (ctx->record_type);
+      fixup_child_record_type (ctx);
+    }
+}
+
+
 /* Scan an OpenMP parallel directive.  */
 
 static void
@@ -1345,6 +1401,10 @@ scan_omp_1 (tree *tp, int *walk_subtrees
   *walk_subtrees = 0;
   switch (TREE_CODE (t))
     {
+    case OMP_TASK:
+      scan_omp_task (tp, ctx);
+      break;
+
     case OMP_PARALLEL:
       parallel_nesting_level++;
       scan_omp_parallel (tp, ctx);
@@ -1760,6 +1820,8 @@ lower_rec_input_clauses (tree clauses, t
 		break;
 	      /* FALLTHRU */
 
+	    case OMP_CLAUSE_CAPTUREPRIVATE:
+	      /* TODO: implement.  */
 	    case OMP_CLAUSE_PRIVATE:
 	      x = lang_hooks.decls.omp_clause_default_ctor (c, new_var);
 	      if (x)
@@ -2101,7 +2163,8 @@ lower_send_clauses (tree clauses, tree *
 
 /* Generate code to implement SHARED from the sender (aka parent) side.
    This is trickier, since OMP_PARALLEL_CLAUSES doesn't list things that
-   got automatically shared.  */
+   got automatically shared.
+   Also used for CAPTUREPRIVATE task variables.  */
 
 static void
 lower_send_shared_vars (tree *ilist, tree *olist, omp_context *ctx)
@@ -2146,6 +2209,62 @@ lower_send_shared_vars (tree *ilist, tre
     }
 }
 
+/* Build the function calls to GOMP_task_start etc to actually 
+   generate the task operation.  REGION is the task region
+   being expanded.  BB is the block where to insert the code.  WS_ARGS
+   will be set if this is a call to a combined task+workshare
+   construct, it contains the list of additional arguments needed by
+   the workshare construct.  */
+
+static void
+expand_task_call (struct omp_region *region, basic_block bb,
+		      tree entry_stmt)
+{
+  tree t, args, list, clauses;
+  block_stmt_iterator si;
+  int start_ix;
+
+  clauses = OMP_TASK_CLAUSES (entry_stmt);
+  push_gimplify_context ();
+
+  /* Determine what flavor of GOMP_task_start we will be
+     emitting.  */
+  start_ix = BUILT_IN_GOMP_TASK_START;
+
+  list = NULL_TREE;
+  t = OMP_TASK_DATA_ARG (entry_stmt);
+  if (t == NULL)
+    t = null_pointer_node;
+  else
+    t = build_fold_addr_expr (t);
+  args = tree_cons (NULL, t, NULL);
+  t = build_fold_addr_expr (OMP_TASK_FN (entry_stmt));
+  args = tree_cons (NULL, t, args);
+
+  t = built_in_decls[start_ix];
+  t = build_function_call_expr (t, args);
+  gimplify_and_add (t, &list);
+
+  t = OMP_TASK_DATA_ARG (entry_stmt);
+  if (t == NULL)
+    t = null_pointer_node;
+  else
+    t = build_fold_addr_expr (t);
+  args = tree_cons (NULL, t, NULL);
+  t = build_function_call_expr (OMP_TASK_FN (entry_stmt), args);
+  gimplify_and_add (t, &list);
+
+  t = built_in_decls[BUILT_IN_GOMP_TASK_END];
+  t = build_function_call_expr (t, NULL);
+  gimplify_and_add (t, &list);
+
+  si = bsi_last (bb);
+  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);
+
+  pop_gimplify_context (NULL_TREE);
+}
+
+
 /* Build the function calls to GOMP_parallel_start etc to actually 
    generate the parallel operation.  REGION is the parallel region
    being expanded.  BB is the block where to insert the code.  WS_ARGS
@@ -2412,6 +2531,150 @@ remove_exit_barriers (struct omp_region 
     }
 }
 
+/* Expand the OpenMP task directive starting at REGION.  */
+
+static void
+expand_omp_task (struct omp_region *region)
+{
+  basic_block entry_bb, exit_bb, new_bb;
+  struct function *child_cfun, *saved_cfun;
+  tree child_fn, block, t;
+  block_stmt_iterator si;
+  tree entry_stmt;
+  edge e;
+  bool do_cleanup_cfg = false;
+
+  entry_stmt = last_stmt (region->entry);
+  child_fn = OMP_TASK_FN (entry_stmt);
+  child_cfun = DECL_STRUCT_FUNCTION (child_fn);
+  saved_cfun = cfun;
+
+  entry_bb = region->entry;
+  exit_bb = region->exit;
+
+  if (child_cfun->cfg)
+    {
+      /* Due to inlining, it may happen that we have already outlined
+	 the region, in which case all we need to do is make the
+	 sub-graph unreachable and emit the task call.  */
+      edge entry_succ_e, exit_succ_e;
+      block_stmt_iterator si;
+
+      entry_succ_e = single_succ_edge (entry_bb);
+
+      si = bsi_last (entry_bb);
+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_TASK);
+      bsi_remove (&si, true);
+
+      new_bb = entry_bb;
+      remove_edge (entry_succ_e);
+      if (exit_bb)
+	{
+	  exit_succ_e = single_succ_edge (exit_bb);
+	  make_edge (new_bb, exit_succ_e->dest, EDGE_FALLTHRU);
+	}
+      do_cleanup_cfg = true;
+    }
+  else
+    {
+      /* If the task region needs data sent from the parent
+	 function, then the very first statement (except possible
+	 tree profile counter updates) of the task body
+	 is a copy assignment .OMP_DATA_I = &.OMP_DATA_O.  Since
+	 &.OMP_DATA_O is passed as an argument to the child function,
+	 we need to replace it with the argument as seen by the child
+	 function.
+
+	 In most cases, this will end up being the identity assignment
+	 .OMP_DATA_I = .OMP_DATA_I.  However, if the task body had
+	 a function call that has been inlined, the original PARM_DECL
+	 .OMP_DATA_I may have been converted into a different local
+	 variable.  In which case, we need to keep the assignment.  */
+      if (OMP_TASK_DATA_ARG (entry_stmt))
+	{
+	  basic_block entry_succ_bb = single_succ (entry_bb);
+	  block_stmt_iterator si;
+
+	  for (si = bsi_start (entry_succ_bb); ; bsi_next (&si))
+	    {
+	      tree stmt, arg;
+
+	      gcc_assert (!bsi_end_p (si));
+	      stmt = bsi_stmt (si);
+	      if (TREE_CODE (stmt) != MODIFY_EXPR)
+		continue;
+
+	      arg = TREE_OPERAND (stmt, 1);
+	      STRIP_NOPS (arg);
+	      if (TREE_CODE (arg) == ADDR_EXPR
+		  && TREE_OPERAND (arg, 0)
+		     == OMP_TASK_DATA_ARG (entry_stmt))
+		{
+		  if (TREE_OPERAND (stmt, 0) == DECL_ARGUMENTS (child_fn))
+		    bsi_remove (&si, true);
+		  else
+		    TREE_OPERAND (stmt, 1) = DECL_ARGUMENTS (child_fn);
+		  break;
+		}
+	    }
+	}
+
+      /* Declare local variables needed in CHILD_CFUN.  */
+      block = DECL_INITIAL (child_fn);
+      BLOCK_VARS (block) = list2chain (child_cfun->unexpanded_var_list);
+      DECL_SAVED_TREE (child_fn) = single_succ (entry_bb)->stmt_list;
+
+      /* Reset DECL_CONTEXT on locals and function arguments.  */
+      for (t = BLOCK_VARS (block); t; t = TREE_CHAIN (t))
+	DECL_CONTEXT (t) = child_fn;
+
+      for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))
+	DECL_CONTEXT (t) = child_fn;
+
+      /* Split ENTRY_BB at OMP_TASK so that it can be moved to the
+	 child function.  */
+      si = bsi_last (entry_bb);
+      t = bsi_stmt (si);
+      gcc_assert (t && TREE_CODE (t) == OMP_TASK);
+      bsi_remove (&si, true);
+      e = split_block (entry_bb, t);
+      entry_bb = e->dest;
+      single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;
+
+      /* Move the task region into CHILD_CFUN.  We need to reset
+	 dominance information because the expansion of the inner
+	 regions has invalidated it.  */
+      free_dominance_info (CDI_DOMINATORS);
+      new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb);
+      if (exit_bb)
+	single_succ_edge (new_bb)->flags = EDGE_FALLTHRU;
+      cgraph_add_new_function (child_fn);
+
+      /* Convert OMP_RETURN into a RETURN_EXPR.  */
+      if (exit_bb)
+	{
+	  si = bsi_last (exit_bb);
+	  gcc_assert (!bsi_end_p (si)
+		      && TREE_CODE (bsi_stmt (si)) == OMP_RETURN);
+	  t = build1 (RETURN_EXPR, void_type_node, NULL);
+	  bsi_insert_after (&si, t, BSI_SAME_STMT);
+	  bsi_remove (&si, true);
+	}
+    }
+
+  /* Emit a library call to launch the children threads.  */
+  expand_task_call (region, new_bb, entry_stmt);
+
+  if (do_cleanup_cfg)
+    {
+      /* Clean up the unreachable sub-graph we created above.  */
+      free_dominance_info (CDI_DOMINATORS);
+      free_dominance_info (CDI_POST_DOMINATORS);
+      cleanup_tree_cfg ();
+    }
+}
+
+
 /* Expand the OpenMP parallel directive starting at REGION.  */
 
 static void
@@ -3426,6 +3689,10 @@ expand_omp (struct omp_region *region)
 
       switch (region->type)
 	{
+	case OMP_TASK:
+	  expand_omp_task (region);
+	  break;
+
 	case OMP_PARALLEL:
 	  expand_omp_parallel (region);
 	  break;
@@ -4144,6 +4411,80 @@ check_combined_parallel (tree *tp, int *
   return NULL;
 }
 
+/* Lower the OpenMP task directive in *STMT_P.  CTX holds context
+   information for the directive.  */
+
+static void
+lower_omp_task (tree *stmt_p, omp_context *ctx)
+{
+  tree clauses, par_bind, par_body, new_body, bind;
+  tree olist, ilist, par_olist, par_ilist;
+  tree stmt, child_fn, t;
+
+  stmt = *stmt_p;
+
+  clauses = OMP_TASK_CLAUSES (stmt);
+  par_bind = OMP_TASK_BODY (stmt);
+  par_body = BIND_EXPR_BODY (par_bind);
+  child_fn = ctx->cb.dst_fn;
+
+  push_gimplify_context ();
+
+  par_olist = NULL_TREE;
+  par_ilist = NULL_TREE;
+  lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx);
+  lower_omp (&par_body, ctx);
+  lower_reduction_clauses (clauses, &par_olist, ctx);
+
+  /* Declare all the variables created by mapping and the variables
+     declared in the scope of the task body.  */
+  record_vars_into (ctx->block_vars, child_fn);
+  record_vars_into (BIND_EXPR_VARS (par_bind), child_fn);
+
+  if (ctx->record_type)
+    {
+      ctx->sender_decl = create_tmp_var (ctx->record_type, ".omp_data_o");
+      OMP_TASK_DATA_ARG (stmt) = ctx->sender_decl;
+    }
+
+  olist = NULL_TREE;
+  ilist = NULL_TREE;
+  lower_send_clauses (clauses, &ilist, &olist, ctx);
+  lower_send_shared_vars (&ilist, &olist, ctx);
+
+  /* Once all the expansions are done, sequence all the different
+     fragments inside OMP_TASK_BODY.  */
+  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);
+  append_to_statement_list (ilist, &BIND_EXPR_BODY (bind));
+
+  new_body = alloc_stmt_list ();
+
+  if (ctx->record_type)
+    {
+      t = build_fold_addr_expr (ctx->sender_decl);
+      /* fixup_child_record_type might have changed receiver_decl's type.  */
+      t = fold_convert (TREE_TYPE (ctx->receiver_decl), t);
+      t = build2 (MODIFY_EXPR, void_type_node, ctx->receiver_decl, t);
+      append_to_statement_list (t, &new_body);
+    }
+
+  append_to_statement_list (par_ilist, &new_body);
+  append_to_statement_list (par_body, &new_body);
+  append_to_statement_list (par_olist, &new_body);
+  maybe_catch_exception (&new_body);
+  t = make_node (OMP_RETURN);
+  append_to_statement_list (t, &new_body);
+  OMP_TASK_BODY (stmt) = new_body;
+
+  append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));
+  append_to_statement_list (olist, &BIND_EXPR_BODY (bind));
+
+  *stmt_p = bind;
+
+  pop_gimplify_context (NULL_TREE);
+}
+
+
 /* Lower the OpenMP parallel directive in *STMT_P.  CTX holds context
    information for the directive.  */
 
@@ -4314,6 +4655,11 @@ lower_omp_1 (tree *tp, int *walk_subtree
       lower_omp_parallel (tp, ctx);
       break;
 
+    case OMP_TASK:
+      ctx = maybe_lookup_ctx (t);
+      lower_omp_task (tp, ctx);
+      break;
+
     case OMP_FOR:
       ctx = maybe_lookup_ctx (t);
       gcc_assert (ctx);
@@ -4516,6 +4862,7 @@ diagnose_sb_1 (tree *tp, int *walk_subtr
   switch (TREE_CODE (t))
     {
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_SECTIONS:
     case OMP_SINGLE:
       walk_tree (&OMP_CLAUSES (t), diagnose_sb_1, wi, NULL);
@@ -4570,6 +4917,7 @@ diagnose_sb_2 (tree *tp, int *walk_subtr
   switch (TREE_CODE (t))
     {
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_SECTIONS:
     case OMP_SINGLE:
       walk_tree (&OMP_CLAUSES (t), diagnose_sb_2, wi, NULL);
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree-cfg.c gcc-4.2.2/gcc/tree-cfg.c
--- gcc-4.2.2.orig/gcc/tree-cfg.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-cfg.c	2007-10-31 12:15:39.000000000 +0100
@@ -524,6 +524,7 @@ make_edges (void)
 	      break;
 
 	    case OMP_PARALLEL:
+	    case OMP_TASK:
 	    case OMP_FOR:
 	    case OMP_SINGLE:
 	    case OMP_MASTER:
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree.def gcc-4.2.2/gcc/tree.def
--- gcc-4.2.2.orig/gcc/tree.def	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree.def	2007-10-31 12:02:18.000000000 +0100
@@ -965,6 +965,7 @@ DEFTREECODE (TARGET_MEM_REF, "target_mem
 	      function.  */
 
 DEFTREECODE (OMP_PARALLEL, "omp_parallel", tcc_statement, 4)
+DEFTREECODE (OMP_TASK, "omp_task", tcc_statement, 4)
 
 /* OpenMP - #pragma omp for [clause1 ... clauseN]
    Operand 0: OMP_FOR_BODY: Loop body.
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree-gimple.c gcc-4.2.2/gcc/tree-gimple.c
--- gcc-4.2.2.orig/gcc/tree-gimple.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-gimple.c	2007-10-31 12:09:28.000000000 +0100
@@ -219,6 +219,7 @@ is_gimple_stmt (tree t)
     case PHI_NODE:
     case STATEMENT_LIST:
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_FOR:
     case OMP_SECTIONS:
     case OMP_SECTION:
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree.h gcc-4.2.2/gcc/tree.h
--- gcc-4.2.2.orig/gcc/tree.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree.h	2007-10-31 16:20:37.000000000 +0100
@@ -170,6 +170,7 @@ extern const enum tree_code_class tree_c
 
 #define OMP_DIRECTIVE_P(NODE)				\
     (TREE_CODE (NODE) == OMP_PARALLEL			\
+     || TREE_CODE (NODE) == OMP_TASK			\
      || TREE_CODE (NODE) == OMP_FOR			\
      || TREE_CODE (NODE) == OMP_SECTIONS		\
      || TREE_CODE (NODE) == OMP_SINGLE			\
@@ -277,9 +278,15 @@ enum omp_clause_code
      (c_parser_omp_variable_list).  */
   OMP_CLAUSE_ERROR = 0,
 
+  /* OpenMP clause: switch.  */
+  OMP_CLAUSE_SWITCH,
+
   /* OpenMP clause: private (variable_list).  */
   OMP_CLAUSE_PRIVATE,
 
+  /* OpenMP clause: captureprivate (variable_list).  */
+  OMP_CLAUSE_CAPTUREPRIVATE,
+
   /* OpenMP clause: shared (variable_list).  */
   OMP_CLAUSE_SHARED,
 
@@ -1558,6 +1565,11 @@ struct tree_constructor GTY(())
 #define OMP_PARALLEL_FN(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 2)
 #define OMP_PARALLEL_DATA_ARG(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 3)
 
+#define OMP_TASK_BODY(NODE)    TREE_OPERAND (OMP_TASK_CHECK (NODE), 0)
+#define OMP_TASK_CLAUSES(NODE) TREE_OPERAND (OMP_TASK_CHECK (NODE), 1)
+#define OMP_TASK_FN(NODE) TREE_OPERAND (OMP_TASK_CHECK (NODE), 2)
+#define OMP_TASK_DATA_ARG(NODE) TREE_OPERAND (OMP_TASK_CHECK (NODE), 3)
+
 #define OMP_FOR_BODY(NODE)	   TREE_OPERAND (OMP_FOR_CHECK (NODE), 0)
 #define OMP_FOR_CLAUSES(NODE)	   TREE_OPERAND (OMP_FOR_CHECK (NODE), 1)
 #define OMP_FOR_INIT(NODE)	   TREE_OPERAND (OMP_FOR_CHECK (NODE), 2)
@@ -1646,7 +1658,8 @@ enum omp_clause_default_kind
   OMP_CLAUSE_DEFAULT_UNSPECIFIED,
   OMP_CLAUSE_DEFAULT_SHARED,
   OMP_CLAUSE_DEFAULT_NONE,
-  OMP_CLAUSE_DEFAULT_PRIVATE
+  OMP_CLAUSE_DEFAULT_PRIVATE,
+  OMP_CLAUSE_DEFAULT_CAPTUREPRIVATE
 };
 
 #define OMP_CLAUSE_DEFAULT_KIND(NODE) \
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree-inline.c gcc-4.2.2/gcc/tree-inline.c
--- gcc-4.2.2.orig/gcc/tree-inline.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-inline.c	2007-10-31 12:15:23.000000000 +0100
@@ -1822,6 +1822,7 @@ estimate_num_insns_1 (tree *tp, int *wal
       }
 
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_FOR:
     case OMP_SECTIONS:
     case OMP_SINGLE:
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree-nested.c gcc-4.2.2/gcc/tree-nested.c
--- gcc-4.2.2.orig/gcc/tree-nested.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-nested.c	2007-10-31 18:24:55.000000000 +0100
@@ -1078,6 +1078,31 @@ convert_nonlocal_reference (tree *tp, in
       walk_tree (tp, convert_nonlocal_reference, wi, NULL);
       break;
 
+    case OMP_TASK:
+      /* TODO: check if CLAUSE_PRIVATE is the right conversion target
+       * clause here	*/
+      save_suppress = info->suppress_expansion;
+      if (convert_nonlocal_omp_clauses (&OMP_TASK_CLAUSES (t), wi))
+	{
+	  tree c, decl;
+	  decl = get_chain_decl (info);
+	  c = build_omp_clause (OMP_CLAUSE_PRIVATE);
+	  OMP_CLAUSE_DECL (c) = decl;
+	  OMP_CLAUSE_CHAIN (c) = OMP_TASK_CLAUSES (t);
+	  OMP_TASK_CLAUSES (t) = c;
+	}
+
+      save_local_var_chain = info->new_local_var_chain;
+      info->new_local_var_chain = NULL;
+
+      walk_body (convert_nonlocal_reference, info, &OMP_TASK_BODY (t));
+
+      if (info->new_local_var_chain)
+	declare_vars (info->new_local_var_chain, OMP_TASK_BODY (t), false);
+      info->new_local_var_chain = save_local_var_chain;
+      info->suppress_expansion = save_suppress;
+      break;
+
     case OMP_PARALLEL:
       save_suppress = info->suppress_expansion;
       if (convert_nonlocal_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))
@@ -1364,6 +1389,31 @@ convert_local_reference (tree *tp, int *
       wi->val_only = save_val_only;
       break;
 
+    case OMP_TASK:
+      /* TODO: check if CLAUSE_SHARED is the right conversion target
+       * clause here	*/
+      save_suppress = info->suppress_expansion;
+      if (convert_local_omp_clauses (&OMP_TASK_CLAUSES (t), wi))
+	{
+	  tree c;
+	  (void) get_frame_type (info);
+	  c = build_omp_clause (OMP_CLAUSE_SHARED);
+	  OMP_CLAUSE_DECL (c) = info->frame_decl;
+	  OMP_CLAUSE_CHAIN (c) = OMP_TASK_CLAUSES (t);
+	  OMP_TASK_CLAUSES (t) = c;
+	}
+
+      save_local_var_chain = info->new_local_var_chain;
+      info->new_local_var_chain = NULL;
+
+      walk_body (convert_local_reference, info, &OMP_TASK_BODY (t));
+
+      if (info->new_local_var_chain)
+	declare_vars (info->new_local_var_chain, OMP_TASK_BODY (t), false);
+      info->new_local_var_chain = save_local_var_chain;
+      info->suppress_expansion = save_suppress;
+      break;
+
     case OMP_PARALLEL:
       save_suppress = info->suppress_expansion;
       if (convert_local_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))
@@ -1698,6 +1748,35 @@ convert_call_expr (tree *tp, int *walk_s
       *walk_subtrees = 1;
       break;
 
+    case OMP_TASK:
+      /* TODO: check if CLAUSE_PRIVATE is the right conversion target
+       * clause here	*/
+      save_static_chain_added = info->static_chain_added;
+      info->static_chain_added = 0;
+      walk_body (convert_call_expr, info, &OMP_TASK_BODY (t));
+      for (i = 0; i < 2; i++)
+	{
+	  tree c, decl;
+	  if ((info->static_chain_added & (1 << i)) == 0)
+	    continue;
+	  decl = i ? get_chain_decl (info) : info->frame_decl;
+	  /* Don't add CHAIN.* or FRAME.* twice.  */
+	  for (c = OMP_TASK_CLAUSES (t); c; c = OMP_CLAUSE_CHAIN (c))
+	    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
+		 || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED)
+		&& OMP_CLAUSE_DECL (c) == decl)
+	      break;
+	  if (c == NULL)
+	    {
+	      c = build_omp_clause (OMP_CLAUSE_PRIVATE);
+	      OMP_CLAUSE_DECL (c) = decl;
+	      OMP_CLAUSE_CHAIN (c) = OMP_TASK_CLAUSES (t);
+	      OMP_TASK_CLAUSES (t) = c;
+	    }
+	}
+      info->static_chain_added |= save_static_chain_added;
+      break;
+
     case OMP_PARALLEL:
       save_static_chain_added = info->static_chain_added;
       info->static_chain_added = 0;
diff -uprN -X diff_exclude -x libgomp gcc-4.2.2.orig/gcc/tree-ssa-operands.c gcc-4.2.2/gcc/tree-ssa-operands.c
--- gcc-4.2.2.orig/gcc/tree-ssa-operands.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-ssa-operands.c	2007-10-31 12:16:15.000000000 +0100
@@ -2063,6 +2063,7 @@ get_expr_operands (tree stmt, tree *expr
     case LABEL_DECL:
     case CONST_DECL:
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_SECTIONS:
     case OMP_FOR:
     case OMP_SINGLE:
