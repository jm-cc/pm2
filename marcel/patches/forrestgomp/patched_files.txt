gcc/c-common.h
  - func c_finish_omp_taskwait declaration

gcc/c-omp.c
  - func c_finish_omp_taskwait:
    --> code generation for calling builtin GOMP_taskwait

gcc/c-parser.c
  - taskwait
    . func c_parser_pragma
      > detection of "omp taskwait" pragma 
    . func c_parser_omp_taskwait:
      > parsing of "omp taskwait" pragma
      > call to func c_finish_omp_taskwait

  - task
    . func c_parser_omp_task
      > parsing of:
        . "omp task" pragma
	. clauses
	. associated block of code
      > call to func c_begin_omp_task (for parsing the block of code)
      > call to func c_finish_omp_task with clauses and block as args

    . func c_parser_omp_construct
      > detection of "omp task" pragma 

gcc/c-pragma.c
  - pragma token -> pragma code association

gcc/c-pragma.h
  - pragma code declaration (enum)

gcc/c-tree.h
  - func c_begin_omp_task declaration
  - func c_finish_omp_task declaration

gcc/c-typeck.c
  - func c_begin_omp_task code
    > begin compound statement parsing

  - func c_finish_omp_task code
    > end compound statement parsing
    > building of "omp task" tree node

  - func c_finish_omp_clauses
    > new clause captureprivate?
      (in the paper but not in the 3.0 draft
       obsolete? to remove?)

gcc/gimple-low.c
  - (high level?) lowering omp task similarly to omp parallel
    into GIMPLE language

gcc/gimplify.c
  - func new_omp_context 
    > initialization of omp block status

  - func gimplify_scan_omp_clauses
    > lowering of omp clauses
      . where to implement IF clauses and the like

  - func gimplify_omp_task
    > actual lowering of tasks to GIMPLE

  - func gimplify_expr
    > branching to various constructs lowering routines

gcc/omp-builtins.def
  - definition of libgomp builtins
    > func GOMP_task_start
    > func GOMP_task_end
    > func GOMP_taskwait

gcc/omp-low.c
  * main Gomp code generation routines
  - func is_task_ctx
    > minor boolean function assertion checking

  - func scan_sharing_clauses
    > shared/private variable management

  - func scan_omp_task
    > task creation? (relationship with expand function series?)
    > call to func create_omp_child_function

  - func scan_omp_1
    > branching to omp construct scanning routines

  - func lower_*_clauses
  - func lower_send_shared_vars
    > variable management according to clauses
  
  - func expand_task_call
    > actual building of functions calls
      . GOMP_task_start builtin call (with user block as a function passed
      as an argument)
      . _also_ a call to the user function (TODO: suppress)
        >> hence call to the user function is built twice
	   (see omp parallel)
      . GOMP_task_end builtin call (TODO: merge with GOMP_task_start)

  - func expand_omp_task
    > building of the task region inside a function
      . directly copied from "omp parallel" code
      . probably should not need to be modified

  - func expand_omp
    > switch to expansion routines of omp constructs

  - func lower_omp_task
    > relationship with gimplify_omp_task from gimplify.c?
      (low-level side of gimplify_omp_task?)

  - func lower_omp_1
    > switch to lowering routines

  - func diagnose_sb_1
  - func diagnose_sb_2
    ?

gcc/tree-cfg.c
  - func make_edges
    ?

gcc/tree.def
  - definition of tree node codes
    . OMP_TASK

gcc/tree-gimple.c
  - func is_gimple_stmt
    ?

gcc/tree.h
  - see OMP_DIRECTIVE_P and some OMP_TASK* macro definitions

gcc/tree-inline.c
  - estimate_num_insns_1
    ?

gcc/tree-nested.c
  - nested function handling: 
    > meaning in OpenMP context ?
    > relationship with everything else ?

gcc/tree-ssa-operands.c
  - get_expr_operands
    ?

