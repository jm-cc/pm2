#!@PERL@

# PM2: Parallel Multithreaded Machine
# Copyright (C) 2007 "the PM2 team" (see AUTHORS file)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#


use warnings;
use strict;

package TraceFile;

## a class representing a trace file being parsed

use Fcntl 'SEEK_CUR','SEEK_SET','SEEK_END';	# seek constants

my %arch_code;	# architecture code to string mapping
my %arch_word;	# architecture code to word size mapping
my %block_code; # block code to string mapping

# parse a block header
sub read_block_header($) {
    my $self	= shift;
    my $bh	= {};
    my $buf;

    my $fh	= ${$self}{'file_handle'};

    # save current pos in the file
    ${$bh}{'start'}	= sysseek($fh, 0, SEEK_CUR)
        or die "sysseek: $!";

    # raw read the header
    sysread $fh, $buf, 16
        or die "sysread block header: $!";

    # perform byte swapping if needed
    my @unpack_h = unpack "${$self}{'swapl'}4", $buf;

    # parse header fields
    if (${$self}{'is_little_endian'}) {
        ${$bh}{'size'} = ($unpack_h[1] << 32) + $unpack_h[0];
    } else {
        ${$bh}{'size'} = ($unpack_h[0] << 32) + $unpack_h[1];
    }

    ${$bh}{'type'}	= $unpack_h[2];
    ${$bh}{'type_name'}	= $block_code{$unpack_h[2]};
    ${$bh}{'subtype'}	= $unpack_h[3];

    return $bh;
}

# pretty pring header fields
sub disp_block_header($$) {
    my $self	= shift;
    my $bh	= shift;
    print "\n[", ${$bh}{'type_name'},"]\n";
    print "start:\t ", ${$bh}{'start'}, "\n";
    print "size:\t ", ${$bh}{'size'}, "\n";
    print "subtype: ", ${$bh}{'subtype'}, "\n";
}

# skip to the beginning of next block
sub seek_next_block($$) {
    my $self	= shift;
    my $bh	= shift;

    my $pos;
    my $fh	= ${$self}{'file_handle'};

    if (${$bh}{'size'}) {
        # print "seeking to ", ${$bh}{'start'}+${$bh}{'size'}, "\n";

        $pos	= sysseek($fh, ${$bh}{'start'}+${$bh}{'size'}, SEEK_SET)
            or die "sysseek: $!";
    } else {
        $pos	= sysseek($fh, 0, SEEK_END)
            or die "sysseek: $!";
    }

    ${$self}{'pos'}	= $pos;

    return $pos;
}

# set file pos to the beginning of the current block header
sub seek_block_header($$) {
    my $self	= shift;
    my $bh	= shift;
    my $fh	= ${$self}{'file_handle'};

    # print "seeking to ${$bh}{'type_name'} header at", ${$bh}{'start'}, "\n";
    my $pos	= sysseek($fh, ${$bh}{'start'}, SEEK_SET)
        or die "sysseek: $!";

    ${$self}{'pos'}	= $pos;

    return $pos;
}

# set file pos to the beginning of the current block body
sub seek_block_data($$) {
    my $self	= shift;
    my $bh	= shift;
    my $fh	= ${$self}{'file_handle'};

    # print "seeking to block ${$bh}{'type_name'} data at ", ${$bh}{'start'}+16, "\n";
    my $pos	= sysseek($fh, ${$bh}{'start'}+16, SEEK_SET)
        or die "sysseek: $!";

    ${$self}{'pos'}	= $pos;

    return $pos;
}

# prepare to read a 'user raw' block
sub init_read_event($$$) {
    my $self		= shift;
    my $bh_hash		= ${$self}{'block_header_hash'};
    my $bh;

    if (${$self}{'arch_word'} == 64) {
        $bh	= ${$bh_hash}{'user raw 64'};
        ${$self}{'read_user_event'}	= \&read_user64_event;
    } else {
        $bh	= ${$bh_hash}{'user raw 32'};
        ${$self}{'read_user_event'}	= \&read_user32_event;
    }

    ${$self}{'ev_bh'}		= $bh;
    ${$self}{'ev_start'}	= seek_block_data($self, $bh);
    ${$self}{'pos'}		= ${$self}{'ev_start'};
    ${$self}{'ev_end'}		= ${$self}{'pos'} + ${$bh}{'size'} - 16;
}

# returns a bool indicating whether more events remain to be read or not
sub more_events($$) {
    my $self		= shift;

    # print "${$self}{'pos'} / ${$self}{'ev_end'}\n";
    return ${$self}{'pos'} < ${$self}{'ev_end'};
}

# pretty print an event
sub disp_event($$;$) {
    my $self		= shift;
    my $short_fmt	= shift;
    my $event;

    if (@_) {
        $event	= shift;
    } else {
        $event	= ${$self}{'ev_event'};
    }

    my $nb_params	= ${$event}{'nb_params'};
    my $a	= ${$event}{'param_array'};

    my $s	= '';

    if ($short_fmt) {
        $s	.= "${$event}{'time'},${$event}{'tid'},${$event}{'num'},$nb_params";
        for my $i (0..$nb_params-1) {
            $s	.= ",${$a}[$i]";
        }
    } else {
        $s	.= "time:\t\t ${$event}{'time'}\n";
        $s	.= "thread id:\t ${$event}{'tid'}\n";
#    $s .= "event code:\t %x\n", ${$event}{'code'};
        $s 	.= sprintf "event num:\t %x\n", ${$event}{'num'};

#    $s .= "nb params:\t ${nb_params}\n";

        for my $i (0..$nb_params-1) {
            $s	.= sprintf "param ${i}:\t %x\n", ${$a}[$i];
        }
    }

    return $s;
}

# 32bit version of the event block parsing routine
sub read_user32_event($$) {
    my $self	= shift;
    my $fh	= ${$self}{'file_handle'};
    my $buf;

    sysread $fh, $buf, 16
        or die "sysread event: $!";
    ${$self}{'pos'}	+= 16;
    my @unpack_buf = unpack "${$self}{'swapl'}4", $buf;

    my $time;
    if (${$self}{'is_little_endian'}) {
        $time = ($unpack_buf[1] << 32) + $unpack_buf[0];
    } else {
        $time = ($unpack_buf[0] << 32) + $unpack_buf[1];
    }

    my $tid	= $unpack_buf[2];
    my $code	= $unpack_buf[3];
    my $nb_params	= ($code & 0xff) - 1;
    my $num	= $code >> 8;

    my $a	= [];
    my $i;
    for $i (0..$nb_params-1) {
        my $param;

        sysread $fh, $buf, 4
            or die "read param: $!";
        ${$self}{'pos'}	+= 4;
        ($param)	= unpack "${$self}{swapl}", $buf;
        ${$a}[$i]	= $param;
    }

    my $event	= {};
    if (exists (${$self}{'time_offset'})) {
    } else {
        ${$self}{'time_offset'}	= $time;
    }

    ${$event}{'time_stamp'}	= $time;
    ${$event}{'time'}		= $time - ${$self}{'time_offset'};
    ${$event}{'tid'}		= $tid;
    ${$event}{'code'}		= $code;
    ${$event}{'num'}		= $num;
    ${$event}{'nb_params'}	= $nb_params;
    ${$event}{'param_array'}	= $a;

    ${$self}{'ev_event'}	= $event;
    return $event;
}

# 64bit version of the event block parsing routine
sub read_user64_event($$) {
    my $self	= shift;
    my $fh	= ${$self}{'file_handle'};
    my $buf;

    sysread $fh, $buf, 24
        or die "sysread event: $!";
    ${$self}{'pos'}	+= 24;
    my @unpack_buf = unpack "${$self}{'swapl'}6", $buf;

    my $time;
    if (${$self}{'is_little_endian'}) {
        $time = ($unpack_buf[1] << 32) + $unpack_buf[0];
    } else {
        $time = ($unpack_buf[0] << 32) + $unpack_buf[1];
    }

    my $tid;
    if (${$self}{'is_little_endian'}) {
        $tid = ($unpack_buf[3] << 32) + $unpack_buf[2];
    } else {
        $tid = ($unpack_buf[2] << 32) + $unpack_buf[3];
    }
    
    my $code;
    if (${$self}{'is_little_endian'}) {
        $code = ($unpack_buf[5] << 32) + $unpack_buf[4];
    } else {
        $code = ($unpack_buf[4] << 32) + $unpack_buf[5];
    }

    my $nb_params	= ($code & 0xff) - 1;
    my $num	= $code >> 8;

    my $a	= [];
    my $i;
    for $i (0..$nb_params-1) {
        sysread $fh, $buf, 8
            or die "read param: $!";
        ${$self}{'pos'}	+= 8;
        my ($param_0, $param_1)	= unpack "${$self}{swapl}2", $buf;
	my $param;
	if (${$self}{'is_little_endian'}) {
		$param = ($param_1 << 32) + $param_0;
	} else {
		$param = ($param_0 << 32) + $param_1;
	}

        ${$a}[$i]	= $param;
    }

    my $event	= {};
    if (exists (${$self}{'time_offset'})) {
    } else {
        ${$self}{'time_offset'}	= $time;
    }

    ${$event}{'time_stamp'}	= $time;
    ${$event}{'time'}		= $time - ${$self}{'time_offset'};
    ${$event}{'tid'}		= $tid;
    ${$event}{'code'}		= $code;
    ${$event}{'num'}		= $num;
    ${$event}{'nb_params'}	= $nb_params;
    ${$event}{'param_array'}	= $a;

    ${$self}{'ev_event'}	= $event;
    return $event;
}

# wrap calls to 32bit or 64bit event parsing routine
sub read_user_event($) {
    my $self	= shift;
    return &{${$self}{'read_user_event'}}($self);
}

# set the time stamp offset to that of the current event (or the passed as arg)
sub reset_time_offset($;$) {
    my $self		= shift;
    my $event;

    if (@_) {
        $event	= shift;
    } else {
        $event	= ${$self}{'ev_event'};
    }

    ${$self}{'time_offset'}	= ${$event}{'time_stamp'};
    ${$event}{'time'}		= ${$event}{'time_stamp'} - ${$self}{'time_offset'};
}

# constructor of the trace file class
sub init($$) {
    my $self	= {};
    bless $self;

    my $name	= shift;
    open my $fh, "<$name"
        or die "open <$name: $!";

    my $short_fmt	= shift;
    my $h	= {};
    my $bh;

    ${$self}{'file_handle'}		= $fh;		# File handle
    ${$self}{'file_name'}		= $name;    	# File name

    # Compute file size
    my $file_size	= sysseek $fh, 0, SEEK_END
        or die "sysseek: $!";
    sysseek $fh, 0, SEEK_SET;
    ${$self}{'file_size'}		= $file_size;	# File size

    # Read architecture code
    my $buf;
    sysread $fh, $buf, 4
        or die "read arch code: $!";
    my ($arch) = unpack "N1", $buf;
    ${$self}{'arch_code'}	= $arch_code{${arch}};
    ${$self}{'arch_word'}	= $arch_word{${arch}};

    print "arch ${arch}: ${$self}{'arch_code'}, ${$self}{'arch_word'} bits\n"
        unless $short_fmt;

    # Endianness
    my $is_le	= ($arch < 0x10000);
    if ($is_le) {
        print "little endian\n"
            unless $short_fmt;
        ${$self}{'swaps'}	= 'v';
        ${$self}{'swapl'}	= 'V';
    } else {
        print "big endian\n"
            unless $short_fmt;
        ${$self}{'swaps'}	= 'n';
        ${$self}{'swapl'}	= 'N';
    }
    ${$self}{'is_little_endian'}	= $is_le;	# Endianness

    # Read block headers
    my $pos	= sysseek($fh, 0, SEEK_CUR)
        or die "sysseek: $!";

    while ($pos < $file_size){
        $bh	= $self->read_block_header();
        $self->disp_block_header($bh)
            unless $short_fmt;
        ${$h}{${$bh}{'type_name'}}	= $bh;

        redo
            if ${$bh}{'type_name'} eq 'infos' ;

        $pos	= $self->seek_next_block($bh);
    }

    ${$self}{'file_pos'}		= $pos;		# File position
    ${$self}{'block_header_hash'}	= $h;		# Hash of blocks

    return $self;
}

# initialization of string hashes

$arch_code{0}		= 'i386';
$arch_code{1}		= 'ia64';
$arch_code{2}		= 'x86_64';

$arch_code{0x10000}	= 'PPC';
$arch_code{0x20000}	= 'PPC64';

$arch_word{0}		= 32;
$arch_word{1}		= 64;
$arch_word{2}		= 64;

$arch_word{0x10000}	= 32;
$arch_word{0x20000}	= 64;

$block_code{0x1}	= 'infos';

$block_code{0x10}	= 'time';
$block_code{0x11}	= 'uname';
$block_code{0x12}	= 'irqs';
$block_code{0x13}	= 'addrs';
$block_code{0x14}	= 'pids';

$block_code{0x100}	= 'kernel raw 32';
$block_code{0x101}	= 'kernel raw 64';

$block_code{0x200}	= 'user raw 32';
$block_code{0x201}	= 'user raw 64';

# -- MAIN package -- #
package main;
use Getopt::Std;


# .... Globals .... #
# Dispatch hash tables
my %num_hash;
my %num_name_hash;
my %handler_hash;

# State hash tables
my %thread_hash;

# Thread <-> VP relationship tables
my %vp_th_hash;

# Runqueue levels counter
my $nb_levels = 0;

# Reference timestamp
my $ev_ref_tstamp = undef;

# Paje dynamic color entity dashboard
my %paje_dyn_entity;

# Settings

## 0 - display Marcel's special threads (idle, run-task, ksoftirqd)
## 1 - do not display Marcel's special threads
my $filter_out_special_threads = 0;

## 0 - display ForestGOMP events (barrier, task wait)
## 1 - do not display ForestGOMP events
my $filter_out_fgomp_events = 0;

## 0 - display Task events
## 1 - do not display Task events
my $filter_out_task_events = 0;

## 0 - display events of the Bubble Cache scheduler
## 1 - do not display Bubble Cache events
my $filter_out_bcache_events = 0;

## 0 - display PAPI samples values
## 1 - do not display PAPI samples values
my $filter_out_papi_events = 0;

## 'text' - selects text-mode trace output
## 'paje' - selects paje-mode trace output
my $output_mode = 'text';

## 0 - display unknown/unhandled events
## 1 - do not display unknown/unhandled events
my $quiet_mode = 0;

## 0 - use effective event times as timestamps
## 1 - use a virtual timer as timestamps
my $time_warp_mode = 0;

## 0 - do not use thread color markers in the vp region
## 1 - do use thread color markers in the vp region
my $use_vp_thread_marker = 0;

# .... End of globals .... #

# .... Sub functions .... #
sub usage {
	print "marcel-fut.pl [options] <prof_file>\n";
	print "\t-h \t\tdisplay usage info\n";
	print "\t-q \t\tquiet mode\n";
	print "\t-o [text|paje] \toutput mode\n";
	print "\f-f [papi,special,gomp,...] \tfilter out some event subsets (comma separated list)\n";
	print "\t-t \t\ttime warp mode\n";
	print "\t-m \t\tthread color marker in the vp section\n";
	exit 0;
}

# Helpers
sub hsl_to_rgb($$$) {
	my $h = shift;
	my $s = shift;
	my $l = shift;
	my @rgb;
	my $q;
	my $p;

	if ($l < 1/2) {
		$q = $l * (1+$s);
	} else {
		$q = $l+$s - $l*$s;
	}

	$p = 2*$l - $q;
	$h %= 360;
	$h /= 360; 

	my $i;
	for $i (0..2) {
		my $t = $h + (1-$i)/3;
		if ($t < 0) {
			$t += 1;
		} elsif ($t > 1) {
			$t -= 1;
		}
		if ($t < 1/6) {
			$rgb[$i] = $p + (($q-$p)*6*$t);
		} elsif ($t < 1/2) {
			$rgb[$i] = $q;
		} elsif ($t < 2/3) {
			$rgb[$i] = $p + (($q-$p)*6*(2/3-$t));
		} else {
			$rgb[$i] = $p;
		}
	}

	return @rgb;
}

sub suffix_from_name($) {
	my $name = shift;
	my $suffix = '';
	if ($name =~ /^idle/) {
		$suffix = "_i";
	} elsif ($name =~ /^ksoftirqd/) {
		$suffix = "_k";
	} elsif ($name =~ /^run_task/) {
		$suffix = "_r";
	} elsif ($name =~ /^seed runner/) {
		$suffix = "_s";
	}
	return $suffix;
}

sub display_arrow($$) {
	my $thread_from = shift;
	my $thread_to = shift;

	unless (exists ${$thread_from}{'created'}) {
		return 0;
	}

	unless (exists ${$thread_to}{'created'}) {
		return 0;
	}

	if ($filter_out_special_threads == 1 and (${$thread_from}{'suffix'} ne '' or ${$thread_to}{'suffix'} ne '')) {
		return 0;
	}

	return 1;
}

# Generate time stamps out of event numbers or event times
sub tstamp($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_time = ${$event}{'time'};
	my $result;

	if ($time_warp_mode) {
		unless (defined $ev_ref_tstamp) {
			$ev_ref_tstamp = $ev_count;
		}
		$result = $ev_count - $ev_ref_tstamp;
	} else {
		unless (defined $ev_ref_tstamp) {
			$ev_ref_tstamp = $ev_time;
		}
		$result = $ev_time - $ev_ref_tstamp;
	}

	return $result;
}

sub tstamp_minus_e($) {
	my $event = shift;
	my $result = tstamp($event);
	if ($time_warp_mode) {
		$result = $result - 0.1;
	} else {
		$result = $result - 1;
	}
	return $result;
}

sub tstamp_plus_e($) {
	my $event = shift;
	my $result = tstamp($event);
	if ($time_warp_mode) {
		$result = $result + 0.1;
	} else {
		$result = $result + 1;
	}
	return $result;
}

# - Paje output mode -
sub handle_paje_FUT_SETUP_CODE		($) {
	print <<END_PAJE_HEADER
%EventDef	PajeDefineContainerType	1
%	Alias	string
%	ContainerType	string
%	Name	string
%EndEventDef
%EventDef	PajeDefineEventType	2
%	Alias	string
%	ContainerType	string
%	Name	string
%EndEventDef
%EventDef	PajeDefineStateType	3
%	Alias	string
%	ContainerType	string
%	Name	string
%EndEventDef
%EventDef	PajeDefineVariableType	4
%	Alias	string
%	ContainerType	string
%	Name	string
%EndEventDef
%EventDef	PajeDefineLinkType	5
%	Alias	string
%	ContainerType	string
%	SourceContainerType	string
%	DestContainerType	string
%	Name	string
%EndEventDef
%EventDef	PajeDefineEntityValue	6
%	Alias	string
%	EntityType	string
%	Name	string
%	Color	color
%EndEventDef
%EventDef	PajeCreateContainer	7
%	Time	date
%	Alias	string
%	Type	string
%	Container	string
%	Name	string
%EndEventDef
%EventDef	PajeDestroyContainer	8
%	Time	date
%	Name	string
%	Type	string
%EndEventDef
%EventDef	PajeNewEvent	9
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%EndEventDef
%EventDef	PajeSetState	10
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%       ThreadName      string
%EndEventDef
%EventDef	PajePushState	11
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%EndEventDef
%EventDef	PajePushState	111
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%	Object	string
%EndEventDef
%EventDef	PajePopState	12
%	Time	date
%	Type	string
%	Container	string
%EndEventDef
%EventDef	PajeSetVariable	13
%	Time	date
%	Type	string
%	Container	string
%	Value	double
%EndEventDef
%EventDef	PajeAddVariable	14
%	Time	date
%	Type	string
%	Container	string
%	Value	double
%EndEventDef
%EventDef	PajeSubVariable	15
%	Time	date
%	Type	string
%	Container	string
%	Value	double
%EndEventDef
%EventDef	PajeStartLink	16
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%	SourceContainer	string
%	Key	string
%	Size	int
%EndEventDef
%EventDef	PajeEndLink	17
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%	DestContainer	string
%	Key	string
%	Size	int
%EndEventDef
%EventDef	PajeStartLink	18
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%	SourceContainer	string
%	Key	string
%EndEventDef
%EventDef	PajeEndLink	19
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%	DestContainer	string
%	Key	string
%EndEventDef
%EventDef	PajeNewEvent   20
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%       EventName      string
%EndEventDef
%EventDef	PajeNewEvent   21
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%       EventName      string
%       ThreadName      string
%EndEventDef
%EventDef	PajeNewEvent   112
%	Time	date
%	Type	string
%	Container	string
%	Value	string
%       ThreadName      string
%       ThreadGroup     string
%       ThreadParent    string
%EndEventDef
1	CT_D	0	Display_type
1	CT_M	CT_D	Machine_container_type
1	CT_Mvp	CT_D	Machine_container_type_vp
1	CT_VPvp	CT_Mvp	VP_container_type_vp
1	CT_T	CT_M	Thread_container_type
1	CT_TE	CT_T	Thread_event_container_type
1	CT_TT	CT_T	Task_container_type
3	ST_BT	CT_TE	Barrier_thread_state_type
2	ET_BT	CT_TE	Barrier_thread_event_type
3	ST_TWT	CT_TE	Task_wait_thread_state_type
2	ET_TWT	CT_TE	Task_wait_thread_event_type
3	ST_TR	CT_TT	Task_run_thread_state_type
2	ET_TR	CT_TT	Task_run_thread_event_type
1	CT_BCE	CT_T	Bubble_cache_event_container_type
3	ST_BC	CT_BCE	Bubble_cache_state_type
2	ET_BC	CT_BCE	Bubble_cache_event_type
3	ST_T	CT_T	Thread_state_type
2	ET_SR	CT_T	Seed_run_event_type
3	ST_VPvp	CT_VPvp	VP_state_type_vp
6	tw	ST_TWT	waiting	\"0.5 0.0 0.9\"
6	tr	ST_TR	task	\"0.0 0.5 0.9\"
6	bw	ST_BT	waiting	\"0.0 0.0 0.9\"
6	sub	ST_BC	submit	\"0.9 0.0 0.5\"
6	rsub	ST_BC	rawsubmit	\"0.7 0.0 0.3\"
6	steal	ST_BC	steal	\"0.9 0.5 0.5\"
6	s	ST_T	sleep	\"0.5 0.2 0.2\"
6	s_s	ST_T	sleep	\"0.5 0.2 0.2\"
6	s_u	ST_T	sleep	\"0.5 0.5 0.5\"
6	s_i	ST_T	sleep	\"0.4 0.4 0.0\"
6	s_k	ST_T	sleep	\"0.5 0.2 0.0\"
6	s_r	ST_T	sleep	\"0.0 0.3 0.5\"
6	r	ST_T	running	\"0.0 0.7 0.0\"
6	r_s	ST_T	running	\"0.4 0.7 0.0\"
6	r_u	ST_T	running	\"0.8 0.8 0.8\"
6	r_i	ST_T	running	\"0.9 0.9 0.0\"
6	r_k	ST_T	running	\"0.9 0.6 0.0\"
6	r_r	ST_T	running	\"0.0 0.6 0.9\"
6	d	ST_T	dead	\"0.1 0.1 0.1\"
6	vp	ST_VPvp	user	\"0.0 1.0 0.5\"
6	vp_s	ST_VPvp	\"seed runner\"	\"0.0 1.0 0.5\"
6	vp_u	ST_VPvp	undef	\"0.8 0.8 0.8\"
6	vp_i	ST_VPvp	idle	\"0.9 0.9 0.5\"
6	vp_k	ST_VPvp	ksoftirqd	\"0.9 0.6 0.5\"
6	vp_r	ST_VPvp	run_task	\"0.0 0.5 0.9\"
7	0	D	CT_D	0	Display
7	0	M	CT_M	D	Machine
7	0	Mvp	CT_Mvp	D	VPs
5	LT_SW	CT_M	CT_T	CT_T	Link_type_switch
7	0	VPvp0	CT_VPvp	Mvp	VP_0
4       VAR_PAPI_0      CT_T    \"Papi event 0\"
4       VAR_PAPI_1      CT_T    \"Papi event 1\"
4       VAR_PAPI_2      CT_T    \"Papi event 2\"
4       VAR_PAPI_3      CT_T    \"Papi event 3\"
4       VAR_PAPI_0vp    CT_VPvp    \"Papi event 0\"
4       VAR_PAPI_1vp    CT_VPvp    \"Papi event 1\"
4       VAR_PAPI_2vp    CT_VPvp    \"Papi event 2\"
4       VAR_PAPI_3vp    CT_VPvp    \"Papi event 3\"
END_PAJE_HEADER
}

sub paje_display_create_thread($$) {
	my $event = shift;
	my $thread = shift;
	my $ev_tstamp = tstamp($event);
	my $th_tid = ${$thread}{'tid'};
	unless (exists ${$thread}{'created'}) {
		print "7 $ev_tstamp T$th_tid CT_T M Thread_$th_tid\n";
		${$thread}{'created'} = 1;
	}
}

sub paje_display_create_vp($$) {
	my $event = shift;
	my $vp_count = shift;
	my $ev_tstamp = tstamp($event);
	print "7 $ev_tstamp VPvp$vp_count CT_VPvp Mvp VP_$vp_count\n";
}

sub paje_display_thread_state($$) {
	my $event = shift;
	my $thread = shift;
	my $ev_tstamp = tstamp($event);
	if (exists ${$thread}{'created'}) {
		unless ($filter_out_special_threads and ${$thread}{'suffix'} ne '') {
			print "10 $ev_tstamp ST_T T${$thread}{'tid'} ${$thread}{'state'}${$thread}{'suffix'} \"${$thread}{'name'}\"\n";
		}
	}
}

# Random colorization
# args:
# . value
# . alias
# . entity type
# . name
# . s (saturation)
# . l (luminosity)
sub paje_rand_color_entity($$$$$$) {
	my $value = shift;
	my $alias = shift;
	if (exists $paje_dyn_entity{$alias.$value}) {
		return;
	}
	my $entity_type = shift;
	my $name = shift;
	my $s = shift;
	my $l = shift;
	$paje_dyn_entity{$alias.$value} = 1;
	my @rgb = hsl_to_rgb(rand(360), $s, $l);
	print "6\t$alias$value\t$entity_type\t$name\t\"$rgb[0] $rgb[1] $rgb[2]\"\n";
}

# Logarithmic RGB ramp
# args:
# . value
# . alias
# . entity type
# . name
# . red
# . green
# . blue
# . range
sub paje_log2_ramp_entity($$$$$$$$) {
	my $value = shift;
	my $alias = shift;
	if (exists $paje_dyn_entity{$alias.$value}) {
		return;
	}
	my $entity_type = shift;
	my $name = shift;
	my $r = shift;
	my $g = shift;
	my $b = shift;
	my $range = shift;

	my $factor = (log($value) / log(2) / $range);
	if ($factor > 1) {
		$factor = 1;
	}
	$factor = 1 - $factor;
	$paje_dyn_entity{$alias.$value} = 1;
	$r *= $factor;
	$g *= $factor;
	$b *= $factor;
	print "6\t$alias$value\t$entity_type\t$name\t\"$r $g $b\"\n";
}

# Logarithmic HSL ramp on Hue parameter 
# args:
# . value
# . alias
# . entity type
# . name
# . s (saturation)
# . l (luminosity)
# . range
sub paje_log2_hsl_ramp_entity($$$$$$$) {
	my $value = shift;
	my $alias = shift;
	if (exists $paje_dyn_entity{$alias.$value}) {
		return;
	}
	my $entity_type = shift;
	my $name = shift;
	my $s = shift;
	my $l = shift;
	my $range = shift;

	my $factor = (log($value) / log(2) / $range);
	my @rgb = hsl_to_rgb(360*$factor, $s, $l);
	$paje_dyn_entity{$alias.$value} = 1;
	my $r = shift @rgb;
	my $g = shift @rgb;
	my $b = shift @rgb;
	print "6\t$alias$value\t$entity_type\t$name\t\"$r $g $b\"\n";
}

sub paje_display_vp_thread_state($$) {
	my $event = shift;
	my $thread = shift;
	my $ev_tstamp = tstamp($event);
	my $vp_count = 0;
	if (exists ${$thread}{'vp'}) {
		$vp_count = ${$thread}{'vp'};
	}
	if ($use_vp_thread_marker == 0 or ${$thread}{'suffix'} ne '' and ${$thread}{'suffix'} ne '_s') {
		print "10 $ev_tstamp ST_VPvp VPvp$vp_count vp${$thread}{'suffix'} \"VP_$vp_count\"\n";
	} else {
		paje_rand_color_entity(${$thread}{'tid'},'vp','ST_VPvp',"running", 1, 0.8);
		print "10 $ev_tstamp ST_VPvp VPvp$vp_count vp${$thread}{'tid'} \"VP_$vp_count\"\n";
	}
}

sub paje_display_switch_arrow_begin($$) {
	my $event = shift;
	my $thread_from = shift;
	my $b_ev_tstamp = tstamp_minus_e($event);
	print "18 $b_ev_tstamp LT_SW M 0 T${$thread_from}{'tid'} ${$event}{'count'}\n";
}

sub paje_display_switch_arrow_end($$) {
	my $event = shift;
	my $thread_to = shift;
	my $e_ev_tstamp = tstamp_plus_e($event);
	print "19 $e_ev_tstamp LT_SW M 0 T${$thread_to}{'tid'} ${$event}{'count'}\n";
}

sub paje_check_task_container($$) {
	my $event = shift;
	my $thread = shift;

	unless (exists ${$thread}{'task'}) {
		${$thread}{'task'}= 1;
		my $ev_tstamp = tstamp($event);
		print "7 $ev_tstamp TT${$thread}{'tid'} CT_TT T${$thread}{'tid'} \"tasks\"\n";
	}
}
sub paje_check_thread_event_container($$) {
	my $event = shift;
	my $thread = shift;

	unless (exists ${$thread}{'thread_ev'}) {
		${$thread}{'thread_ev'}= 1;
		my $ev_tstamp = tstamp($event);
		print "7 $ev_tstamp TE${$thread}{'tid'} CT_TE T${$thread}{'tid'} \"events\"\n";
	}
}

sub paje_check_bcache_event_container($$) {
	my $event = shift;
	my $thread = shift;

	unless (exists ${$thread}{'bcache_ev'}) {
		${$thread}{'bcache_ev'}= 1;
		my $ev_tstamp = tstamp($event);
		print "7 $ev_tstamp BCE${$thread}{'tid'} CT_BCE T${$thread}{'tid'} \"bubble cache events\"\n";
	}
}

# -

sub handle_paje_FUT_THREAD_BIRTH_CODE	($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_time = ${$event}{'time'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $th_tid = shift @$param_array;
	my ($param_1) = unpack 'l', (pack 'q', (@$param_array));

	my $thread;
	if (exists ${thread_hash}{$th_tid}) {
		$thread = ${thread_hash}{$th_tid};
	} else {
		$thread = {};
		${$thread}{'tid'} = $th_tid;
		${thread_hash}{$th_tid} = $thread;
	}
	${$thread}{'name'} = 'undefined';
	${$thread}{'state'} = 's';
	${$thread}{'suffix'} = '_u';

	unless ($filter_out_special_threads) {
		paje_display_create_thread($event, $thread);
		paje_display_thread_state($event, $thread);
	}
}

sub handle_paje_FUT_SET_THREAD_NAME_CODE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $th_tid = shift @$param_array;
	my ($th_name) = unpack 'Z*', (pack 'q*', (@$param_array));
	my $thread = ${thread_hash}{$th_tid};
	${$thread}{'name'} = $th_name;
	${$thread}{'suffix'} = suffix_from_name($th_name);
	if (!$filter_out_special_threads or ${$thread}{'suffix'} eq '') {
		paje_display_create_thread($event, $thread);
		paje_display_thread_state($event, $thread);
		paje_display_vp_thread_state($event, $thread);
	}
}

sub handle_paje_FUT_SWITCH_TO_CODE		($) {
	my $event = shift;
	my $th_from_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $th_to_tid = ${$param_array}[0];
	
	my $thread_from = ${thread_hash}{$th_from_tid};
	if (${$thread_from}{'state'} ne 'd') {
		${$thread_from}{'state'} = 's';
	}

	my $thread_to = ${thread_hash}{$th_to_tid};
	${$thread_to}{'state'} = 'r';

	my $display_arrow = display_arrow($thread_from, $thread_to);
	if ($display_arrow) {
		paje_display_switch_arrow_begin($event, $thread_from);
	}
	paje_display_thread_state($event, $thread_from);
	paje_display_thread_state($event, $thread_to);

	my $vp_count = 0;
	if (exists ${$thread_from}{'vp'}) {
		$vp_count = ${$thread_from}{'vp'};
		delete ${$thread_from}{'vp'};
	}
	${vp_th_hash}{$vp_count} = $thread_to;
	${$thread_to}{'vp'} = $vp_count;

	paje_display_vp_thread_state($event, $thread_to);
	if ($display_arrow) {
		paje_display_switch_arrow_end($event, $thread_to);
	}
}

sub handle_paje_FUT_THREAD_DEATH_CODE	($) {
	my $event = shift;
	my $param_array = ${$event}{'param_array'};
	my $th_tid = ${$param_array}[0];
	my $thread = ${thread_hash}{$th_tid};
	${$thread}{'suffix'} = '';
	${$thread}{'state'} = 'd';
	paje_display_thread_state($event, $thread);
}

sub handle_paje_FUT_NEW_LWP_CODE		($) {
	my $event = shift;
	my $param_array = ${$event}{'param_array'};
	my $vp_count = ${$param_array}[0];
	my $th_tid = ${$param_array}[1];

	my $thread = ${thread_hash}{$th_tid};
	${$thread}{'state'} = 'r';
	${$thread}{'vp'} = $vp_count;
	${vp_th_hash}{$vp_count} = $thread;

	paje_display_thread_state($event, $thread);
	paje_display_create_vp($event, $vp_count);
	paje_display_vp_thread_state($event, $thread);
}

sub handle_paje_FUT_FGOMP_PAPIMAR_EV		($$) {
	my $papi_ev = shift;
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $ev_val = ${$param_array}[0];
	my $thread = ${thread_hash}{$ev_tid};

	my $vp_count = 0;
	if (exists ${$thread}{'vp'}) {
		$vp_count = ${$thread}{'vp'};
	}

	my $ev_tstamp = tstamp($event);
	print "13 $ev_tstamp VAR_PAPI_$papi_ev T$ev_tid $ev_val\n";
	print "13 $ev_tstamp VAR_PAPI_${papi_ev}vp VPvp$vp_count $ev_val\n";
}

sub handle_paje_FUT_FGOMP_PAPIMAR_EV0		($) {
	my $event = shift;
	handle_paje_FUT_FGOMP_PAPIMAR_EV (0, $event);
}

sub handle_paje_FUT_FGOMP_PAPIMAR_EV1		($) {
	my $event = shift;
	handle_paje_FUT_FGOMP_PAPIMAR_EV (1, $event);
}

sub handle_paje_FUT_FGOMP_PAPIMAR_EV2		($) {
	my $event = shift;
	handle_paje_FUT_FGOMP_PAPIMAR_EV (2, $event);
}

sub handle_paje_FUT_FGOMP_PAPIMAR_EV3		($) {
	my $event = shift;
	handle_paje_FUT_FGOMP_PAPIMAR_EV (3, $event);
}

sub handle_paje_FUT_FGOMP_GOMP_BAR_ENTER	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_thread_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_BT TE$ev_tid \"entering barrier\" \"barrier enter\"\n";
	print "11 $ev_tstamp ST_BT TE$ev_tid bw\n";
}

sub handle_paje_FUT_FGOMP_GOMP_BAR_LEAVE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_thread_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "12 $ev_tstamp ST_BT TE$ev_tid\n";
	print "20 $ev_tstamp ET_BT TE$ev_tid \"leaving barrier\" \"barrier leave\"\n";
}

sub handle_paje_FUT_FGOMP_GOMP_TASK_WAIT_ENTER	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $depth = ${$param_array}[0];
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_thread_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_TWT TE$ev_tid \"entering taskwait\" \"task wait enter\"\n";
	paje_log2_ramp_entity($depth,'tw','ST_TWT',"task_wait($depth)", 0.5, 0.0, 0.9, 5);
	print "11 $ev_tstamp ST_TWT TE$ev_tid tw$depth\n";
}

sub handle_paje_FUT_FGOMP_GOMP_TASK_WAIT_LEAVE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_thread_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "12 $ev_tstamp ST_TWT TE$ev_tid\n";
	print "20 $ev_tstamp ET_TWT TE$ev_tid \"leaving task wait\" \"task wait leave\"\n";
}

sub handle_paje_FUT_FGOMP_GOMP_TASK_ENTER	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $depth = ${$param_array}[0]-1;
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_task_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_TR TT$ev_tid \"new task\" \"task enter\"\n";
	paje_log2_hsl_ramp_entity($depth,'tr','ST_TR',"task($depth)", 1.0, 0.5, 8);
	#paje_log2_ramp_entity($depth,'tr','ST_TR',"task($depth)", 0.0, 0.5, 0.9, 8);
	#paje_rand_color_entity($depth,'tr','ST_TR',"task($depth)");
	print "11 $ev_tstamp ST_TR TT$ev_tid tr$depth\n";
}

sub handle_paje_FUT_FGOMP_GOMP_TASK_LEAVE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_task_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "12 $ev_tstamp ST_TR TT$ev_tid\n";
	print "20 $ev_tstamp ET_TR TT$ev_tid \"task complete\" \"task leave\"\n";
}

sub handle_paje_FUT_BCACHE_SCHED_SUBMIT_ENTER	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_bcache_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_BC BCE$ev_tid \"entering sched submit\" \"sched submit enter\"\n";
	print "11 $ev_tstamp ST_BC BCE$ev_tid sub\n";
}

sub handle_paje_FUT_BCACHE_SCHED_SUBMIT_LEAVE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_bcache_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "12 $ev_tstamp ST_BC BCE$ev_tid\n";
	print "20 $ev_tstamp ET_BC BCE$ev_tid \"leaving sched submit\" \"sched submit leave\"\n";
}

sub handle_paje_FUT_BCACHE_SCHED_RAWSUBMIT_ENTER	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_bcache_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_BC BCE$ev_tid \"entering sched rawsubmit\" \"sched rawsubmit enter\"\n";
	print "11 $ev_tstamp ST_BC BCE$ev_tid rsub\n";
}

sub handle_paje_FUT_BCACHE_SCHED_RAWSUBMIT_LEAVE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_bcache_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "12 $ev_tstamp ST_BC BCE$ev_tid\n";
	print "20 $ev_tstamp ET_BC BCE$ev_tid \"leaving sched rawsubmit\" \"sched rawsubmit leave\"\n";
}

sub handle_paje_FUT_BCACHE_STEAL_ENTER	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_bcache_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_BC BCE$ev_tid \"entering steal\" \"steal enter\"\n";
	print "11 $ev_tstamp ST_BC BCE$ev_tid steal\n";
}

sub handle_paje_FUT_BCACHE_STEAL_LEAVE	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_bcache_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "12 $ev_tstamp ST_BC BCE$ev_tid\n";
	print "20 $ev_tstamp ET_BC BCE$ev_tid \"leaving steal\" \"steal leave\"\n";
}

sub handle_paje_THREAD_SEED_RUN	($) {
	my $event = shift;
	my $ev_tid = ${$event}{'tid'};
	my $thread = ${thread_hash}{$ev_tid};
	paje_check_thread_event_container($event, $thread);
	my $ev_tstamp = tstamp($event);
	print "20 $ev_tstamp ET_SR T$ev_tid \"seed run\" \"seed run\"\n";
}

# - Text output mode -
sub handle_FUT_GCC_INSTRUMENT_ENTRY_CODE($) {
	print "<FUT_GCC_INSTRUMENT_ENTRY_CODE>\n";
}

sub handle_FUT_GCC_INSTRUMENT_EXIT_CODE($) {
	print "<FUT_GCC_INSTRUMENT_EXIT_CODE>\n";
}

sub handle_FUT_SETUP_CODE		($) {
	print "<FUT_SETUP_CODE>\n";
}

sub handle_FUT_CALIBRATE0_CODE		($) {
	print "<FUT_CALIBRATE0_CODE>\n";
}

sub handle_FUT_CALIBRATE1_CODE		($) {
	print "<FUT_CALIBRATE1_CODE>\n";
}

sub handle_FUT_CALIBRATE2_CODE		($) {
	print "<FUT_CALIBRATE2_CODE>\n";
}

sub handle_FUT_RQS_NEWLEVEL		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	print "$ev_count [$ev_tid]: New level $nb_levels created with [$param_0] runqueues\n";
	$nb_levels++;
}

sub handle_FUT_RQS_NEWRQ		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my ($s_temp) = pack 'q', (@$param_array);
	my ($param_0) = unpack 'l', ($s_temp);
	my $param_1 = @$param_array[1];
	print "$ev_count [$ev_tid]: New rq [$param_1] at level [$param_0] created\n";
}

sub handle_BUBBLE_SCHED_NEW		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	print "$ev_count [$ev_tid]: New bubble [$param_0] created\n";
}

sub handle_FUT_THREAD_BIRTH_CODE	($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	shift @$param_array;
	my ($s_temp) = pack 'q', (@$param_array);
	my ($param_1) = unpack 'l', ($s_temp);
	print "$ev_count [$ev_tid]: Thread [$param_0] created on VP [$param_1]\n";
}

sub handle_SET_THREAD_NUMBER		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	my $param_1 = ${$param_array}[1];
	print "$ev_count [$ev_tid]: Thread [$param_0] numbered [$param_1]\n";
}

sub handle_FUT_SET_THREAD_NAME_CODE	($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $line = ${$event}{'line'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = shift @$param_array;
	my ($name_s_temp) = pack 'q*', (@$param_array);
	my ($name_s) = unpack 'Z*', ($name_s_temp);
	my $name = join ' - ',(@$param_array);

	print "$ev_count [$ev_tid]: Thread [$param_0] named [$name_s]\n";
}

sub handle_FUT_SWITCH_TO_CODE		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	print "$ev_count [$ev_tid]: Switch to thread $param_0\n";
}

sub handle_FUT_THREAD_DEATH_CODE	($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	print "$ev_count [$ev_tid]: Thread [$param_0] dead\n";
}

sub handle_FUT_RQS_NEWLWPRQ		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my ($s_temp) = pack 'q', (@$param_array);
	my ($param_0) = unpack 'l', ($s_temp);
	my $param_1 = @$param_array[1];
	print "$ev_count [$ev_tid]: New VP rq [$param_1] at VP [$param_0] created\n";
}

sub handle_FUT_NEW_LWP_CODE		($) {
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $param_0 = ${$param_array}[0];
	my $param_1 = ${$param_array}[1];
	print "$ev_count [$ev_tid]: New VP [$param_0] running thread [$param_1]\n";
}

sub handle_FUT_FGOMP_PAPIMAR_EV		($$) {
	my $papi_ev = shift;
	my $event = shift;
	my $ev_count = ${$event}{'count'};
	my $ev_tid = ${$event}{'tid'};
	my $param_array = ${$event}{'param_array'};
	my $ev_val = ${$param_array}[0];

	print "$ev_count [$ev_tid]: PAPI event$papi_ev sample: $ev_val\n";
}

sub handle_FUT_FGOMP_PAPIMAR_EV0		($) {
	my $event = shift;
	handle_FUT_FGOMP_PAPIMAR_EV (0, $event);
}

sub handle_FUT_FGOMP_PAPIMAR_EV1		($) {
	my $event = shift;
	handle_FUT_FGOMP_PAPIMAR_EV (1, $event);
}

sub handle_FUT_FGOMP_PAPIMAR_EV2		($) {
	my $event = shift;
	handle_FUT_FGOMP_PAPIMAR_EV (2, $event);
}

sub handle_FUT_FGOMP_PAPIMAR_EV3		($) {
	my $event = shift;
	handle_FUT_FGOMP_PAPIMAR_EV (3, $event);
}
# .... End of sub functions .... #

# .... Main entry point of the program .... #
# Command line processing
my %opts;
my $ret	= getopts('hqo:f:tm', \%opts);	# -h -q -o <output_mode> -f <filtered_out_event_subsets -t -m

if (exists $opts{'h'}) {
	usage();
}

if (exists $opts{'q'}) {
	$quiet_mode	= 1;
}

if (exists $opts{'o'}) {
	$output_mode	= $opts{'o'};
	if ($output_mode ne 'paje' and $output_mode ne 'text') {
		usage();
	}
}

my %filter_out;
if (exists $opts{'f'}) {
	my $filter_events	= $opts{'f'};
	my @filter_event_list = split /,/, $filter_events;
	foreach (@filter_event_list) {
		$filter_out{$_} = 1;
	}
}

if (exists $filter_out{'special'}) {
	$filter_out_special_threads = 1;
}

if (exists $filter_out{'fgomp'}) {
	$filter_out_fgomp_events = 1;
}

if (exists $filter_out{'task'}) {
	$filter_out_task_events = 1;
}

if (exists $filter_out{'bcache'}) {
	$filter_out_bcache_events = 1;
}

if (exists $filter_out{'papi'}) {
	$filter_out_papi_events = 1;
}

if (exists $opts{'t'}) {
	$time_warp_mode	= 1;
}

if (exists $opts{'m'}) {
	$use_vp_thread_marker	= 1;
}

# Read FUT nums / num_names mapping using the output of the fut-codes.pl script
open my $num_desc, "fut-codes.pl|" or die "open [fut-codes.pl|] failed: $!\n";	# Open a pipe descriptor

while (<$num_desc>) {						# Loop over each line
	chomp;							# Remove trailing \n
	my ($num_name, $num_val) = split /,/;			# Split line into fields
	#print "$num_name: $num_val\n";
	${num_hash}{$num_name} = $num_val;			# Map code name onto code value
	if (! exists ${num_name_hash}{$num_val}) {
		${num_name_hash}{$num_val} = $num_name;		# Map code value onto code name
								# Note: If multiple code names share the same code value
								# only the first one is taken into account
	}
}

# - Output mode dispatch -
if ($output_mode eq 'paje') {
	${handler_hash}{ ${num_hash}{'FUT_SETUP_CODE'} } = \&handle_paje_FUT_SETUP_CODE;
	${handler_hash}{ ${num_hash}{'FUT_THREAD_BIRTH_CODE'} } = \&handle_paje_FUT_THREAD_BIRTH_CODE;
	${handler_hash}{ ${num_hash}{'FUT_SET_THREAD_NAME_CODE'} } = \&handle_paje_FUT_SET_THREAD_NAME_CODE;
	${handler_hash}{ ${num_hash}{'FUT_SWITCH_TO_CODE'} } = \&handle_paje_FUT_SWITCH_TO_CODE;
	${handler_hash}{ ${num_hash}{'FUT_THREAD_DEATH_CODE'} } = \&handle_paje_FUT_THREAD_DEATH_CODE;
	${handler_hash}{ ${num_hash}{'FUT_NEW_LWP_CODE'} } = \&handle_paje_FUT_NEW_LWP_CODE;
	unless ($filter_out_fgomp_events) {
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_GOMP_BAR_ENTER'} } = \&handle_paje_FUT_FGOMP_GOMP_BAR_ENTER;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_GOMP_BAR_LEAVE'} } = \&handle_paje_FUT_FGOMP_GOMP_BAR_LEAVE;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_GOMP_TASK_WAIT_ENTER'} } = \&handle_paje_FUT_FGOMP_GOMP_TASK_WAIT_ENTER;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_GOMP_TASK_WAIT_LEAVE'} } = \&handle_paje_FUT_FGOMP_GOMP_TASK_WAIT_LEAVE;
	}
	unless ($filter_out_task_events) {
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_GOMP_TASK_ENTER'} } = \&handle_paje_FUT_FGOMP_GOMP_TASK_ENTER;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_GOMP_TASK_LEAVE'} } = \&handle_paje_FUT_FGOMP_GOMP_TASK_LEAVE;
	}
	unless ($filter_out_bcache_events) {
		${handler_hash}{ ${num_hash}{'FUT_BCACHE_SCHED_SUBMIT_ENTER'} } = \&handle_paje_FUT_BCACHE_SCHED_SUBMIT_ENTER;
		${handler_hash}{ ${num_hash}{'FUT_BCACHE_SCHED_SUBMIT_LEAVE'} } = \&handle_paje_FUT_BCACHE_SCHED_SUBMIT_LEAVE;
		${handler_hash}{ ${num_hash}{'FUT_BCACHE_SCHED_RAWSUBMIT_ENTER'} } = \&handle_paje_FUT_BCACHE_SCHED_RAWSUBMIT_ENTER;
		${handler_hash}{ ${num_hash}{'FUT_BCACHE_SCHED_RAWSUBMIT_LEAVE'} } = \&handle_paje_FUT_BCACHE_SCHED_RAWSUBMIT_LEAVE;
		${handler_hash}{ ${num_hash}{'FUT_BCACHE_STEAL_ENTER'} } = \&handle_paje_FUT_BCACHE_STEAL_ENTER;
		${handler_hash}{ ${num_hash}{'FUT_BCACHE_STEAL_LEAVE'} } = \&handle_paje_FUT_BCACHE_STEAL_LEAVE;
	}

	${handler_hash}{ ${num_hash}{'THREAD_SEED_RUN'} } = \&handle_paje_THREAD_SEED_RUN;


	unless ($filter_out_papi_events) {
		unless ($filter_out_fgomp_events) {
			${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV0'} } = \&handle_paje_FUT_FGOMP_PAPIMAR_EV0;
			${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV1'} } = \&handle_paje_FUT_FGOMP_PAPIMAR_EV1;
			${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV2'} } = \&handle_paje_FUT_FGOMP_PAPIMAR_EV2;
			${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV3'} } = \&handle_paje_FUT_FGOMP_PAPIMAR_EV3;
		}
	}
} else {
	${handler_hash}{ ${num_hash}{'FUT_GCC_INSTRUMENT_ENTRY_CODE'} } = \&handle_FUT_GCC_INSTRUMENT_ENTRY_CODE;
	${handler_hash}{ ${num_hash}{'FUT_GCC_INSTRUMENT_EXIT_CODE'} } = \&handle_FUT_GCC_INSTRUMENT_EXIT_CODE;
	${handler_hash}{ ${num_hash}{'FUT_SETUP_CODE'} } = \&handle_FUT_SETUP_CODE;
	${handler_hash}{ ${num_hash}{'FUT_CALIBRATE0_CODE'} } = \&handle_FUT_CALIBRATE0_CODE;
	${handler_hash}{ ${num_hash}{'FUT_CALIBRATE1_CODE'} } = \&handle_FUT_CALIBRATE1_CODE;
	${handler_hash}{ ${num_hash}{'FUT_CALIBRATE2_CODE'} } = \&handle_FUT_CALIBRATE2_CODE;
	${handler_hash}{ ${num_hash}{'FUT_RQS_NEWLEVEL'} } = \&handle_FUT_RQS_NEWLEVEL;
	${handler_hash}{ ${num_hash}{'FUT_RQS_NEWRQ'} } = \&handle_FUT_RQS_NEWRQ;
	${handler_hash}{ ${num_hash}{'BUBBLE_SCHED_NEW'} } = \&handle_BUBBLE_SCHED_NEW;
	${handler_hash}{ ${num_hash}{'FUT_THREAD_BIRTH_CODE'} } = \&handle_FUT_THREAD_BIRTH_CODE;
	${handler_hash}{ ${num_hash}{'SET_THREAD_NUMBER'} } = \&handle_SET_THREAD_NUMBER;
	${handler_hash}{ ${num_hash}{'FUT_SET_THREAD_NAME_CODE'} } = \&handle_FUT_SET_THREAD_NAME_CODE;
	${handler_hash}{ ${num_hash}{'FUT_SWITCH_TO_CODE'} } = \&handle_FUT_SWITCH_TO_CODE;
	${handler_hash}{ ${num_hash}{'FUT_THREAD_DEATH_CODE'} } = \&handle_FUT_THREAD_DEATH_CODE;
	${handler_hash}{ ${num_hash}{'FUT_RQS_NEWLWPRQ'} } = \&handle_FUT_RQS_NEWLWPRQ;
	${handler_hash}{ ${num_hash}{'FUT_NEW_LWP_CODE'} } = \&handle_FUT_NEW_LWP_CODE;

	unless ($filter_out_papi_events) {
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV0'} } = \&handle_FUT_FGOMP_PAPIMAR_EV0;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV1'} } = \&handle_FUT_FGOMP_PAPIMAR_EV1;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV2'} } = \&handle_FUT_FGOMP_PAPIMAR_EV2;
		${handler_hash}{ ${num_hash}{'FUT_FGOMP_PAPIMAR_EV3'} } = \&handle_FUT_FGOMP_PAPIMAR_EV3;
	}
}

# Read Tracefile
my $ev_count	 = 0;						# Store the number of events processed so far
my $trace_filename = shift @ARGV;				# Get the trace filename from command line
my $file_object	= TraceFile::init($trace_filename, 1);		# Build a tracefile reader object
$file_object->init_read_event();				# Bootstrap the event pump
while ($file_object->more_events()) {				# Loop over the events
	my $event	= $file_object->read_user_event();	# Fetch an event
	${$event}{'count'}	= $ev_count;			# Add a count field to the event
	my $ev_num	= ${$event}{'num'};			# Get the event code
	if (exists ${handler_hash}{$ev_num}) {			# See if we have an handler for this code
		my $handler_sub = ${handler_hash}{$ev_num};		# YES: retrieve that handler...
		&{$handler_sub}($event);				# ... and call it on the event
	} else {
		# NO: we don't have any handler for this event. If requested, we display the information we know about that event
		if ($quiet_mode == 0) {
			if (exists ${num_name_hash}{$ev_num}) {
				print "unhandled event $ev_num - ".(${num_name_hash}{$ev_num})."\n";
			} else {
				print "unhandled event $ev_num - <UNKNOWN CODE>\n";
			}
		}
	}
    $ev_count++;
}

