diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-common.h gcc-4.2.2/gcc/c-common.h
--- gcc-4.2.2.orig/gcc/c-common.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-common.h	2007-11-07 14:17:49.000000000 +0100
@@ -947,6 +947,7 @@ extern tree c_finish_omp_master (tree);
 extern tree c_finish_omp_critical (tree, tree);
 extern tree c_finish_omp_ordered (tree);
 extern void c_finish_omp_barrier (void);
+extern void c_finish_omp_taskwait (void);
 extern tree c_finish_omp_atomic (enum tree_code, tree, tree);
 extern void c_finish_omp_flush (void);
 extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-omp.c gcc-4.2.2/gcc/c-omp.c
--- gcc-4.2.2.orig/gcc/c-omp.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-omp.c	2007-11-07 14:20:53.000000000 +0100
@@ -79,6 +79,18 @@ c_finish_omp_barrier (void)
   add_stmt (x);
 }
 
+/* Complete a #pragma omp taskwait construct.  */
+
+void
+c_finish_omp_taskwait (void)
+{
+  tree x;
+
+  x = built_in_decls[BUILT_IN_GOMP_TASKWAIT];
+  x = build_function_call_expr (x, NULL);
+  add_stmt (x);
+}
+
 
 /* Complete a #pragma omp atomic construct.  The expression to be 
    implemented atomically is LHS code= RHS.  The value returned is
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-parser.c gcc-4.2.2/gcc/c-parser.c
--- gcc-4.2.2.orig/gcc/c-parser.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-parser.c	2007-11-07 15:41:35.000000000 +0100
@@ -215,7 +215,9 @@ typedef enum pragma_omp_clause {
   PRAGMA_OMP_CLAUSE_PRIVATE,
   PRAGMA_OMP_CLAUSE_REDUCTION,
   PRAGMA_OMP_CLAUSE_SCHEDULE,
-  PRAGMA_OMP_CLAUSE_SHARED
+  PRAGMA_OMP_CLAUSE_SHARED,
+  PRAGMA_OMP_CLAUSE_CAPTUREPRIVATE,
+  PRAGMA_OMP_CLAUSE_SWITCH
 } pragma_omp_clause;
 
 
@@ -1035,6 +1037,7 @@ static tree c_parser_expr_list (c_parser
 static void c_parser_omp_construct (c_parser *);
 static void c_parser_omp_threadprivate (c_parser *);
 static void c_parser_omp_barrier (c_parser *);
+static void c_parser_omp_taskwait (c_parser *);
 static void c_parser_omp_flush (c_parser *);
 
 enum pragma_context { pragma_external, pragma_stmt, pragma_compound };
@@ -6517,6 +6520,17 @@ c_parser_pragma (c_parser *parser, enum 
 
   switch (id)
     {
+    case PRAGMA_OMP_TASKWAIT:
+      if (context != pragma_compound)
+	{
+	  if (context == pragma_stmt)
+	    c_parser_error (parser, "%<#pragma omp taskwait%> may only be "
+			    "used in compound statements");
+	  goto bad_stmt;
+	}
+      c_parser_omp_taskwait (parser);
+      return false;
+    
     case PRAGMA_OMP_BARRIER:
       if (context != pragma_compound)
 	{
@@ -7322,6 +7336,19 @@ c_parser_omp_barrier (c_parser *parser)
   c_finish_omp_barrier ();
 }
 
+/* OpenMP 3.0 draft:
+   # pragma omp taskwait new-line
+*/
+
+static void
+c_parser_omp_taskwait (c_parser *parser)
+{
+  c_parser_consume_pragma (parser);
+  c_parser_skip_to_pragma_eol (parser);
+
+  c_finish_omp_taskwait ();
+}
+
 /* OpenMP 2.5:
    # pragma omp critical [(name)] new-line
      structured-block
@@ -7715,6 +7742,31 @@ c_parser_omp_parallel (c_parser *parser)
   return stmt;
 }
 
+/* OpenMP 3.0 draft:
+   # pragma task task-clause new-line
+*/
+
+#define OMP_TASK_CLAUSE_MASK			\
+	( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)		\
+	| (1u << PRAGMA_OMP_CLAUSE_CAPTUREPRIVATE)	\
+	| (1u << PRAGMA_OMP_CLAUSE_SHARED)		\
+	| (1u << PRAGMA_OMP_CLAUSE_SWITCH))
+
+static tree
+c_parser_omp_task (c_parser *parser)
+{
+  const char *p_name = "#pragma omp task";
+  tree stmt, clauses, block;
+  unsigned int mask = OMP_TASK_CLAUSE_MASK;
+
+  clauses = c_parser_omp_all_clauses (parser, mask, p_name);
+  block = c_begin_omp_task ();
+  c_parser_statement (parser);
+  stmt = c_finish_omp_task (clauses, block);
+
+  return stmt;
+}
+
 /* OpenMP 2.5:
    # pragma omp single single-clause[optseq] new-line
      structured-block
@@ -7786,6 +7838,14 @@ c_parser_omp_construct (c_parser *parser
     case PRAGMA_OMP_SINGLE:
       stmt = c_parser_omp_single (parser);
       break;
+    case PRAGMA_OMP_TASK:
+      stmt = c_parser_omp_task (parser);
+      break;
+#if 0
+    case PRAGMA_OMP_TASKGROUP:
+      stmt = c_parser_omp_taskgroup (parser);
+      break;
+#endif
     default:
       gcc_unreachable ();
     }
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-pragma.c gcc-4.2.2/gcc/c-pragma.c
--- gcc-4.2.2.orig/gcc/c-pragma.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-pragma.c	2007-10-31 11:30:28.000000000 +0100
@@ -797,7 +797,10 @@ init_pragma (void)
 	{ "section", PRAGMA_OMP_SECTION },
 	{ "sections", PRAGMA_OMP_SECTIONS },
 	{ "single", PRAGMA_OMP_SINGLE },
-	{ "threadprivate", PRAGMA_OMP_THREADPRIVATE }
+	{ "threadprivate", PRAGMA_OMP_THREADPRIVATE },
+	{ "task", PRAGMA_OMP_TASK },
+	{ "taskwait", PRAGMA_OMP_TASKWAIT },
+	{ "taskgroup", PRAGMA_OMP_TASKGROUP }
       };
 
       const int n_omp_pragmas = sizeof (omp_pragmas) / sizeof (*omp_pragmas);
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-pragma.h gcc-4.2.2/gcc/c-pragma.h
--- gcc-4.2.2.orig/gcc/c-pragma.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-pragma.h	2007-10-31 11:29:12.000000000 +0100
@@ -42,6 +42,9 @@ typedef enum pragma_kind {
   PRAGMA_OMP_SECTIONS,
   PRAGMA_OMP_SINGLE,
   PRAGMA_OMP_THREADPRIVATE,
+  PRAGMA_OMP_TASK,
+  PRAGMA_OMP_TASKWAIT,
+  PRAGMA_OMP_TASKGROUP,
 
   PRAGMA_GCC_PCH_PREPROCESS,
 
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-tree.h gcc-4.2.2/gcc/c-tree.h
--- gcc-4.2.2.orig/gcc/c-tree.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-tree.h	2007-10-31 14:57:20.000000000 +0100
@@ -587,6 +587,8 @@ extern void c_end_vm_scope (unsigned int
 extern tree c_expr_to_decl (tree, bool *, bool *, bool *);
 extern tree c_begin_omp_parallel (void);
 extern tree c_finish_omp_parallel (tree, tree);
+extern tree c_begin_omp_task (void);
+extern tree c_finish_omp_task (tree, tree);
 extern tree c_finish_omp_clauses (tree);
 
 /* Set to 0 at beginning of a function definition, set to 1 if
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/c-typeck.c gcc-4.2.2/gcc/c-typeck.c
--- gcc-4.2.2.orig/gcc/c-typeck.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/c-typeck.c	2007-10-31 17:45:57.000000000 +0100
@@ -8582,6 +8582,32 @@ c_finish_omp_parallel (tree clauses, tre
   return add_stmt (stmt);
 }
 
+tree
+c_begin_omp_task (void)
+{
+  tree block;
+
+  keep_next_level ();
+  block = c_begin_compound_stmt (true);
+
+  return block;
+}
+
+tree
+c_finish_omp_task (tree clauses, tree block)
+{
+  tree stmt;
+
+  block = c_end_compound_stmt (block, true);
+
+  stmt = make_node (OMP_TASK);
+  TREE_TYPE (stmt) = void_type_node;
+  OMP_TASK_CLAUSES (stmt) = clauses;
+  OMP_TASK_BODY (stmt) = block;
+
+  return add_stmt (stmt);
+}
+
 /* For all elements of CLAUSES, validate them vs OpenMP constraints.
    Remove any elements from the list that are invalid.  */
 
@@ -8776,6 +8802,9 @@ c_finish_omp_clauses (tree clauses)
 		case OMP_CLAUSE_DEFAULT_PRIVATE:
 		  share_name = "private";
 		  break;
+		case OMP_CLAUSE_DEFAULT_CAPTUREPRIVATE:
+		  share_name = "captureprivate";
+		  break;
 		default:
 		  gcc_unreachable ();
 		}
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/gimple-low.c gcc-4.2.2/gcc/gimple-low.c
--- gcc-4.2.2.orig/gcc/gimple-low.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/gimple-low.c	2007-10-31 17:47:04.000000000 +0100
@@ -274,6 +274,7 @@ lower_stmt (tree_stmt_iterator *tsi, str
       }
       break;
 
+    case OMP_TASK:
     case OMP_PARALLEL:
       lower_omp_directive (tsi, data);
       return;
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/gimplify.c gcc-4.2.2/gcc/gimplify.c
--- gcc-4.2.2.orig/gcc/gimplify.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/gimplify.c	2007-10-31 15:26:15.000000000 +0100
@@ -271,6 +271,7 @@ new_omp_context (bool is_parallel, bool 
   c->location = input_location;
   c->is_parallel = is_parallel;
   c->is_combined_parallel = is_combined_parallel;
+  /* TODO: use DEFAULT_CAPTUREPRIVATE for tasks */
   c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;
 
   return c;
@@ -4685,6 +4686,8 @@ gimplify_scan_omp_clauses (tree *list_p,
 
       switch (OMP_CLAUSE_CODE (c))
 	{
+	case OMP_CLAUSE_CAPTUREPRIVATE:
+		/* TODO: implement */
 	case OMP_CLAUSE_PRIVATE:
 	  flags = GOVD_PRIVATE | GOVD_EXPLICIT;
 	  notice_outer = false;
@@ -4948,6 +4951,28 @@ gimplify_omp_parallel (tree *expr_p, tre
   return GS_ALL_DONE;
 }
 
+static enum gimplify_status
+gimplify_omp_task (tree *expr_p, tree *pre_p)
+{
+  tree expr = *expr_p;
+
+  gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p, true,
+			     0);
+
+  push_gimplify_context ();
+
+  gimplify_stmt (&OMP_TASK_BODY (expr));
+
+  if (TREE_CODE (OMP_TASK_BODY (expr)) == BIND_EXPR)
+    pop_gimplify_context (OMP_TASK_BODY (expr));
+  else
+    pop_gimplify_context (NULL_TREE);
+
+  gimplify_adjust_omp_clauses (&OMP_TASK_CLAUSES (expr));
+
+  return GS_ALL_DONE;
+}
+
 /* Gimplify the gross structure of an OMP_FOR statement.  */
 
 static enum gimplify_status
@@ -5804,6 +5829,10 @@ gimplify_expr (tree *expr_p, tree *pre_p
 	  ret = gimplify_omp_parallel (expr_p, pre_p);
 	  break;
 
+	case OMP_TASK:
+	  ret = gimplify_omp_task (expr_p, pre_p);
+	  break;
+
 	case OMP_FOR:
 	  ret = gimplify_omp_for (expr_p, pre_p);
 	  break;
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/omp-builtins.def gcc-4.2.2/gcc/omp-builtins.def
--- gcc-4.2.2.orig/gcc/omp-builtins.def	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/omp-builtins.def	2007-11-07 15:43:43.000000000 +0100
@@ -131,6 +131,12 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL
 		  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_END, "GOMP_parallel_end",
 		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK_START, "GOMP_task_start",
+		  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)
+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK_END, "GOMP_task_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT, "GOMP_taskwait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, "GOMP_sections_start",
 		  BT_FN_UINT_UINT, ATTR_NOTHROW_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_NEXT, "GOMP_sections_next",
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/omp-low.c gcc-4.2.2/gcc/omp-low.c
--- gcc-4.2.2.orig/gcc/omp-low.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/omp-low.c	2007-11-07 15:22:28.000000000 +0100
@@ -126,6 +126,14 @@ find_omp_clause (tree clauses, enum tree
   return NULL_TREE;
 }
 
+/* Return true if CTX is for an omp task.  */
+
+static inline bool
+is_task_ctx (omp_context *ctx)
+{
+  return TREE_CODE (ctx->stmt) == OMP_TASK;
+}
+
 /* Return true if CTX is for an omp parallel.  */
 
 static inline bool
@@ -935,14 +943,18 @@ scan_sharing_clauses (tree clauses, omp_
 
       switch (OMP_CLAUSE_CODE (c))
 	{
+	case OMP_CLAUSE_CAPTUREPRIVATE:
+	  /* TODO: implement correct behaviour instead of just copying
+	     the PRIVATE clause.  */
 	case OMP_CLAUSE_PRIVATE:
 	  decl = OMP_CLAUSE_DECL (c);
 	  if (!is_variable_sized (decl))
 	    install_var_local (decl, ctx);
 	  break;
 
+
 	case OMP_CLAUSE_SHARED:
-	  gcc_assert (is_parallel_ctx (ctx));
+	  gcc_assert (is_parallel_ctx (ctx) || is_task_ctx (ctx));
 	  decl = OMP_CLAUSE_DECL (c);
 	  gcc_assert (!is_variable_sized (decl));
 	  by_ref = use_pointer_for_field (decl, true);
@@ -960,7 +972,8 @@ scan_sharing_clauses (tree clauses, omp_
 	      break;
 	    }
 	  /* We don't need to copy const scalar vars back.  */
-	  OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_FIRSTPRIVATE);
+	  if (is_parallel_ctx (ctx))
+	    OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_FIRSTPRIVATE);
 	  goto do_private;
 
 	case OMP_CLAUSE_LASTPRIVATE:
@@ -1028,6 +1041,9 @@ scan_sharing_clauses (tree clauses, omp_
 	    break;
 	  /* FALLTHRU */
 
+	case OMP_CLAUSE_CAPTUREPRIVATE:
+	  /* TODO: implement correct behaviour instead of just copying
+	     the PRIVATE clause.  */
 	case OMP_CLAUSE_PRIVATE:
 	case OMP_CLAUSE_FIRSTPRIVATE:
 	case OMP_CLAUSE_REDUCTION:
@@ -1145,6 +1161,46 @@ create_omp_child_function (omp_context *
 }
 
 
+/* Scan an OpenMP task directive.  */
+
+static void
+scan_omp_task (tree *stmt_p, omp_context *outer_ctx)
+{
+  omp_context *ctx;
+  tree name;
+
+  /* Ignore task directives with empty bodies, unless there
+     are copyin clauses.  */
+  if (optimize > 0
+      && empty_body_p (OMP_PARALLEL_BODY (*stmt_p)))
+    {
+      *stmt_p = build_empty_stmt ();
+      return;
+    }
+
+  ctx = new_omp_context (*stmt_p, outer_ctx);
+  ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);
+  ctx->default_kind = OMP_CLAUSE_DEFAULT_CAPTUREPRIVATE;
+  ctx->record_type = lang_hooks.types.make_type (RECORD_TYPE);
+  name = create_tmp_var_name (".omp_data_s");
+  name = build_decl (TYPE_DECL, name, ctx->record_type);
+  TYPE_NAME (ctx->record_type) = name;
+  create_omp_child_function (ctx);
+  OMP_TASK_FN (*stmt_p) = ctx->cb.dst_fn;
+
+  scan_sharing_clauses (OMP_TASK_CLAUSES (*stmt_p), ctx);
+  scan_omp (&OMP_TASK_BODY (*stmt_p), ctx);
+
+  if (TYPE_FIELDS (ctx->record_type) == NULL)
+    ctx->record_type = ctx->receiver_decl = NULL;
+  else
+    {
+      layout_type (ctx->record_type);
+      fixup_child_record_type (ctx);
+    }
+}
+
+
 /* Scan an OpenMP parallel directive.  */
 
 static void
@@ -1345,6 +1401,10 @@ scan_omp_1 (tree *tp, int *walk_subtrees
   *walk_subtrees = 0;
   switch (TREE_CODE (t))
     {
+    case OMP_TASK:
+      scan_omp_task (tp, ctx);
+      break;
+
     case OMP_PARALLEL:
       parallel_nesting_level++;
       scan_omp_parallel (tp, ctx);
@@ -1760,6 +1820,8 @@ lower_rec_input_clauses (tree clauses, t
 		break;
 	      /* FALLTHRU */
 
+	    case OMP_CLAUSE_CAPTUREPRIVATE:
+	      /* TODO: implement.  */
 	    case OMP_CLAUSE_PRIVATE:
 	      x = lang_hooks.decls.omp_clause_default_ctor (c, new_var);
 	      if (x)
@@ -2101,7 +2163,8 @@ lower_send_clauses (tree clauses, tree *
 
 /* Generate code to implement SHARED from the sender (aka parent) side.
    This is trickier, since OMP_PARALLEL_CLAUSES doesn't list things that
-   got automatically shared.  */
+   got automatically shared.
+   Also used for CAPTUREPRIVATE task variables.  */
 
 static void
 lower_send_shared_vars (tree *ilist, tree *olist, omp_context *ctx)
@@ -2146,6 +2209,62 @@ lower_send_shared_vars (tree *ilist, tre
     }
 }
 
+/* Build the function calls to GOMP_task_start etc to actually 
+   generate the task operation.  REGION is the task region
+   being expanded.  BB is the block where to insert the code.  WS_ARGS
+   will be set if this is a call to a combined task+workshare
+   construct, it contains the list of additional arguments needed by
+   the workshare construct.  */
+
+static void
+expand_task_call (struct omp_region *region, basic_block bb,
+		      tree entry_stmt)
+{
+  tree t, args, list, clauses;
+  block_stmt_iterator si;
+  int start_ix;
+
+  clauses = OMP_TASK_CLAUSES (entry_stmt);
+  push_gimplify_context ();
+
+  /* Determine what flavor of GOMP_task_start we will be
+     emitting.  */
+  start_ix = BUILT_IN_GOMP_TASK_START;
+
+  list = NULL_TREE;
+  t = OMP_TASK_DATA_ARG (entry_stmt);
+  if (t == NULL)
+    t = null_pointer_node;
+  else
+    t = build_fold_addr_expr (t);
+  args = tree_cons (NULL, t, NULL);
+  t = build_fold_addr_expr (OMP_TASK_FN (entry_stmt));
+  args = tree_cons (NULL, t, args);
+
+  t = built_in_decls[start_ix];
+  t = build_function_call_expr (t, args);
+  gimplify_and_add (t, &list);
+
+  t = OMP_TASK_DATA_ARG (entry_stmt);
+  if (t == NULL)
+    t = null_pointer_node;
+  else
+    t = build_fold_addr_expr (t);
+  args = tree_cons (NULL, t, NULL);
+  t = build_function_call_expr (OMP_TASK_FN (entry_stmt), args);
+  gimplify_and_add (t, &list);
+
+  t = built_in_decls[BUILT_IN_GOMP_TASK_END];
+  t = build_function_call_expr (t, NULL);
+  gimplify_and_add (t, &list);
+
+  si = bsi_last (bb);
+  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);
+
+  pop_gimplify_context (NULL_TREE);
+}
+
+
 /* Build the function calls to GOMP_parallel_start etc to actually 
    generate the parallel operation.  REGION is the parallel region
    being expanded.  BB is the block where to insert the code.  WS_ARGS
@@ -2412,6 +2531,150 @@ remove_exit_barriers (struct omp_region 
     }
 }
 
+/* Expand the OpenMP task directive starting at REGION.  */
+
+static void
+expand_omp_task (struct omp_region *region)
+{
+  basic_block entry_bb, exit_bb, new_bb;
+  struct function *child_cfun, *saved_cfun;
+  tree child_fn, block, t;
+  block_stmt_iterator si;
+  tree entry_stmt;
+  edge e;
+  bool do_cleanup_cfg = false;
+
+  entry_stmt = last_stmt (region->entry);
+  child_fn = OMP_TASK_FN (entry_stmt);
+  child_cfun = DECL_STRUCT_FUNCTION (child_fn);
+  saved_cfun = cfun;
+
+  entry_bb = region->entry;
+  exit_bb = region->exit;
+
+  if (child_cfun->cfg)
+    {
+      /* Due to inlining, it may happen that we have already outlined
+	 the region, in which case all we need to do is make the
+	 sub-graph unreachable and emit the task call.  */
+      edge entry_succ_e, exit_succ_e;
+      block_stmt_iterator si;
+
+      entry_succ_e = single_succ_edge (entry_bb);
+
+      si = bsi_last (entry_bb);
+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_TASK);
+      bsi_remove (&si, true);
+
+      new_bb = entry_bb;
+      remove_edge (entry_succ_e);
+      if (exit_bb)
+	{
+	  exit_succ_e = single_succ_edge (exit_bb);
+	  make_edge (new_bb, exit_succ_e->dest, EDGE_FALLTHRU);
+	}
+      do_cleanup_cfg = true;
+    }
+  else
+    {
+      /* If the task region needs data sent from the parent
+	 function, then the very first statement (except possible
+	 tree profile counter updates) of the task body
+	 is a copy assignment .OMP_DATA_I = &.OMP_DATA_O.  Since
+	 &.OMP_DATA_O is passed as an argument to the child function,
+	 we need to replace it with the argument as seen by the child
+	 function.
+
+	 In most cases, this will end up being the identity assignment
+	 .OMP_DATA_I = .OMP_DATA_I.  However, if the task body had
+	 a function call that has been inlined, the original PARM_DECL
+	 .OMP_DATA_I may have been converted into a different local
+	 variable.  In which case, we need to keep the assignment.  */
+      if (OMP_TASK_DATA_ARG (entry_stmt))
+	{
+	  basic_block entry_succ_bb = single_succ (entry_bb);
+	  block_stmt_iterator si;
+
+	  for (si = bsi_start (entry_succ_bb); ; bsi_next (&si))
+	    {
+	      tree stmt, arg;
+
+	      gcc_assert (!bsi_end_p (si));
+	      stmt = bsi_stmt (si);
+	      if (TREE_CODE (stmt) != MODIFY_EXPR)
+		continue;
+
+	      arg = TREE_OPERAND (stmt, 1);
+	      STRIP_NOPS (arg);
+	      if (TREE_CODE (arg) == ADDR_EXPR
+		  && TREE_OPERAND (arg, 0)
+		     == OMP_TASK_DATA_ARG (entry_stmt))
+		{
+		  if (TREE_OPERAND (stmt, 0) == DECL_ARGUMENTS (child_fn))
+		    bsi_remove (&si, true);
+		  else
+		    TREE_OPERAND (stmt, 1) = DECL_ARGUMENTS (child_fn);
+		  break;
+		}
+	    }
+	}
+
+      /* Declare local variables needed in CHILD_CFUN.  */
+      block = DECL_INITIAL (child_fn);
+      BLOCK_VARS (block) = list2chain (child_cfun->unexpanded_var_list);
+      DECL_SAVED_TREE (child_fn) = single_succ (entry_bb)->stmt_list;
+
+      /* Reset DECL_CONTEXT on locals and function arguments.  */
+      for (t = BLOCK_VARS (block); t; t = TREE_CHAIN (t))
+	DECL_CONTEXT (t) = child_fn;
+
+      for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))
+	DECL_CONTEXT (t) = child_fn;
+
+      /* Split ENTRY_BB at OMP_TASK so that it can be moved to the
+	 child function.  */
+      si = bsi_last (entry_bb);
+      t = bsi_stmt (si);
+      gcc_assert (t && TREE_CODE (t) == OMP_TASK);
+      bsi_remove (&si, true);
+      e = split_block (entry_bb, t);
+      entry_bb = e->dest;
+      single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;
+
+      /* Move the task region into CHILD_CFUN.  We need to reset
+	 dominance information because the expansion of the inner
+	 regions has invalidated it.  */
+      free_dominance_info (CDI_DOMINATORS);
+      new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb);
+      if (exit_bb)
+	single_succ_edge (new_bb)->flags = EDGE_FALLTHRU;
+      cgraph_add_new_function (child_fn);
+
+      /* Convert OMP_RETURN into a RETURN_EXPR.  */
+      if (exit_bb)
+	{
+	  si = bsi_last (exit_bb);
+	  gcc_assert (!bsi_end_p (si)
+		      && TREE_CODE (bsi_stmt (si)) == OMP_RETURN);
+	  t = build1 (RETURN_EXPR, void_type_node, NULL);
+	  bsi_insert_after (&si, t, BSI_SAME_STMT);
+	  bsi_remove (&si, true);
+	}
+    }
+
+  /* Emit a library call to launch the children threads.  */
+  expand_task_call (region, new_bb, entry_stmt);
+
+  if (do_cleanup_cfg)
+    {
+      /* Clean up the unreachable sub-graph we created above.  */
+      free_dominance_info (CDI_DOMINATORS);
+      free_dominance_info (CDI_POST_DOMINATORS);
+      cleanup_tree_cfg ();
+    }
+}
+
+
 /* Expand the OpenMP parallel directive starting at REGION.  */
 
 static void
@@ -3426,6 +3689,10 @@ expand_omp (struct omp_region *region)
 
       switch (region->type)
 	{
+	case OMP_TASK:
+	  expand_omp_task (region);
+	  break;
+
 	case OMP_PARALLEL:
 	  expand_omp_parallel (region);
 	  break;
@@ -4144,6 +4411,80 @@ check_combined_parallel (tree *tp, int *
   return NULL;
 }
 
+/* Lower the OpenMP task directive in *STMT_P.  CTX holds context
+   information for the directive.  */
+
+static void
+lower_omp_task (tree *stmt_p, omp_context *ctx)
+{
+  tree clauses, par_bind, par_body, new_body, bind;
+  tree olist, ilist, par_olist, par_ilist;
+  tree stmt, child_fn, t;
+
+  stmt = *stmt_p;
+
+  clauses = OMP_TASK_CLAUSES (stmt);
+  par_bind = OMP_TASK_BODY (stmt);
+  par_body = BIND_EXPR_BODY (par_bind);
+  child_fn = ctx->cb.dst_fn;
+
+  push_gimplify_context ();
+
+  par_olist = NULL_TREE;
+  par_ilist = NULL_TREE;
+  lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx);
+  lower_omp (&par_body, ctx);
+  lower_reduction_clauses (clauses, &par_olist, ctx);
+
+  /* Declare all the variables created by mapping and the variables
+     declared in the scope of the task body.  */
+  record_vars_into (ctx->block_vars, child_fn);
+  record_vars_into (BIND_EXPR_VARS (par_bind), child_fn);
+
+  if (ctx->record_type)
+    {
+      ctx->sender_decl = create_tmp_var (ctx->record_type, ".omp_data_o");
+      OMP_TASK_DATA_ARG (stmt) = ctx->sender_decl;
+    }
+
+  olist = NULL_TREE;
+  ilist = NULL_TREE;
+  lower_send_clauses (clauses, &ilist, &olist, ctx);
+  lower_send_shared_vars (&ilist, &olist, ctx);
+
+  /* Once all the expansions are done, sequence all the different
+     fragments inside OMP_TASK_BODY.  */
+  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);
+  append_to_statement_list (ilist, &BIND_EXPR_BODY (bind));
+
+  new_body = alloc_stmt_list ();
+
+  if (ctx->record_type)
+    {
+      t = build_fold_addr_expr (ctx->sender_decl);
+      /* fixup_child_record_type might have changed receiver_decl's type.  */
+      t = fold_convert (TREE_TYPE (ctx->receiver_decl), t);
+      t = build2 (MODIFY_EXPR, void_type_node, ctx->receiver_decl, t);
+      append_to_statement_list (t, &new_body);
+    }
+
+  append_to_statement_list (par_ilist, &new_body);
+  append_to_statement_list (par_body, &new_body);
+  append_to_statement_list (par_olist, &new_body);
+  maybe_catch_exception (&new_body);
+  t = make_node (OMP_RETURN);
+  append_to_statement_list (t, &new_body);
+  OMP_TASK_BODY (stmt) = new_body;
+
+  append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));
+  append_to_statement_list (olist, &BIND_EXPR_BODY (bind));
+
+  *stmt_p = bind;
+
+  pop_gimplify_context (NULL_TREE);
+}
+
+
 /* Lower the OpenMP parallel directive in *STMT_P.  CTX holds context
    information for the directive.  */
 
@@ -4314,6 +4655,11 @@ lower_omp_1 (tree *tp, int *walk_subtree
       lower_omp_parallel (tp, ctx);
       break;
 
+    case OMP_TASK:
+      ctx = maybe_lookup_ctx (t);
+      lower_omp_task (tp, ctx);
+      break;
+
     case OMP_FOR:
       ctx = maybe_lookup_ctx (t);
       gcc_assert (ctx);
@@ -4516,6 +4862,7 @@ diagnose_sb_1 (tree *tp, int *walk_subtr
   switch (TREE_CODE (t))
     {
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_SECTIONS:
     case OMP_SINGLE:
       walk_tree (&OMP_CLAUSES (t), diagnose_sb_1, wi, NULL);
@@ -4570,6 +4917,7 @@ diagnose_sb_2 (tree *tp, int *walk_subtr
   switch (TREE_CODE (t))
     {
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_SECTIONS:
     case OMP_SINGLE:
       walk_tree (&OMP_CLAUSES (t), diagnose_sb_2, wi, NULL);
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree-cfg.c gcc-4.2.2/gcc/tree-cfg.c
--- gcc-4.2.2.orig/gcc/tree-cfg.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-cfg.c	2007-10-31 12:15:39.000000000 +0100
@@ -524,6 +524,7 @@ make_edges (void)
 	      break;
 
 	    case OMP_PARALLEL:
+	    case OMP_TASK:
 	    case OMP_FOR:
 	    case OMP_SINGLE:
 	    case OMP_MASTER:
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree.def gcc-4.2.2/gcc/tree.def
--- gcc-4.2.2.orig/gcc/tree.def	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree.def	2007-10-31 12:02:18.000000000 +0100
@@ -965,6 +965,7 @@ DEFTREECODE (TARGET_MEM_REF, "target_mem
 	      function.  */
 
 DEFTREECODE (OMP_PARALLEL, "omp_parallel", tcc_statement, 4)
+DEFTREECODE (OMP_TASK, "omp_task", tcc_statement, 4)
 
 /* OpenMP - #pragma omp for [clause1 ... clauseN]
    Operand 0: OMP_FOR_BODY: Loop body.
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree-gimple.c gcc-4.2.2/gcc/tree-gimple.c
--- gcc-4.2.2.orig/gcc/tree-gimple.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-gimple.c	2007-10-31 12:09:28.000000000 +0100
@@ -219,6 +219,7 @@ is_gimple_stmt (tree t)
     case PHI_NODE:
     case STATEMENT_LIST:
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_FOR:
     case OMP_SECTIONS:
     case OMP_SECTION:
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree.h gcc-4.2.2/gcc/tree.h
--- gcc-4.2.2.orig/gcc/tree.h	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree.h	2007-10-31 16:20:37.000000000 +0100
@@ -170,6 +170,7 @@ extern const enum tree_code_class tree_c
 
 #define OMP_DIRECTIVE_P(NODE)				\
     (TREE_CODE (NODE) == OMP_PARALLEL			\
+     || TREE_CODE (NODE) == OMP_TASK			\
      || TREE_CODE (NODE) == OMP_FOR			\
      || TREE_CODE (NODE) == OMP_SECTIONS		\
      || TREE_CODE (NODE) == OMP_SINGLE			\
@@ -277,9 +278,15 @@ enum omp_clause_code
      (c_parser_omp_variable_list).  */
   OMP_CLAUSE_ERROR = 0,
 
+  /* OpenMP clause: switch.  */
+  OMP_CLAUSE_SWITCH,
+
   /* OpenMP clause: private (variable_list).  */
   OMP_CLAUSE_PRIVATE,
 
+  /* OpenMP clause: captureprivate (variable_list).  */
+  OMP_CLAUSE_CAPTUREPRIVATE,
+
   /* OpenMP clause: shared (variable_list).  */
   OMP_CLAUSE_SHARED,
 
@@ -1558,6 +1565,11 @@ struct tree_constructor GTY(())
 #define OMP_PARALLEL_FN(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 2)
 #define OMP_PARALLEL_DATA_ARG(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 3)
 
+#define OMP_TASK_BODY(NODE)    TREE_OPERAND (OMP_TASK_CHECK (NODE), 0)
+#define OMP_TASK_CLAUSES(NODE) TREE_OPERAND (OMP_TASK_CHECK (NODE), 1)
+#define OMP_TASK_FN(NODE) TREE_OPERAND (OMP_TASK_CHECK (NODE), 2)
+#define OMP_TASK_DATA_ARG(NODE) TREE_OPERAND (OMP_TASK_CHECK (NODE), 3)
+
 #define OMP_FOR_BODY(NODE)	   TREE_OPERAND (OMP_FOR_CHECK (NODE), 0)
 #define OMP_FOR_CLAUSES(NODE)	   TREE_OPERAND (OMP_FOR_CHECK (NODE), 1)
 #define OMP_FOR_INIT(NODE)	   TREE_OPERAND (OMP_FOR_CHECK (NODE), 2)
@@ -1646,7 +1658,8 @@ enum omp_clause_default_kind
   OMP_CLAUSE_DEFAULT_UNSPECIFIED,
   OMP_CLAUSE_DEFAULT_SHARED,
   OMP_CLAUSE_DEFAULT_NONE,
-  OMP_CLAUSE_DEFAULT_PRIVATE
+  OMP_CLAUSE_DEFAULT_PRIVATE,
+  OMP_CLAUSE_DEFAULT_CAPTUREPRIVATE
 };
 
 #define OMP_CLAUSE_DEFAULT_KIND(NODE) \
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree-inline.c gcc-4.2.2/gcc/tree-inline.c
--- gcc-4.2.2.orig/gcc/tree-inline.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-inline.c	2007-10-31 12:15:23.000000000 +0100
@@ -1822,6 +1822,7 @@ estimate_num_insns_1 (tree *tp, int *wal
       }
 
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_FOR:
     case OMP_SECTIONS:
     case OMP_SINGLE:
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree-nested.c gcc-4.2.2/gcc/tree-nested.c
--- gcc-4.2.2.orig/gcc/tree-nested.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-nested.c	2007-10-31 18:24:55.000000000 +0100
@@ -1078,6 +1078,31 @@ convert_nonlocal_reference (tree *tp, in
       walk_tree (tp, convert_nonlocal_reference, wi, NULL);
       break;
 
+    case OMP_TASK:
+      /* TODO: check if CLAUSE_PRIVATE is the right conversion target
+       * clause here	*/
+      save_suppress = info->suppress_expansion;
+      if (convert_nonlocal_omp_clauses (&OMP_TASK_CLAUSES (t), wi))
+	{
+	  tree c, decl;
+	  decl = get_chain_decl (info);
+	  c = build_omp_clause (OMP_CLAUSE_PRIVATE);
+	  OMP_CLAUSE_DECL (c) = decl;
+	  OMP_CLAUSE_CHAIN (c) = OMP_TASK_CLAUSES (t);
+	  OMP_TASK_CLAUSES (t) = c;
+	}
+
+      save_local_var_chain = info->new_local_var_chain;
+      info->new_local_var_chain = NULL;
+
+      walk_body (convert_nonlocal_reference, info, &OMP_TASK_BODY (t));
+
+      if (info->new_local_var_chain)
+	declare_vars (info->new_local_var_chain, OMP_TASK_BODY (t), false);
+      info->new_local_var_chain = save_local_var_chain;
+      info->suppress_expansion = save_suppress;
+      break;
+
     case OMP_PARALLEL:
       save_suppress = info->suppress_expansion;
       if (convert_nonlocal_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))
@@ -1364,6 +1389,31 @@ convert_local_reference (tree *tp, int *
       wi->val_only = save_val_only;
       break;
 
+    case OMP_TASK:
+      /* TODO: check if CLAUSE_SHARED is the right conversion target
+       * clause here	*/
+      save_suppress = info->suppress_expansion;
+      if (convert_local_omp_clauses (&OMP_TASK_CLAUSES (t), wi))
+	{
+	  tree c;
+	  (void) get_frame_type (info);
+	  c = build_omp_clause (OMP_CLAUSE_SHARED);
+	  OMP_CLAUSE_DECL (c) = info->frame_decl;
+	  OMP_CLAUSE_CHAIN (c) = OMP_TASK_CLAUSES (t);
+	  OMP_TASK_CLAUSES (t) = c;
+	}
+
+      save_local_var_chain = info->new_local_var_chain;
+      info->new_local_var_chain = NULL;
+
+      walk_body (convert_local_reference, info, &OMP_TASK_BODY (t));
+
+      if (info->new_local_var_chain)
+	declare_vars (info->new_local_var_chain, OMP_TASK_BODY (t), false);
+      info->new_local_var_chain = save_local_var_chain;
+      info->suppress_expansion = save_suppress;
+      break;
+
     case OMP_PARALLEL:
       save_suppress = info->suppress_expansion;
       if (convert_local_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))
@@ -1698,6 +1748,35 @@ convert_call_expr (tree *tp, int *walk_s
       *walk_subtrees = 1;
       break;
 
+    case OMP_TASK:
+      /* TODO: check if CLAUSE_PRIVATE is the right conversion target
+       * clause here	*/
+      save_static_chain_added = info->static_chain_added;
+      info->static_chain_added = 0;
+      walk_body (convert_call_expr, info, &OMP_TASK_BODY (t));
+      for (i = 0; i < 2; i++)
+	{
+	  tree c, decl;
+	  if ((info->static_chain_added & (1 << i)) == 0)
+	    continue;
+	  decl = i ? get_chain_decl (info) : info->frame_decl;
+	  /* Don't add CHAIN.* or FRAME.* twice.  */
+	  for (c = OMP_TASK_CLAUSES (t); c; c = OMP_CLAUSE_CHAIN (c))
+	    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
+		 || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED)
+		&& OMP_CLAUSE_DECL (c) == decl)
+	      break;
+	  if (c == NULL)
+	    {
+	      c = build_omp_clause (OMP_CLAUSE_PRIVATE);
+	      OMP_CLAUSE_DECL (c) = decl;
+	      OMP_CLAUSE_CHAIN (c) = OMP_TASK_CLAUSES (t);
+	      OMP_TASK_CLAUSES (t) = c;
+	    }
+	}
+      info->static_chain_added |= save_static_chain_added;
+      break;
+
     case OMP_PARALLEL:
       save_static_chain_added = info->static_chain_added;
       info->static_chain_added = 0;
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/gcc/tree-ssa-operands.c gcc-4.2.2/gcc/tree-ssa-operands.c
--- gcc-4.2.2.orig/gcc/tree-ssa-operands.c	2007-09-01 17:28:30.000000000 +0200
+++ gcc-4.2.2/gcc/tree-ssa-operands.c	2007-10-31 12:16:15.000000000 +0100
@@ -2063,6 +2063,7 @@ get_expr_operands (tree stmt, tree *expr
     case LABEL_DECL:
     case CONST_DECL:
     case OMP_PARALLEL:
+    case OMP_TASK:
     case OMP_SECTIONS:
     case OMP_FOR:
     case OMP_SINGLE:
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/bar.c gcc-4.2.2/libgomp/config/marcel/bar.c
--- gcc-4.2.2.orig/libgomp/config/marcel/bar.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/bar.c	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1 @@
+/* Everything is in the header.  */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/bar.h gcc-4.2.2/libgomp/config/marcel/bar.h
--- gcc-4.2.2.orig/libgomp/config/marcel/bar.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/bar.h	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1,76 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This is the default implementation of a barrier synchronization mechanism
+   for libgomp.  This type is private to the library.  Note that we rely on
+   being able to adjust the barrier count while threads are blocked, so the
+   POSIX pthread_barrier_t won't work.  */
+
+#ifndef GOMP_BARRIER_H
+#define GOMP_BARRIER_H 1
+
+#include "marcel.h"
+
+typedef marcel_barrier_t gomp_barrier_t;
+
+static inline void
+gomp_barrier_init (marcel_barrier_t * bar, unsigned count)
+{
+  marcel_barrier_init (bar, NULL, count);
+}
+
+static inline void
+gomp_barrier_reinit (marcel_barrier_t * bar, unsigned count)
+{
+  marcel_barrier_setcount (bar, count);
+}
+
+static inline void
+gomp_barrier_destroy (marcel_barrier_t * bar)
+{
+  marcel_barrier_destroy (bar);
+}
+
+static inline void
+gomp_barrier_wait (marcel_barrier_t * bar)
+{
+  marcel_barrier_wait (bar);
+}
+
+static inline bool
+gomp_barrier_wait_start (marcel_barrier_t * bar)
+{
+  return marcel_barrier_wait_begin (bar) == 0;
+}
+
+static inline void
+gomp_barrier_wait_end (marcel_barrier_t * bar, bool last)
+{
+  marcel_barrier_wait_end (bar);
+}
+
+#endif /* GOMP_BARRIER_H */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/lock.c gcc-4.2.2/libgomp/config/marcel/lock.c
--- gcc-4.2.2.orig/libgomp/config/marcel/lock.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/lock.c	2007-11-12 09:05:07.000000000 +0100
@@ -0,0 +1,113 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This is the default PTHREADS implementation of the public OpenMP
+   locking primitives.
+
+   Because OpenMP uses different entry points for normal and recursive
+   locks, and pthreads uses only one entry point, a system may be able
+   to do better and streamline the locking as well as reduce the size
+   of the types exported.  */
+
+#include "libgomp.h"
+
+
+void
+omp_init_lock (omp_lock_t *lock)
+{
+  marcel_mutex_init (lock, NULL);
+}
+
+void
+omp_destroy_lock (omp_lock_t *lock)
+{
+  marcel_mutex_destroy (lock);
+}
+
+void
+omp_set_lock (omp_lock_t *lock)
+{
+  marcel_mutex_lock (lock);
+}
+
+void
+omp_unset_lock (omp_lock_t *lock)
+{
+  marcel_mutex_unlock (lock);
+}
+
+int
+omp_test_lock (omp_lock_t *lock)
+{
+  return marcel_mutex_trylock (lock) == 0;
+}
+
+void
+omp_init_nest_lock (omp_nest_lock_t *lock)
+{
+  pmarcel_mutexattr_t attr;
+
+  pmarcel_mutexattr_init (&attr);
+  pmarcel_mutexattr_settype (&attr, PMARCEL_MUTEX_RECURSIVE);
+  pmarcel_mutex_init (lock, &attr);
+  pmarcel_mutexattr_destroy (&attr);
+}
+
+void
+omp_destroy_nest_lock (omp_nest_lock_t *lock)
+{
+  pmarcel_mutex_destroy (lock);
+}
+
+void
+omp_set_nest_lock (omp_nest_lock_t *lock)
+{
+  pmarcel_mutex_lock (lock);
+}
+
+void
+omp_unset_nest_lock (omp_nest_lock_t *lock)
+{
+  pmarcel_mutex_unlock (lock);
+}
+
+int
+omp_test_nest_lock (omp_nest_lock_t *lock)
+{
+  return pmarcel_mutex_trylock (lock);
+}
+
+ialias (omp_init_lock)
+ialias (omp_init_nest_lock)
+ialias (omp_destroy_lock)
+ialias (omp_destroy_nest_lock)
+ialias (omp_set_lock)
+ialias (omp_set_nest_lock)
+ialias (omp_unset_lock)
+ialias (omp_unset_nest_lock)
+ialias (omp_test_lock)
+ialias (omp_test_nest_lock)
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/mutex.c gcc-4.2.2/libgomp/config/marcel/mutex.c
--- gcc-4.2.2.orig/libgomp/config/marcel/mutex.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/mutex.c	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1 @@
+/* Everything is in the header.  */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/mutex.h gcc-4.2.2/libgomp/config/marcel/mutex.h
--- gcc-4.2.2.orig/libgomp/config/marcel/mutex.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/mutex.h	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1,60 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This is the default PTHREADS implementation of a mutex synchronization
+   mechanism for libgomp.  This type is private to the library.  */
+
+#ifndef GOMP_MUTEX_H
+#define GOMP_MUTEX_H 1
+
+#include "marcel.h"
+
+typedef marcel_mutex_t gomp_mutex_t;
+
+#define GOMP_MUTEX_INIT_0 0
+
+static inline void gomp_mutex_init (gomp_mutex_t *mutex)
+{
+  marcel_mutex_init (mutex, NULL);
+}
+
+static inline void gomp_mutex_lock (gomp_mutex_t *mutex)
+{
+  marcel_mutex_lock (mutex);
+}
+
+static inline void gomp_mutex_unlock (gomp_mutex_t *mutex)
+{
+  marcel_mutex_unlock (mutex);
+}
+
+static inline void gomp_mutex_destroy (gomp_mutex_t *mutex)
+{
+  marcel_mutex_destroy (mutex);
+}
+
+#endif /* GOMP_MUTEX_H */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/omp-lock.h gcc-4.2.2/libgomp/config/marcel/omp-lock.h
--- gcc-4.2.2.orig/libgomp/config/marcel/omp-lock.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/omp-lock.h	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1,11 @@
+/* This header is used during the build process to find the size and 
+   alignment of the public OpenMP locks, so that we can export data
+   structures without polluting the namespace.
+
+   In this default POSIX implementation, we map the two locks to the
+   same PTHREADS primitive.  */
+
+#include "marcel.h"
+
+typedef marcel_mutex_t omp_lock_t;
+typedef pmarcel_mutex_t omp_nest_lock_t;
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/proc.c gcc-4.2.2/libgomp/config/marcel/proc.c
--- gcc-4.2.2.orig/libgomp/config/marcel/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/proc.c	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1,103 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This file contains system specific routines related to counting
+   online processors and dynamic load balancing.  It is expected that
+   a system may well want to write special versions of each of these.
+
+   The following implementation uses a mix of POSIX and BSD routines.  */
+
+#include "libgomp.h"
+#include <unistd.h>
+#include <stdlib.h>
+#ifdef HAVE_GETLOADAVG
+# ifdef HAVE_SYS_LOADAVG_H
+#  include <sys/loadavg.h>
+# endif
+#endif
+
+
+/* At startup, determine the default number of threads.  It would seem
+   this should be related to the number of cpus online.  */
+
+void
+gomp_init_num_threads (void)
+{
+#ifdef _SC_NPROCESSORS_ONLN
+  gomp_nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);
+#endif
+}
+
+/* When OMP_DYNAMIC is set, at thread launch determine the number of
+   threads we should spawn for this team.  */
+/* ??? I have no idea what best practice for this is.  Surely some
+   function of the number of processors that are *still* online and
+   the load average.  Here I use the number of processors online
+   minus the 15 minute load average.  */
+
+unsigned
+gomp_dynamic_max_threads (void)
+{
+  unsigned n_onln, loadavg;
+
+#ifdef _SC_NPROCESSORS_ONLN
+  n_onln = sysconf (_SC_NPROCESSORS_ONLN);
+  if (n_onln > gomp_nthreads_var)
+    n_onln = gomp_nthreads_var;
+#else
+  n_onln = gomp_nthreads_var;
+#endif
+
+  loadavg = 0;
+#ifdef HAVE_GETLOADAVG
+  {
+    double dloadavg[3];
+    if (getloadavg (dloadavg, 3) == 3)
+      {
+	/* Add 0.1 to get a kind of biased rounding.  */
+	loadavg = dloadavg[2] + 0.1;
+      }
+  }
+#endif
+
+  if (loadavg >= n_onln)
+    return 1;
+  else
+    return n_onln - loadavg;
+}
+
+int
+omp_get_num_procs (void)
+{
+#ifdef _SC_NPROCESSORS_ONLN
+  return sysconf (_SC_NPROCESSORS_ONLN);
+#else
+  return gomp_nthreads_var;
+#endif
+}
+
+ialias (omp_get_num_procs)
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/sem.c gcc-4.2.2/libgomp/config/marcel/sem.c
--- gcc-4.2.2.orig/libgomp/config/marcel/sem.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/sem.c	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1 @@
+/* Everything is in the header.  */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/sem.h gcc-4.2.2/libgomp/config/marcel/sem.h
--- gcc-4.2.2.orig/libgomp/config/marcel/sem.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/sem.h	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1,77 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This is the default POSIX 1003.1b implementation of a semaphore
+   synchronization mechanism for libgomp.  This type is private to
+   the library.
+
+   This is a bit heavy weight for what we need, in that we're not
+   interested in sem_wait as a cancelation point, but it's not too
+   bad for a default.  */
+
+#ifndef GOMP_SEM_H
+#define GOMP_SEM_H 1
+
+#ifdef HAVE_ATTRIBUTE_VISIBILITY
+# pragma GCC visibility push(default)
+#endif
+
+#include <semaphore.h>
+
+#ifdef HAVE_ATTRIBUTE_VISIBILITY
+# pragma GCC visibility pop
+#endif
+
+#include "marcel.h"
+
+typedef marcel_sem_t gomp_sem_t;
+
+static inline void
+gomp_sem_init (marcel_sem_t *sem, int value)
+{
+  marcel_sem_init (sem, value);  
+}
+
+static inline void
+gomp_sem_wait (marcel_sem_t *sem)
+{
+  marcel_sem_P (sem);
+}
+
+static inline void
+gomp_sem_post (marcel_sem_t *sem)
+{
+  marcel_sem_V (sem);
+}
+
+static inline void
+gomp_sem_destroy (marcel_sem_t *sem)
+{
+  marcel_sem_destroy (sem);  
+}
+
+#endif /* GOMP_SEM_H  */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config/marcel/time.c gcc-4.2.2/libgomp/config/marcel/time.c
--- gcc-4.2.2.orig/libgomp/config/marcel/time.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config/marcel/time.c	2007-11-09 16:21:18.000000000 +0100
@@ -0,0 +1,81 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This file contains system specific timer routines.  It is expected that
+   a system may well want to write special versions of each of these.
+
+   The following implementation uses the most simple POSIX routines.
+   If present, POSIX 4 clocks should be used instead.  */
+
+#include "libgomp.h"
+#include <unistd.h>
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+
+double
+omp_get_wtime (void)
+{
+#ifdef HAVE_CLOCK_GETTIME
+  struct timespec ts;
+# ifdef CLOCK_MONOTONIC
+  if (clock_gettime (CLOCK_MONOTONIC, &ts) < 0)
+# endif
+    clock_gettime (CLOCK_REALTIME, &ts);
+  return ts.tv_sec + ts.tv_nsec / 1e9;
+#else
+  struct timeval tv;
+  gettimeofday (&tv, NULL);
+  return tv.tv_sec + tv.tv_usec / 1e6;
+#endif
+}
+
+double
+omp_get_wtick (void)
+{
+#ifdef HAVE_CLOCK_GETTIME
+  struct timespec ts;
+# ifdef CLOCK_MONOTONIC
+  if (clock_getres (CLOCK_MONOTONIC, &ts) < 0)
+# endif
+    clock_getres (CLOCK_REALTIME, &ts);
+  return ts.tv_sec + ts.tv_nsec / 1e9;
+#else
+  return 1.0 / sysconf(_SC_CLK_TCK);
+#endif
+}
+
+ialias (omp_get_wtime)
+ialias (omp_get_wtick)
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/config.h.in.orig gcc-4.2.2/libgomp/config.h.in.orig
--- gcc-4.2.2.orig/libgomp/config.h.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/config.h.in.orig	2007-10-31 17:30:57.000000000 +0100
@@ -0,0 +1,103 @@
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if the target supports __attribute__((alias(...))). */
+#undef HAVE_ATTRIBUTE_ALIAS
+
+/* Define to 1 if the target supports __attribute__((dllexport)). */
+#undef HAVE_ATTRIBUTE_DLLEXPORT
+
+/* Define to 1 if the target supports __attribute__((visibility(...))). */
+#undef HAVE_ATTRIBUTE_VISIBILITY
+
+/* Define if the POSIX Semaphores do not work on your system. */
+#undef HAVE_BROKEN_POSIX_SEMAPHORES
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#undef HAVE_CLOCK_GETTIME
+
+/* Define to 1 if you have the `getloadavg' function. */
+#undef HAVE_GETLOADAVG
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <semaphore.h> header file. */
+#undef HAVE_SEMAPHORE_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if the target supports __sync_*_compare_and_swap */
+#undef HAVE_SYNC_BUILTINS
+
+/* Define to 1 if you have the <sys/loadavg.h> header file. */
+#undef HAVE_SYS_LOADAVG_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if the target supports thread-local storage. */
+#undef HAVE_TLS
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* The size of `char', as computed by sizeof. */
+#undef SIZEOF_CHAR
+
+/* The size of `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* The size of `short', as computed by sizeof. */
+#undef SIZEOF_SHORT
+
+/* The size of `void *', as computed by sizeof. */
+#undef SIZEOF_VOID_P
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#undef TIME_WITH_SYS_TIME
+
+/* Version number of package */
+#undef VERSION
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/configure.ac gcc-4.2.2/libgomp/configure.ac
--- gcc-4.2.2.orig/libgomp/configure.ac	2007-02-06 19:49:55.000000000 +0100
+++ gcc-4.2.2/libgomp/configure.ac	2007-11-09 16:27:08.000000000 +0100
@@ -164,9 +164,114 @@ AC_CHECK_HEADERS(unistd.h semaphore.h sy
 
 GCC_HEADER_STDINT(gstdint.h)
 
+# check whether we use marcel or pthread
+AC_MSG_CHECKING(whether we use marcel threads)
+AC_ARG_ENABLE(marcel, [  --enable-marcel     use marcel threads],
+	      enable_marcel=$enableval, enable_marcel=yes)
+if test "$enable_marcel" = yes; then
+  AC_DEFINE_UNQUOTED(LIBGOMP_USE_MARCEL, 1, [Define to 1 to use Marcel threads instead of Posix])
+fi
+AC_MSG_RESULT($enable_marcel)
+
+if test "$enable_marcel" = yes ; then
+  AC_MSG_CHECKING(whether we place marcel threads in bubbles)
+  AC_ARG_ENABLE(marcel-bubbles, [  --disable-marcel-bubbles     use marcel threads without bubbles],
+		enable_marcel_bubbles=$enableval, enable_marcel_bubbles=yes)
+  if test "$enable_marcel" = yes -a "$enable_marcel_bubbles" = yes; then
+    AC_DEFINE_UNQUOTED(LIBGOMP_USE_MARCEL_BUBBLES, 1, [Define to 1 to use Marcel threads with Bubbles instead of Posix])
+  fi
+  AC_MSG_RESULT($enable_marcel_bubbles)
+fi
+
+if test "$enable_marcel" = yes ; then
+  AC_MSG_CHECKING(whether pm2 is available)
+  if test -z $(which pm2-config) ; then
+    AC_MSG_ERROR(pm2-config not found)
+    exit -1
+  fi
+  AC_MSG_RESULT(yes)
+
+  MARCEL_CPPFLAGS="$(pm2-config --cflags) -I$PM2_ROOT/marcel/include/pthread/"
+
+  save_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS="$MARCEL_CPPFLAGS"
+
+  AC_MSG_CHECKING(whether marcel is available)
+  AC_PREPROC_IFELSE([
+#include "marcel.h"
+], marcel=yes, marcel=no)
+  if test $marcel = no ; then
+    AC_MSG_ERROR(marcel.h not found)
+    exit -1
+  fi
+  AC_MSG_RESULT(yes)
+
+  AC_MSG_CHECKING(whether pmarcel is enabled)
+  AC_COMPILE_IFELSE([
+#include "marcel.h"
+#ifndef MARCEL_POSIX
+#error "marcel posix disabled"
+#endif
+], pmarcel=yes, pmarcel=no)
+  if test $pmarcel = no ; then
+    AC_MSG_ERROR(MARCEL_POSIX not defined)
+    exit -1
+  fi
+  AC_MSG_RESULT(yes)
+
+  AC_MSG_CHECKING(whether marcel keys are enabled)
+  AC_COMPILE_IFELSE([
+#include "marcel.h"
+#ifndef MARCEL_KEYS_ENABLED
+#error "marcel keys disabled"
+#endif
+], marcel_keys=yes, marcel_keys=no)
+  if test $marcel_keys = no ; then
+    AC_MSG_ERROR(MARCEL_KEYS_ENABLED not defined)
+    exit -1
+  fi
+  AC_MSG_RESULT(yes)
+
+  AC_MSG_CHECKING(whether marcel standard_main is enabled)
+  AC_COMPILE_IFELSE([
+#include "marcel.h"
+#ifndef STANDARD_MAIN
+#error "marcel standard_main disabled"
+#endif
+], marcel_standard_main=yes, marcel_standard_main=no)
+  if test $marcel_standard_main = no ; then
+    AC_MSG_ERROR(marcel STANDARD_MAIN not defined)
+    exit -1
+  fi
+  AC_MSG_RESULT(yes)
+
+  if test "$enable_marcel_bubbles" = yes ; then
+    AC_MSG_CHECKING(whether marcel bubbles are enabled)
+    AC_COMPILE_IFELSE([
+#include "marcel.h"
+#ifndef MARCEL_NUMA
+#error "marcel numa disabled"
+#endif
+], pmarcel=yes, pmarcel=no)
+    if test $pmarcel = no ; then
+      AC_MSG_ERROR(MARCEL_NUMA not defined)
+      exit -1
+    fi
+    AC_MSG_RESULT(yes)
+  fi
+
+  CPPFLAGS="$save_CPPFLAGS"
+fi
+
 # Check to see if -pthread or -lpthread is needed.  Prefer the former.
 # In case the pthread.h system header is not found, this test will fail.
 XPCFLAGS=""
+if test $enable_marcel = yes ; then
+
+  XPCFLAGS=" $MARCEL_CPPFLAGS"
+
+else
+
 CFLAGS="$CFLAGS -pthread"
 AC_LINK_IFELSE(
  [AC_LANG_PROGRAM(
@@ -183,6 +288,8 @@ AC_LINK_IFELSE(
    [],
    [AC_MSG_ERROR([Pthreads are required to build libgomp])])])
 
+fi
+
 # Check for functions needed.
 AC_CHECK_FUNCS(getloadavg clock_gettime)
 
@@ -304,6 +411,10 @@ for i in $config_path; do
   fi
 done
 
+if test "$enable_marcel" = yes ; then
+  CFLAGS="$CFLAGS $MARCEL_CPPFLAGS"
+fi
+
 _AC_COMPUTE_INT([sizeof (omp_lock_t)], [OMP_LOCK_SIZE],,
   [AC_MSG_ERROR([unsupported system, cannot find sizeof (omp_lock_t)])])
 _AC_COMPUTE_INT([__alignof (omp_lock_t)], [OMP_LOCK_ALIGN])
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/configure.ac.orig gcc-4.2.2/libgomp/configure.ac.orig
--- gcc-4.2.2.orig/libgomp/configure.ac.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/configure.ac.orig	2007-02-06 19:49:55.000000000 +0100
@@ -0,0 +1,337 @@
+# Process this file with autoconf to produce a configure script, like so:
+# aclocal -I ../config && autoconf && autoheader && automake
+
+AC_PREREQ(2.59)
+AC_INIT([GNU OpenMP Runtime Library], 1.0,,[libgomp])
+AC_CONFIG_HEADER(config.h)
+
+# -------
+# Options
+# -------
+
+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])
+LIBGOMP_ENABLE(version-specific-runtime-libs, no, ,
+   [Specify that runtime libraries should be installed in a compiler-specific directory],
+   permit yes|no)
+AC_MSG_RESULT($enable_version_specific_runtime_libs)
+
+AC_MSG_CHECKING([for --enable-linux-futex])
+LIBGOMP_ENABLE(linux-futex, default, ,
+  [Use the Linux futex system call],
+  permit yes|no|default)
+AC_MSG_RESULT($enable_linux_futex)
+
+# We would like our source tree to be readonly. However when releases or
+# pre-releases are generated, the flex/bison generated files as well as the
+# various formats of manuals need to be included along with the rest of the
+# sources.  Therefore we have --enable-generated-files-in-srcdir to do 
+# just that.
+AC_MSG_CHECKING([for --enable-generated-files-in-srcdir])
+LIBGOMP_ENABLE(generated-files-in-srcdir, no, ,
+   [put copies of generated files in source dir intended for creating source 
+    tarballs for users without texinfo bison or flex.],
+   permit yes|no)
+AC_MSG_RESULT($enable_generated_files_in_srcdir)
+AM_CONDITIONAL(GENINSRC, test "$enable_generated_files_in_srcdir" = yes)
+
+
+# -------
+# -------
+
+# Gets build, host, target, *_vendor, *_cpu, *_os, etc.
+#
+# You will slowly go insane if you do not grok the following fact:  when
+# building this library, the top-level /target/ becomes the library's /host/.
+#
+# configure then causes --target to default to --host, exactly like any
+# other package using autoconf.  Therefore, 'target' and 'host' will
+# always be the same.  This makes sense both for native and cross compilers
+# just think about it for a little while.  :-)
+#
+# Also, if this library is being configured as part of a cross compiler, the
+# top-level configure script will pass the "real" host as $with_cross_host.
+#
+# Do not delete or change the following two lines.  For why, see
+# http://gcc.gnu.org/ml/libstdc++/2003-07/msg00451.html
+AC_CANONICAL_SYSTEM
+target_alias=${target_alias-$host_alias}
+
+# Sets up automake.  Must come after AC_CANONICAL_SYSTEM.  Each of the
+# following is magically included in AUTOMAKE_OPTIONS in each Makefile.am.
+#  1.9.0:  minimum required version
+#  no-define:  PACKAGE and VERSION will not be #define'd in config.h (a bunch
+#              of other PACKAGE_* variables will, however, and there's nothing
+#              we can do about that; they come from AC_INIT).
+#  foreign:  we don't follow the normal rules for GNU packages (no COPYING
+#            file in the top srcdir, etc, etc), so stop complaining.
+#  no-dependencies:  turns off auto dependency generation (just for now)
+#  -Wall:  turns on all automake warnings...
+#  -Wno-portability:  ...except this one, since GNU make is required.
+#  -Wno-override: ... and this one, since we do want this in testsuite.
+AM_INIT_AUTOMAKE([1.9.0 foreign -Wall -Wno-portability -Wno-override])
+AM_ENABLE_MULTILIB(, ..)
+
+# Calculate toolexeclibdir
+# Also toolexecdir, though it's only used in toolexeclibdir
+case ${enable_version_specific_runtime_libs} in
+  yes)
+    # Need the gcc compiler version to know where to install libraries
+    # and header files if --enable-version-specific-runtime-libs option
+    # is selected.
+    toolexecdir='$(libdir)/gcc/$(target_alias)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    ;;
+  no)
+    if test -n "$with_cross_host" &&
+       test x"$with_cross_host" != x"no"; then
+      # Install a library built with a cross compiler in tooldir, not libdir.
+      toolexecdir='$(exec_prefix)/$(target_alias)'
+      toolexeclibdir='$(toolexecdir)/lib'
+    else
+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
+      toolexeclibdir='$(libdir)'
+    fi
+    multi_os_directory=`$CC -print-multi-os-directory`
+    case $multi_os_directory in
+      .) ;; # Avoid trailing /.
+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;
+    esac
+    ;;
+esac
+AC_SUBST(toolexecdir)
+AC_SUBST(toolexeclibdir)
+
+# Check the compiler.
+# The same as in boehm-gc and libstdc++. Have to borrow it from there.
+# We must force CC to /not/ be precious variables; otherwise
+# the wrong, non-multilib-adjusted value will be used in multilibs.
+# As a side effect, we have to subst CFLAGS ourselves.
+
+m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])
+m4_define([_AC_ARG_VAR_PRECIOUS],[])
+AC_PROG_CC
+m4_rename([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])
+
+AC_SUBST(CFLAGS)
+
+# In order to override CFLAGS_FOR_TARGET, all of our special flags go
+# in XCFLAGS.  But we need them in CFLAGS during configury.  So put them
+# in both places for now and restore CFLAGS at the end of config.
+save_CFLAGS="$CFLAGS"
+
+# Add -Wall -Werror if we are using GCC.
+if test "x$GCC" = "xyes"; then
+  XCFLAGS="$XCFLAGS -Wall -Werror"
+fi
+
+# Find other programs we need.
+AC_CHECK_TOOL(AR, ar)
+AC_CHECK_TOOL(RANLIB, ranlib, ranlib-not-found-in-path-error)
+AC_PATH_PROG(PERL, perl, perl-not-found-in-path-error)
+AC_PROG_MAKE_SET
+AC_PROG_INSTALL
+
+# See if makeinfo has been installed and is modern enough
+# that we can use it.
+ACX_CHECK_PROG_VER([MAKEINFO], [makeinfo], [--version],
+                   [GNU texinfo.* \([0-9][0-9.]*\)],
+                   [4.[4-9]*])
+AM_CONDITIONAL(BUILD_INFO, test $gcc_cv_prog_makeinfo_modern = "yes")
+
+
+# Configure libtool
+AM_PROG_LIBTOOL
+AC_SUBST(enable_shared)
+AC_SUBST(enable_static)
+
+AM_MAINTAINER_MODE
+
+# We need gfortran to compile parts of the library
+# We can't use AC_PROG_FC because it expects a fully working gfortran.
+#AC_PROG_FC(gfortran)
+FC="$GFORTRAN"
+AC_PROG_FC(gfortran)
+FCFLAGS="$FCFLAGS -Wall"
+
+# For libtool versioning info, format is CURRENT:REVISION:AGE
+libtool_VERSION=1:0:0
+AC_SUBST(libtool_VERSION)
+
+# Check header files.
+AC_STDC_HEADERS
+AC_HEADER_TIME
+AC_CHECK_HEADERS(unistd.h semaphore.h sys/loadavg.h sys/time.h)
+
+GCC_HEADER_STDINT(gstdint.h)
+
+# Check to see if -pthread or -lpthread is needed.  Prefer the former.
+# In case the pthread.h system header is not found, this test will fail.
+XPCFLAGS=""
+CFLAGS="$CFLAGS -pthread"
+AC_LINK_IFELSE(
+ [AC_LANG_PROGRAM(
+  [#include <pthread.h>
+   void *g(void *d) { return NULL; }],
+  [pthread_t t; pthread_create(&t,NULL,g,NULL);])],
+ [XPCFLAGS=" -Wc,-pthread"],
+ [CFLAGS="$save_CFLAGS" LIBS="-lpthread $LIBS"
+  AC_LINK_IFELSE(
+   [AC_LANG_PROGRAM(
+    [#include <pthread.h>
+     void *g(void *d) { return NULL; }],
+    [pthread_t t; pthread_create(&t,NULL,g,NULL);])],
+   [],
+   [AC_MSG_ERROR([Pthreads are required to build libgomp])])])
+
+# Check for functions needed.
+AC_CHECK_FUNCS(getloadavg clock_gettime)
+
+# Check for broken semaphore implementation on darwin.
+# sem_init returns: sem_init error: Function not implemented.
+case "$host" in
+  *-darwin*)
+    AC_DEFINE(HAVE_BROKEN_POSIX_SEMAPHORES, 1,
+	Define if the POSIX Semaphores do not work on your system.)
+    ;;
+  *-linux*)
+    case "$enable_linux_futex" in
+      default)
+	# If headers don't have gettid/futex syscalls definition, then
+	# default to no, otherwise there will be compile time failures.
+	# Otherwise, default to yes.  If we don't detect we are
+	# compiled/linked against NPTL and not cross-compiling, check
+	# if programs are run by default against NPTL and if not, issue
+	# a warning.
+	enable_linux_futex=no
+	AC_LINK_IFELSE(
+	 [AC_LANG_PROGRAM(
+	  [#include <sys/syscall.h>
+	   int lk;],
+	  [syscall (SYS_gettid); syscall (SYS_futex, &lk, 0, 0, 0);])],
+	  [AC_LINK_IFELSE(
+	   [AC_LANG_PROGRAM(
+	    [#ifndef _GNU_SOURCE
+	     #define _GNU_SOURCE 1
+	     #endif
+	     #include <pthread.h>
+	     pthread_t th; void *status;],
+	    [pthread_tryjoin_np (th, &status);])],[enable_linux_futex=yes],
+	    [if test x$cross_compiling = xno; then
+	       if getconf GNU_LIBPTHREAD_VERSION 2>/dev/null \
+		  | LC_ALL=C grep -i NPTL > /dev/null 2>/dev/null; then
+		 AC_MSG_WARN([The kernel might not support futex or gettid syscalls.
+If so, please configure with --disable-linux-futex])
+	       fi
+	     fi
+	     enable_linux_futex=yes])])
+	;;
+      yes)
+	AC_LINK_IFELSE(
+	 [AC_LANG_PROGRAM(
+	  [#include <sys/syscall.h>
+	   int lk;],
+	  [syscall (SYS_gettid); syscall (SYS_futex, &lk, 0, 0, 0);])],[],
+	  [AC_MSG_ERROR([SYS_gettid and SYS_futex required for --enable-linux-futex])])
+	;;
+    esac
+    ;;
+esac
+
+# At least for glibc, clock_gettime is in librt.  But don't pull that
+# in if it still doesn't give us the function we want.
+if test $ac_cv_func_clock_gettime = no; then
+  AC_CHECK_LIB(rt, clock_gettime,
+    [LIBS="-lrt $LIBS"
+     AC_DEFINE(HAVE_CLOCK_GETTIME, 1,
+	       [Define to 1 if you have the `clock_gettime' function.])])
+fi
+
+# See if we support thread-local storage.
+GCC_CHECK_TLS
+
+# See what sort of export controls are availible.
+LIBGOMP_CHECK_ATTRIBUTE_VISIBILITY
+LIBGOMP_CHECK_ATTRIBUTE_DLLEXPORT
+LIBGOMP_CHECK_ATTRIBUTE_ALIAS
+LIBGOMP_ENABLE_SYMVERS
+
+# Get target configury.
+. ${srcdir}/configure.tgt
+CFLAGS="$save_CFLAGS $XCFLAGS"
+
+# Check for __sync_val_compare_and_swap, but only after the target has
+# had a chance to set XCFLAGS.
+LIBGOMP_CHECK_SYNC_BUILTINS
+
+XCFLAGS="$XCFLAGS$XPCFLAGS"
+
+AC_SUBST(config_path)
+AC_SUBST(XCFLAGS)
+AC_SUBST(XLDFLAGS)
+
+# Cleanup and exit.
+CFLAGS="$save_CFLAGS"
+AC_CACHE_SAVE
+
+if test ${multilib} = yes; then
+  multilib_arg="--enable-multilib"
+else
+  multilib_arg=
+fi
+
+# Set up the set of libraries that we need to link against for libgomp.
+# Note that the GOMP_SELF_SPEC in gcc.c will force -pthread for -fopenmp,
+# which will force linkage against -lpthread (or equivalent for the system).
+# That's not 100% ideal, but about the best we can do easily.
+if test $enable_shared = yes; then
+  link_gomp="-lgomp %{static: $LIBS}"
+else
+  link_gomp="-lgomp $LIBS"
+fi
+AC_SUBST(link_gomp)
+
+AM_CONDITIONAL([USE_FORTRAN], [test "$ac_cv_fc_compiler_gnu" = yes])
+
+# ??? 2006-01-24: Paulo committed to asking autoconf folk to document
+# and export AC_COMPUTE_INT.  If that happens, then we'll need to remove
+# the underscore here and update the PREREQ.  If it doesn't, then we'll
+# need to copy this macro to our acinclude.m4.
+save_CFLAGS="$CFLAGS"
+for i in $config_path; do
+  if test -f $srcdir/config/$i/omp-lock.h; then
+    CFLAGS="$CFLAGS -include $srcdir/config/$i/omp-lock.h"
+    break
+  fi
+done
+
+_AC_COMPUTE_INT([sizeof (omp_lock_t)], [OMP_LOCK_SIZE],,
+  [AC_MSG_ERROR([unsupported system, cannot find sizeof (omp_lock_t)])])
+_AC_COMPUTE_INT([__alignof (omp_lock_t)], [OMP_LOCK_ALIGN])
+_AC_COMPUTE_INT([sizeof (omp_nest_lock_t)], [OMP_NEST_LOCK_SIZE])
+_AC_COMPUTE_INT([__alignof (omp_nest_lock_t)], [OMP_NEST_LOCK_ALIGN])
+
+# If the lock fits in an integer, then arrange for Fortran to use that
+# integer.  If it doesn't, then arrange for Fortran to use a pointer.
+# Except that we don't have a way at present to multi-lib the installed
+# Fortran modules, so we assume 8 bytes for pointers, regardless of the
+# actual target.
+OMP_LOCK_KIND=$OMP_LOCK_SIZE
+OMP_NEST_LOCK_KIND=$OMP_NEST_LOCK_SIZE
+if test $OMP_LOCK_SIZE -gt 8 || test $OMP_LOCK_ALIGN -gt $OMP_LOCK_SIZE; then
+  OMP_LOCK_KIND=8
+fi
+if test $OMP_NEST_LOCK_SIZE -gt 8 || test $OMP_NEST_LOCK_ALIGN -gt $OMP_NEST_LOCK_SIZE; then
+  OMP_NEST_LOCK_KIND=8
+fi
+
+AC_SUBST(OMP_LOCK_SIZE)
+AC_SUBST(OMP_LOCK_ALIGN)
+AC_SUBST(OMP_NEST_LOCK_SIZE)
+AC_SUBST(OMP_NEST_LOCK_ALIGN)
+AC_SUBST(OMP_LOCK_KIND)
+AC_SUBST(OMP_NEST_LOCK_KIND)
+CFLAGS="$save_CFLAGS"
+
+AC_CONFIG_FILES(omp.h omp_lib.h omp_lib.f90 libgomp_f.h)
+AC_CONFIG_FILES(Makefile testsuite/Makefile libgomp.spec)
+AC_OUTPUT
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/configure.tgt gcc-4.2.2/libgomp/configure.tgt
--- gcc-4.2.2.orig/libgomp/configure.tgt	2006-12-02 21:02:00.000000000 +0100
+++ gcc-4.2.2/libgomp/configure.tgt	2007-11-09 16:21:18.000000000 +0100
@@ -23,6 +23,12 @@ if test $have_tls = yes ; then
   esac
 fi
 
+
+if [ "$enable_marcel" = yes ] ; then
+	config_path=marcel
+
+else
+
 # Since we require POSIX threads, assume a POSIX system by default.
 config_path="posix"
 
@@ -109,3 +115,5 @@ case "${target}" in
 	;;
 
 esac
+
+fi
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/critical.c gcc-4.2.2/libgomp/critical.c
--- gcc-4.2.2.orig/libgomp/critical.c	2006-06-21 10:59:44.000000000 +0200
+++ gcc-4.2.2/libgomp/critical.c	2007-11-09 16:21:18.000000000 +0100
@@ -30,6 +30,15 @@
 #include "libgomp.h"
 #include <stdlib.h>
 
+#ifdef LIBGOMP_USES_MARCEL
+#if 1
+#define gomp_mutex_t marcel_spinlock_t
+#define gomp_mutex_init(lock) marcel_spin_init(lock,MARCEL_PROCESS_PRIVATE)
+#define gomp_mutex_lock(lock) marcel_spin_lock(lock);
+#define gomp_mutex_unlock(lock) marcel_spin_unlock(lock);
+#define gomp_mutex_destroy(lock) marcel_spin_destroy(lock)
+#endif
+#endif
 
 static gomp_mutex_t default_lock;
 
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/libgomp_g.h gcc-4.2.2/libgomp/libgomp_g.h
--- gcc-4.2.2.orig/libgomp/libgomp_g.h	2006-01-18 20:21:25.000000000 +0100
+++ gcc-4.2.2/libgomp/libgomp_g.h	2007-11-07 15:29:52.000000000 +0100
@@ -108,4 +108,10 @@ extern bool GOMP_single_start (void);
 extern void *GOMP_single_copy_start (void);
 extern void GOMP_single_copy_end (void *);
 
+/* task.c */
+
+extern void GOMP_task_start (void (*) (void *), void *);
+extern void GOMP_task_end (void);
+extern void GOMP_taskwait (void);
+
 #endif /* LIBGOMP_G_H */
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/libgomp.h gcc-4.2.2/libgomp/libgomp.h
--- gcc-4.2.2.orig/libgomp/libgomp.h	2006-06-10 00:08:55.000000000 +0200
+++ gcc-4.2.2/libgomp/libgomp.h	2007-11-09 16:21:18.000000000 +0100
@@ -40,8 +40,17 @@
 #include "config.h"
 #include "gstdint.h"
 
-#include <pthread.h>
+/* error.c */
+
+extern void gomp_error (const char *, ...)
+	__attribute__((format (printf, 1, 2)));
+extern void gomp_fatal (const char *, ...)
+	__attribute__((noreturn, format (printf, 1, 2)));
+
+
+
 #include <stdbool.h>
+#include <pthread.h>
 
 #ifdef HAVE_ATTRIBUTE_VISIBILITY
 # pragma GCC visibility push(hidden)
@@ -189,13 +198,20 @@ struct gomp_team
   struct gomp_team_state prev_ts;
 
   /* This barrier is used for most synchronization of the team.  */
-  gomp_barrier_t barrier;
+  gomp_barrier_t barrier, /*barrier_start,*/ barrier_stop;
 
   /* This semaphore should be used by the master thread instead of its
      "native" semaphore in the thread structure.  Required for nested
      parallels, as the master is a member of two teams.  */
   gomp_sem_t master_release;
 
+#ifdef LIBGOMP_USE_MARCEL_BUBBLES
+  /* The bubble that contains the threads of this team. */
+  marcel_bubble_t bubble;
+#endif
+
+  struct gomp_thread_start_data *start_data;
+
   /* This array contains pointers to the release semaphore of the threads
      in the team.  */
   gomp_sem_t *ordered_release[];
@@ -216,11 +232,22 @@ struct gomp_thread
 
   /* This semaphore is used for ordered loops.  */
   gomp_sem_t release;
+
+#ifdef LIBGOMP_USE_MARCEL
+  /* usefull to insert the thread in a bubble */
+  marcel_t tid;
+#endif
 };
 
 /* ... and here is that TLS data.  */
 
-#ifdef HAVE_TLS
+#ifdef LIBGOMP_USE_MARCEL
+extern marcel_key_t gomp_tls_key;
+static inline struct gomp_thread *gomp_thread (void)
+{
+  return marcel_getspecific (gomp_tls_key);
+}
+#elif defined HAVE_TLS
 extern __thread struct gomp_thread gomp_tls_data;
 static inline struct gomp_thread *gomp_thread (void)
 {
@@ -258,13 +285,6 @@ extern void *gomp_realloc (void *, size_
    GCC's builtin alloca().  */
 #define gomp_alloca(x)  __builtin_alloca(x)
 
-/* error.c */
-
-extern void gomp_error (const char *, ...)
-	__attribute__((format (printf, 1, 2)));
-extern void gomp_fatal (const char *, ...)
-	__attribute__((noreturn, format (printf, 1, 2)));
-
 /* iter.c */
 
 extern int gomp_iter_static_next (long *, long *);
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/libgomp.map gcc-4.2.2/libgomp/libgomp.map
--- gcc-4.2.2.orig/libgomp/libgomp.map	2006-01-18 20:21:25.000000000 +0100
+++ gcc-4.2.2/libgomp/libgomp.map	2007-11-08 08:27:49.000000000 +0100
@@ -102,4 +102,7 @@ GOMP_1.0 {
 	GOMP_single_copy_end;
 	GOMP_single_copy_start;
 	GOMP_single_start;
+	GOMP_task_end;
+	GOMP_task_start;
+	GOMP_taskwait;
 };
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/Makefile.am gcc-4.2.2/libgomp/Makefile.am
--- gcc-4.2.2.orig/libgomp/Makefile.am	2007-02-06 19:49:55.000000000 +0100
+++ gcc-4.2.2/libgomp/Makefile.am	2007-11-07 15:30:14.000000000 +0100
@@ -32,7 +32,7 @@ libgomp_version_info = -version-info $(l
 libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script)
 
 libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \
-	loop.c ordered.c parallel.c sections.c single.c team.c work.c \
+	loop.c ordered.c parallel.c sections.c single.c team.c task.c taskwait.c work.c \
 	lock.c mutex.c proc.c sem.c bar.c time.c fortran.c
 
 nodist_noinst_HEADERS = libgomp_f.h
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/task.c gcc-4.2.2/libgomp/task.c
--- gcc-4.2.2.orig/libgomp/task.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/task.c	2007-11-07 15:28:17.000000000 +0100
@@ -0,0 +1,48 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This file handles the (bare) TASK construct.  */
+
+#include "libgomp.h"
+#include <stdio.h>
+
+void
+GOMP_task_start (void (*fn) (void *), void *data)
+{
+  /* TODO: implement right behaviour.  */
+  fprintf(stderr, "GOMP_task_start\n");
+  gomp_team_start (fn, data, 1, NULL);
+}
+
+void
+GOMP_task_end (void)
+{
+  /* TODO: implement right behaviour.  */
+  gomp_team_end ();
+  fprintf(stderr, "GOMP_task_end\n");
+}
+
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/taskwait.c gcc-4.2.2/libgomp/taskwait.c
--- gcc-4.2.2.orig/libgomp/taskwait.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.2.2/libgomp/taskwait.c	2007-11-08 09:07:32.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU OpenMP Library (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+   more details.
+
+   You should have received a copy of the GNU Lesser General Public License 
+   along with libgomp; see the file COPYING.LIB.  If not, write to the
+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files, some
+   of which are compiled with GCC, to produce an executable, this library
+   does not by itself cause the resulting executable to be covered by the
+   GNU General Public License.  This exception does not however invalidate
+   any other reasons why the executable file might be covered by the GNU
+   General Public License.  */
+
+/* This file handles the TASKWAIT construct.  */
+
+#include "libgomp.h"
+#include <stdio.h>
+
+void
+GOMP_taskwait (void)
+{
+  /* TODO: implement
+  struct gomp_task *task = gomp_task ();
+  gomp_barrier_wait (&task);
+  */
+  fprintf(stderr, "GOMP_taskwait\n");
+}
diff -uprN -x '*~' -x configure -x autom4te.cache -x '*.in' gcc-4.2.2.orig/libgomp/team.c gcc-4.2.2/libgomp/team.c
--- gcc-4.2.2.orig/libgomp/team.c	2006-06-10 00:08:55.000000000 +0200
+++ gcc-4.2.2/libgomp/team.c	2007-11-09 16:21:18.000000000 +0100
@@ -45,7 +45,9 @@ pthread_attr_t gomp_thread_attr;
 static gomp_barrier_t gomp_threads_dock;
 
 /* This is the libgomp per-thread data structure.  */
-#ifdef HAVE_TLS
+#ifdef LIBGOMP_USE_MARCEL
+marcel_key_t gomp_tls_key;
+#elif defined HAVE_TLS
 __thread struct gomp_thread gomp_tls_data;
 #else
 pthread_key_t gomp_tls_key;
@@ -74,7 +76,7 @@ gomp_thread_start (void *xdata)
   void (*local_fn) (void *);
   void *local_data;
 
-#ifdef HAVE_TLS
+#if HAVE_TLS && !defined LIBGOMP_USE_MARCEL
   thr = &gomp_tls_data;
 #else
   struct gomp_thread local_thr;
@@ -90,11 +92,15 @@ gomp_thread_start (void *xdata)
 
   thr->ts.team->ordered_release[thr->ts.team_id] = &thr->release;
 
+#ifdef LIBGOMP_USE_MARCEL
+  thr->tid = marcel_self ();
+#endif
+
   if (data->nested)
     {
-      gomp_barrier_wait (&thr->ts.team->barrier);
+      //gomp_barrier_wait_start (&thr->ts.team->barrier_start);
       local_fn (local_data);
-      gomp_barrier_wait (&thr->ts.team->barrier);
+      gomp_barrier_wait_start (&thr->ts.team->barrier_stop);
     }
   else
     {
@@ -118,7 +124,7 @@ gomp_thread_start (void *xdata)
 	  thr->ts.work_share_generation = 0;
 	  thr->ts.static_trip = 0;
 
-	  gomp_barrier_wait (&team->barrier);
+	  gomp_barrier_wait_start (&team->barrier_stop);
 	  gomp_barrier_wait (&gomp_threads_dock);
 
 	  local_fn = thr->fn;
@@ -148,9 +154,12 @@ new_team (unsigned nthreads, struct gomp
   team->oldest_live_gen = work_share == NULL;
   team->num_live_gen = work_share != NULL;
   team->work_shares[0] = work_share;
+  team->start_data = NULL;
 
   team->nthreads = nthreads;
   gomp_barrier_init (&team->barrier, nthreads);
+  //gomp_barrier_init (&team->barrier_start, nthreads);
+  gomp_barrier_init (&team->barrier_stop, nthreads);
 
   gomp_sem_init (&team->master_release, 0);
   team->ordered_release[0] = &team->master_release;
@@ -167,6 +176,8 @@ free_team (struct gomp_team *team)
   free (team->work_shares);
   gomp_mutex_destroy (&team->work_share_lock);
   gomp_barrier_destroy (&team->barrier);
+  //gomp_barrier_destroy (&team->barrier_start);
+  //gomp_barrier_destroy (&team->barrier_stop);
   gomp_sem_destroy (&team->master_release);
   free (team);
 }
@@ -189,6 +200,32 @@ gomp_team_start (void (*fn) (void *), vo
 
   team = new_team (nthreads, work_share);
 
+#ifdef LIBGOMP_USE_MARCEL
+  marcel_attr_t gomp_thread_attr;
+
+  marcel_attr_init(&gomp_thread_attr);
+  marcel_attr_setdetachstate(&gomp_thread_attr, tbx_true);      
+  marcel_attr_setseed(&gomp_thread_attr, tbx_true);
+  marcel_attr_setprio(&gomp_thread_attr, MA_BATCH_PRIO);
+
+#ifdef LIBGOMP_USE_MARCEL_BUBBLES
+  if (nthreads > 1 && nested)
+    {
+      marcel_bubble_init (&team->bubble);
+      marcel_bubble_setinithere (&team->bubble);
+      marcel_bubble_setprio (&team->bubble, MA_BATCH_PRIO);
+      marcel_bubble_insertbubble (marcel_bubble_holding_task (thr->tid), &team->bubble);
+      //marcel_wake_up_bubble(&team->bubble);
+      marcel_bubble_inserttask (&team->bubble, thr->tid);
+      marcel_attr_setinitbubble(&gomp_thread_attr, &team->bubble);
+    }
+  else
+    marcel_attr_setinitbubble(&gomp_thread_attr, &marcel_root_bubble);
+#endif
+#endif
+
+
+
   /* Always save the previous state, even if this isn't a nested team.
      In particular, we should save any work share state from an outer
      orphaned work share construct.  */
@@ -265,11 +302,11 @@ gomp_team_start (void (*fn) (void *), vo
 	}
     }
 
-  start_data = gomp_alloca (sizeof (struct gomp_thread_start_data)
+  team->start_data = gomp_malloc (sizeof (struct gomp_thread_start_data)
 			    * (nthreads-i));
 
   /* Launch new threads.  */
-  for (; i < nthreads; ++i, ++start_data)
+  for (start_data = team->start_data; i < nthreads; ++i, ++start_data)
     {
       pthread_t pt;
       int err;
@@ -290,14 +327,17 @@ gomp_team_start (void (*fn) (void *), vo
     }
 
  do_release:
-  gomp_barrier_wait (nested ? &team->barrier : &gomp_threads_dock);
+  if (!nested) {
+    gomp_barrier_wait (&gomp_threads_dock);
 
   /* Decrease the barrier threshold to match the number of threads
      that should arrive back at the end of this team.  The extra
      threads should be exiting.  Note that we arrange for this test
      to never be true for nested teams.  */
-  if (nthreads < old_threads_used)
-    gomp_barrier_reinit (&gomp_threads_dock, nthreads);
+    if (nthreads < old_threads_used)
+      gomp_barrier_reinit (&gomp_threads_dock, nthreads);
+  } //else
+    //gomp_barrier_wait (&team->barrier_start);
 }
 
 
@@ -310,32 +350,74 @@ gomp_team_end (void)
   struct gomp_thread *thr = gomp_thread ();
   struct gomp_team *team = thr->ts.team;
 
-  gomp_barrier_wait (&team->barrier);
+  gomp_barrier_wait (&team->barrier_stop);
+
+
+#ifdef LIBGOMP_USE_MARCEL_BUBBLES
+    if (team->nthreads > 1 &&  team->prev_ts.team != NULL)
+    {
+      marcel_bubble_t *holding_bubble = marcel_bubble_holding_bubble (&team->bubble);
+      marcel_bubble_inserttask (holding_bubble, thr->tid);
+      marcel_bubble_join (&team->bubble);
+      marcel_bubble_destroy (&team->bubble);            
+    }  
+#endif
 
   thr->ts = team->prev_ts;
 
+  free(team->start_data);
   free_team (team);
 }
 
 
 /* Constructors for this file.  */
 
+#define MAGOMP_DEBUG_LENGTH_MAX 1024
+#define MAGOMP_DEBUG_PREFIX "--debug:"
+#define MAGOMP_DEBUG_PREFIX_LENGTH strlen(MAGOMP_DEBUG_PREFIX)
+
 static void __attribute__((constructor))
 initialize_team (void)
 {
   struct gomp_thread *thr;
 
-#ifndef HAVE_TLS
+#ifdef LIBGOMP_USE_MARCEL
+  {
+    struct marcel_sched_param param = {.sched_priority = MA_BATCH_PRIO};
+    marcel_init (NULL, NULL);
+    marcel_sched_setparam (marcel_self (), &param);
+    marcel_thread_preemption_disable ();
+  }
+#endif
+
+#if !defined HAVE_TLS || defined LIBGOMP_USE_MARCEL
   static struct gomp_thread initial_thread_tls_data;
 
   pthread_key_create (&gomp_tls_key, NULL);
   pthread_setspecific (gomp_tls_key, &initial_thread_tls_data);
 #endif
 
-#ifdef HAVE_TLS
+#if defined HAVE_TLS && !defined LIBGOMP_USE_MARCEL
   thr = &gomp_tls_data;
 #else
   thr = &initial_thread_tls_data;
+#ifdef LIBGOMP_USE_MARCEL
+  thr->tid = marcel_self ();
+#endif
 #endif
   gomp_sem_init (&thr->release, 0);
+  gomp_barrier_init (&gomp_threads_dock, 1);
+}
+
+#ifdef LIBGOMP_USE_MARCEL
+void __attribute__((destructor))
+finalize_team() 
+{
+  if (gomp_threads_used) {
+    gomp_barrier_wait (&gomp_threads_dock);
+    gomp_barrier_destroy (&gomp_threads_dock);    
+  }
+  marcel_end();
 }
+#endif
+
