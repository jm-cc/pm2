<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE TEXT SYSTEM "file:///net/cvs/runtime/usr/xml2html/data/xml/DOCUMENT.dtd">

<TEXT>

<SUBSECTION TITLE="Introducing PM2 flavors">

<P>
You have now compiled and run a few PM2 programs. It is time to have a
look at the underlying machinery. The key feature is the notion of
<EM>flavor</EM>, which we will explain in detail below. Technically speaking,
a PM2 module is a library to be linked with your program. For
instance, the module <TT>pm2</TT> is attached to the library <TT>libpm2.a</TT>. It is the job of the
<TT>pm2-config</TT> utility to automatically generate the correct compiling
and linking set of directives for the various modules.

<CODE FILE="./Sources/code/pm2config.txt"/>
</P>

<P>
It is important to realize at this point that the various PM2 modules
are independently compiled into <EM>separate</EM> libraries. Yet, these
libraries are <EM>strongly</EM> dependent one on each other, and they
are moreover dependent on the directives used in compiling the main
program. Therefore, uttermost care is needed in managing the various
sets of compiling and linking directives, as they <EM>must</EM> be
consistent. 
</P>

<P>
Another aspect is that many users are interested in using
<EM>several</EM> versions of PM2 at a time. For instance, you may wish
to compare the performance of a given user program on a Myrinet and on
a SCI network within the same benchmarking session. Or, you may use a
version of the program compiled with all the debugging features turned
on, and another one aggressively optimized. You may even compare a
version of PM2 compiled with some C<SPACE/>compiler against another
version compiled with another C<SPACE/>compiler.  Different decisions
will result in different PM2 libraries. Changing the network from
Myrinet to SCI requires a recompilation of the Madeleine module.  Changing
the mode from debugging to optimizing requires a total recompilation of
all the libraries from scratch. This is a not trivial operation, as it
consumes time and resources.
</P>

<NOTE>
  LB to RN: Is the name of the C compiler included in the flavor?
</NOTE>

<P>
All these motivations have led to the notion of <EM>PM2 flavors</EM>. A PM2
flavor is simply a set of compiling and linking options for the user
program and the various modules of PM2: Marcel, Madeleine, DSM, and
various other ancillary modules. It is always assumed that the user
program and the modules have been compiled and linked with the
<EM>same</EM> flavor. Unfortunately, there is no easy way to enforce
this in the C/Unix framework. The method used in PM2 to enforce global
consistency is explained in the following.
<UL>
  
<LI>
<P>
 The list of all currently available flavors is provided by
  the command <TT>pm2-flavor list</TT>.

<CODE FILE="./Sources/code/pm2flavorlist.txt"/>
</P>
</LI>

<LI>
<P>
 At any point, the currently active flavor is the value of the shell
  variable <TT>PM2_FLAVOR</TT>. Alternatively, most PM2 commands provide a
  <TT>--flavor=xxx</TT> flag, so that you can easily manage several flavors
  at the same time within a Makefile or a script. The default of
  <TT>xxx</TT> is the value of the variable <TT>PM2_FLAVOR</TT>.
  
  <WARNING>
    The <TT>PM2_FLAVOR</TT> variable should most preferably be set to
    a value! Remember to <TT>export</TT> it if you use <TT>sh</TT>-like
    shells.
  </WARNING>
</P>
</LI>

<LI>  
<P>
 The flavor <TT>xxx</TT> is kept in the file <TT>${PM2_HOME}/.pm2/flavors/xxx</TT>, as
  indicated by the command <TT>pm2-flavor find --flavor=xxx</TT>.

  <WARNING>
    These files are automatically generated by the tools to be presented
    below. Do not edit them by hand!
  </WARNING>

<CODE FILE="./Sources/code/pm2flavorfind.txt"/>
</P>
</LI>

<LI>
<P>
 The list of options defined by the flavor <TT>xxx</TT> is provided by
  the command <TT>pm2-flavor get --flavor=xxx</TT>.

<CODE FILE="./Sources/code/pm2flavorget.txt"/>
</P>
</LI>

<LI>
<P>
 The internal consistency of the flavor <TT>xxx</TT> can be checked with
  the command <TT>pm2-flavor check --flavor=xxx</TT>.

<CODE FILE="./Sources/code/pm2flavorcheck.txt"/>
</P>
</LI>

<LI>
<P>
A flavor may be regenerated by using the command <TT>pm2-flavor regenerate --flavor=xxx</TT>.

<CODE FILE="./Sources/code/pm2flavorregen.txt"/>
</P>
</LI>

<LI>
<P>
 When a module is compiled with the flavor <TT>xxx</TT>, then the
  resulting object code is created into the directory
  <TT>${PM2_BUILD_DIR}/xxx</TT>. You may thus have several versions of PM2
  ready for use at the same time.
</P>
</LI>

<LI>
<P>
 To compile and link a user program with the flavor <TT>xxx</TT>, use the
  flags generated by the commands <TT>pm2-config --cflags</TT> and <TT>pm2-config
  --libs</TT>, as shown in the Makefile in Program <REF LABEL="prog:Makefile1"/>.
</P>
</LI>
</UL>
</P>

</SUBSECTION>

<SUBSECTION TITLE="Creating your own, personal PM2 flavors">

<P>
You know now <EM>what</EM> a flavor is, and more or less <EM>why</EM> it is
so. Let us now learn <EM>how</EM> they can be used. Assume for instance
that you have been using the flavor <TT>pm2</TT> since your (PM2-)birth:
<TT>setenv PM2_FLAVOR pm2</TT>. After having grown up, you are now starting
feeling somehow unsatisfied with it, almost frustrated. No problem,
PM2 has something for you: <TT>ezflavor</TT>! (To be pronounced:
<EM>ee-zee-flavor</EM>)
</P>

<P>
The <TT>ezflavor</TT> utility is a graphic interface to list, modify, check,
and regenerate flavors all in once. As it is highly dependent on the
operating system you are running, you first have to compile it:

<CODE FILE="./Sources/code/makeEzflavor.txt"/>
</P>

<P>
The binary will be created in the directory
<TT>${PM2_BUILD_DIR}/ezflavor/ezflavor/bin/</TT>. The root script to
invoke <TT>ezflavor</TT> is available from your <TT>PATH</TT> in
<TT>${PM2_ROOT}/bin/ezflavor</TT>, using your PM2 configuration, it
will automatically redirect your call to the binary file.
</P>

<P>
So now, let's start <TT>ezflavor</TT> so to analyze your PM2-frustration.

<CODE FILE="./Sources/code/ezflavor.txt"/>
</P>

<IMAGE FILE="Figures/ezflavor" TITLE="The ezflavor graphic interface to manage PM2 flavors." SCALE="0.7" LABEL="fig:ezflavor"/>

<P>
Load in the current flavor <TT>pm2</TT>.
<UL>
  
<LI>
<P>
 Select the <TT>pm2</TT> module. The result is displayed on
  Figure <REF LABEL="fig:ezflavor"/>. As you can see, only one option is turned
  on for this module: <TT>opt</TT>, which makes the module run in optimized
  mode. 
</P>
</LI>

<LI>  
<P>
 Select the <TT>mad3</TT> module: you can observe that the <TT>tcp</TT>
  option is turned on, which makes Madeleine use the TCP/IP interface.
</P>
</LI>

<LI>
<P>  
 Select the <TT>marcel</TT> module: you can observe the <TT>mono</TT> option
  is turned on, which makes Marcel run on a single processor at each
  node (even though the node may be have multiple processors). Also,
  you can observe that the <TT>marcel_main</TT> option is on, which
  specifies that the <TT>main</TT> function of the C<SPACE/>program is provided by
  PM2 (actually, by Marcel). The user only specifies the auxiliary
  <TT>pm2_main</TT> function, which is called by the real <TT>main</TT> function
  after some initialization. See for instance
  Program <REF LABEL="prog:hello"/>.
</P>
</LI>

<LI>
<P>  
 Finally, you can observe that the <TT>opt</TT> option is enabled for
  the application itself: the user code is compiled with the
  <TT>-O6</TT> option of the <TT>gcc</TT> compiler.
</P>
</LI>

</UL>
</P>

<P>
Assume now that the real PM2 you are striving after is a PM2 with
fully-fledged debugging facilities. What you need is to create a new
flavor that we will called <TT>pm2-debug</TT> based on the
<TT>pm2</TT> one.
</P>

<P>
Select the <TT>debug</TT> option in the <TT>pm2</TT> module.  Do it
also for the application, and for the <TT>mad3</TT> and <TT>dsm</TT>
modules. Change the name of this new flavor from <TT>pm2</TT> to
<TT>pm2-debug</TT>, and save it (see Figure <REF LABEL="fig:ezflavor-create"/>).

<IMAGE FILE="Figures/ezflavor-create" TITLE="Creating a new flavor with ezflavor" SCALE="0.7" LABEL="fig:ezflavor-create"/>

The new flavor is checked for consistency and saved into the file
<TT>${PM2_HOME}/.pm2/flavors/pm2-debug</TT>. You may check that
the file actually contains the new settings:

<CODE FILE="./Sources/code/flavor.txt"/>
</P>

<P>
Now, you have to recompile PM2 for this new flavor. Observe that you
do not have to explicitly set the <TT>PM2_FLAVOR</TT> shell variable to
this new value. Just specify it in-line to the <TT>make</TT> facility.

<CODE FILE="./Sources/code/flavor2.txt"/>
</P>

<P>
Everything should run smoothly, without any warning...
</P>

<P>
Once you are done, set the <TT>PM2_FLAVOR</TT> variable to
<TT>pm2-debug</TT> and compile your favorite PM2 program using a
``dynamic'' Makefile as the one on Program <REF
LABEL="prog:Makefile1"/>. Ideally, you should not see any difference
with the <TT>pm2</TT> run.

<CODE FILE="./Sources/code/flavor3.txt"/>
</P>

<P>
Just for fun, modify the <TT>pm2-debug</TT> flavor so as to enable the option
<TT>isoaddr_trace</TT> in the <TT>pm2</TT> module. Recompile PM2
with this modified flavor. Recompile your program, for instance the
simplistic <TT>hello</TT> on Program <REF LABEL="prog:hello"/> and run it. You should
see a lot of rather cryptic debugging information:

<CODE FILE="./Sources/code/pm2loadflavor.txt"/>
</P>

<WARNING>
  Be careful that the simple Makefile of Program <REF LABEL="prog:Makefile1"/>
  is not able to spot that the flavor has been modified. You will have
  to explicitly delete the object file to create a fresh, consistent
  one. 
</WARNING>

<P>
It is often interesting to enable some options for <EM>all</EM> the
modules at the same time, together with the application. This can be
the case for example for the <TT>debug</TT>, <TT>gdb</TT>,
<TT>opt</TT> (optimization) and <TT>profile</TT> options.
<TT>ezflavor</TT> provides such a facility: click on
<TT>View</TT>/<TT>Common options/Display panel</TT> to open the
appropriate window, as shown on Figure <REF LABEL="fig:options"/>.
</P>

<IMAGE FILE="Figures/options" TITLE="The 'Common options' window of the ezflavor utility." SCALE="0.7" LABEL="fig:options"/>


<P>
<B>A note to the wizards.</B>

Experienced and hurried users may find that the <TT>ezflavor</TT> interface is
too heavy with respect to their needs. A tty-oriented interface is
also available. It is called <TT>pm2-config-flavor</TT>.

<CODE FILE="./Sources/code/pm2configflavor.txt"/>
</P>

<WARNING>
  In the current version of the system, no backup copy of a flavor is
  done prior editing. Be careful! In case, you think you have really messed up with one of your flavors, it is always possible to delete it and regenerate it from scratch.

  <CODE FILE="./Sources/code/pm2configflavorremove.txt"/>
</WARNING>

</SUBSECTION>

<SUBSECTION TITLE="Debugging a PM2 program">

<P>
You may have already experienced problems in designing PM2 programs.
Debugging distributed, multithreaded programs is a difficult task, and
few tools already exist to assist the programmer in it. One of the
goal of the PM2 project is to contribute to the design of such tools,
but we have rather concentrated on <EM>performance</EM> debugging.
Actually, PM2 is equipped with powerful profiling facilities, to be
introduced in Section <REF LABEL="sec:profiling"/>. In this section, we rather
concentrate on the tools available at the level of programming.
</P>

<P>
The first step is to derive a specific flavor from your current one.
It should enable the options <TT>debug</TT> and <TT>gdb</TT> for all modules. With
the <TT>debug</TT> option enabled, the modules of PM2 are careful to check
consistency conditions along the execution, so that abnormal situation
may be detected early. You may also wish to concentrate on memory
allocations by enabling the <TT>safe_malloc</TT> and the <TT>parano_malloc</TT>
options of module <TT>tbx</TT>, the toolbox common to all PM2 modules. If
you suspect a problem with synchronization objects, you will find
useful options in the <TT>marcel</TT> module, and in the <TT>dsm</TT> module for
the inter-node synchronization actions induced by the DSM consistency
protocols. I you wish to use the <TT>valgrind</TT> debugger on a program using
<TT>marcel</TT>, you need to set the <TT>valgrind</TT> option of the <TT>marcel</TT>
module to let <TT>valgrind</TT> know about <TT>marcel</TT> stacks. If your version
of <TT>valgrind</TT> is older than 3.0, you will also need to recompile it
after setting, in <TT>coregrind/vg_memory.c</TT>, the
<TT>VG_PLAUSIBLE_STACK_SIZE</TT> constant to the size of <TT>marcel</TT> stacks
(65536 by default).
</P>

<P>
Assuming that you are using the <TT>pm2</TT> flavor, make up a
<TT>pm2-debug</TT> one. Set your <TT>PM2_FLAVOR</TT> shell variable to this value,
and recompile PM2 with this new flavor. 

<CODE FILE="./Sources/code/pm2debug.txt"/>
</P>

<P>
Then, recompile the programs of interest with this new flavor. 
</P>

<WARNING>
  Make sure that they are <EM>actually</EM> recompiled: better delete
  the objects files by hand!
</WARNING>

<P>
A second step is to insert additional trace outputs within your source
code. Your are strongly advised to print on the <TT>stderr</TT> error
descriptor instead of regular <TT>stdout</TT> one. Also, you should always
use the <EM>thread-safe</EM> version of <TT>(f)printf</TT>, called <TT>t(f)printf</TT>.
This will prevent multiple Marcel thread to print concurrently,
leading to scrambled text. Use the <TT>pm2logs</TT> utility to view the
remote logs. It may be useful to force logging also on the main
node<SPACE/>0: use <TT>pm2load -l</TT>. Then, <TT>pm2logs</TT> will recover exactly one
log per (logical) node.
</P>

<P>
You may also require ``immediate'' output from remote node by using
the <TT>pm2_(f)printf</TT> routine. Each time it is called, the output is
packed into a buffer and sent to main node<SPACE/>0 to be immediately
displayed there. The output is prefixed by <TT>t&lt;i&gt;</TT>, where <TT>&lt;i&gt;</TT> is
the logical number of the originator node.  This is quite convenient, but
the user has to be aware that the additional messages generated in
this way <EM>do interfere</EM> with the original communication scheme of
the program under debugging. In particular, they may generate
additional deadlocks! Also, these additional messages have to be
considered when designing the termination scheme of the program. The
<TT>pm2_halt</TT> function should not be called by a node <EM>before</EM> it
is guaranteed that all communications, whatever their origin, have
been handled by the daemon service threads. Deadlock may otherwise
occur.
</P>

<P>
The <TT>pm2load</TT> utility honors a number of options.  The most useful
one in a first place is <TT>pm2load -d</TT>. It can be used with any flavor,
but it is most rewarding when the current flavor enables the <TT>gdb</TT>
for all the modules and for the application. If run with the <TT>-d</TT>
option, <TT>pm2load</TT> opens a <TT>gdb</TT> session on each (logical) node
declared in the configuration, with a display on your console. Just
typing <TT>r</TT> (for <TT>run</TT>) in the window will start the execution.
Observe that your have to type it in <EM>each</EM> window!  Before
debugging your program at this level, you'd better downsize your code
to some manageable configuration, say<SPACE/>3 or 4<SPACE/>nodes. Observe also that
the windows of nodes other than the main one will only pop up after
the main node has started and called its <TT>pm2_main</TT> routine. Then,
the node is blocked until you have typed <TT>r</TT> in the window of each
subsidiary node. Before starting the nodes, you may add breakpoints
and require all kind of functionalities provided by <TT>gdb</TT>.  PM2 does
not close the windows at the end of the run, so that you can inspect
the final state of each node. Typing <TT>Ctrl-D</TT> in each window will close
it and terminate the program.
</P>

<WARNING>
  A note to eye-impaired Solaris users. The <TT>gdb</TT> facility is run
  within a <TT>xterm</TT>. In certain recent versions of Solaris, the
  default for the <TT>xterm</TT> background is a dark gray, which makes
  debugging *very* painful. You can change it to white by adding the
  following line to your <TT>${HOME}/.Xdefaults</TT> file:

<CODE FILE="./Sources/code/xdefaults.txt"/>

Once it is done, reload your <TT>.Xdefaults</TT> file by issuing:

<CODE FILE="./Sources/code/xdefaults2.txt"/>
</WARNING>

<P>
The user should be aware that <TT>gdb</TT> itself is <EM>not</EM> aware
of Marcel threads: <TT>info threads</TT> will only show LWPs,
<TT>thread &lt;num&gt;</TT> will only let switch between LWPs, and
<TT>backtrace</TT> will only show the backtrace of the <EM>current</EM>
Marcel thread running in the chosen LWPs.
</P>

<P>
However, if Marcel was compiled with the gdb option, Marcel provides
several gdb functions for printing thread state like the --marcel-xtop
option:

<CODE FILE="./Sources/code/marcelTop.txt"/>
</P>

<P>
One may switch to not-running threads' context thanks PM2-provided
functions<FOOTNOTE>yet implemented on X86 only</FOOTNOTE>:

<CODE FILE="./Sources/code/gdb.txt"/>
</P>

<P>
One can then use usual functions like <TT>frame</TT>, <TT>print</TT>,
etc. to inspect the thread.
</P>

<P>
The user should be aware that although <TT>set-ctx</TT> achieves a
context switch so as to get correct <TT>PC</TT> and <TT>SP</TT>,
<TT>continue</TT>-like commands automatically switch back to the
current running thread<FOOTNOTE>In theory, the PM2 process should
then continue properly, but it seems gdb does not yet let this work
correctly</FOOTNOTE>.
</P>

<P>
The user should be aware that some of the names of PM2 routine are in
fact on-line definitions in internal header files. Thus, one has to
know the <EM>actual</EM> name of the routine to set a breakpoint. The
following table provides the some useful translations.
</P>

<P>
<TABLE>
<TR>
<TH>External name</TH> <TH>Real name</TH> <TH>Origin module</TH>
</TR>
<TR>
<TD> <TT>pm2_init</TT></TD> <TD><TT>common_init</TT></TD> <TD><TT>pm2</TT></TD>
</TR>
<TR>
<TD><TT>pm2_main</TT></TD> <TD><TT>marcel_main</TT></TD> <TD><TT>pm2</TT></TD>
</TR>
<TR>
<TD><TT>tprintf</TT></TD>    <TD><TT>marcel_printf</TT></TD>      <TD><TT>tbx</TT></TD>
</TR>
<TR>
<TD><TT>tfprintf</TT></TD>     <TD><TT>marcel_fprintf</TT></TD>     <TD><TT>tbx</TT></TD>
</TR>
<TR>
<TD><TT>lock_task</TT></TD>    <TD><TT>ma_lock_task</TT></TD>       <TD><TT>marcel</TT></TD>
</TR>
<TR>
<TD><TT>unlock_task</TT></TD>  <TD><TT>ma_unlock_task</TT></TD>     <TD><TT>marcel</TT></TD>
</TR>
</TABLE>
</P>

</SUBSECTION>

</TEXT>
