\chapter{Wizarding PM2: advanced features}

\stamp $Id: wizarding.tex,v 1.6 2001/04/18 15:13:14 bouge Exp $

We have gathered in this section some advanced material as a reference
for the advanced user. Beginners should probably skip this section on
a first reading. 

\section{Thread synchronization}

PM2 provides a number of POSIX-like synchronization facilities to
synchronize the threads within a node and among remote nodes: locks,
mutexes, semaphores, conditions, barriers. The facilities which are
local to a node are provided by the Marcel thread scheduler. Remote
synchronization facilities are provided by PM2.

\subsection{Locks}

The lowest level of synchronization is to temporarily disable the scheduler
at the local node. This guarantees that the successive
instructions will be issued atomically. This is done using the
\|pm2_freeze|/\|pm2_unfreeze| routines. These are simply wrappers for
two essential Marcel routines respectively called \|lock_task| and
\|unlock_task|. The \|lock_task| routine locks a Marcel thread within
the scheduler, disabling any external interrupt. No other thread
whatsoever can be scheduled until the \|unlock_task| has been called.
These routines may be nested. It is up to the user to guarantee proper
nesting. One has to be uttermost careful that PM2/Marcel provides no
protection against deadlock. Also, locking a tasked within a node
disables any progress of the daemon service threads: no message can be
received, etc. It is up to the user to guarantee that no harm may
result, for instance from overfilling communication buffers.

\figurelistingdouble {freeze.c} {Freezing and unfreezing the scheduler}
{prog:freeze}

Consider Program~\ref{prog:freeze}. The main thread spawns an even
number of threads on the local node. Each even thread increases the
shared variable \|counter| for \|N| times, and each odd thread decreases
it for \|N| times, too. To emphasize that increasing and decreasing a
variable is \emph{not} an atomic operation at the level of machine
code, we have written it explicitly as a Load/Add/Store series of
operations. (Observe that variable \|tmp| has be registered as
\|volatile| to prevent the wise compiler to optimize our
trick!). The expected final value for \|counter| is~0.  
\begin{shell}
ravel% pm2-load freeze
Initial value: 0
Creating thread 0
Creating thread 1
Creating thread 2
Creating thread 3
Final value: 0
\end{shell}

It is interesting to run the program without the calls to
\|pm2_freeze| and \|pm2_unfreeze| routines, and see what happens.
At least on my current workstation, this yieds the following result:
\begin{shell}
ravel% pm2-load freeze
Initial value: 0
[...]
Final value: 776821
\end{shell}
It shows that getting interrupted in the middle of the critical section
is a relatively frequent event, which should definitely not be
overlooked by the PM2 programmer! 

\subsection{Mutexes}
\label{sec:mutex}

\figurelistingdouble {mutex.c} {Using mutexes in PM2}
{prog:mutex}

Freezing is sufficient for most simple purpose, when a (short!)
sequence of actions have to be atomically issued. Yet, this does not
handle the case of sequence where the thread may get temporarily
suspended, from its own request or not. In this case, more
sophisticated facilities have to be used, for instance mutexes (for
\emph{mutual exclusion}). Consider Program~\ref{prog:mutex}, and
assume that for some reason, the thread should be suspended right in
the middle of the critical section. We simulate this by a call to the
\|marcel_yield| routine, which yields the control back to the
scheduler and inserts back the thread into the ready list. Running the
program without any synchronization facility returns a non-null value,
even for a few iterations. A mutex has to be first initialized using
the \|marcel_mutex_init| routine, with a number of attributes. As
usual, \|NULL| is a sensible default in a first place.  A mutex can
afterwards be acquired and released, respectively with the
\|marcel_mutex_lock| and \|marcel_mutex_unlock| routines.

\subsection{Semaphores}

\figurelistingdouble {semaphore.c} {Using semaphores in PM2}
{prog:semaphore}

Marcel also provides semaphores. A semaphore can be initialized with
the \|marcel_sem_init| routine with an initial integer value. It can
be taken with \|marcel_sem_P|, and freed with \|marcel_sem_V|, as
(probably?) expected.

In fact, completion are just a simple wrapping for semaphores. On
initializing a completion, a semaphore is initialized, and its address
and native node are stored into a structure. Waiting for a completion
is just issuing a \|marcel_sem_P| on the semaphore.  Signaling
completion includes the following action: if the local node is the
same as the native node, then a call to \|marcel_sem_V| is issued for
the semaphore; otherwise, a RPC request is issued to the native node,
with the the signaling routine as its service and the completion as
its argument. Program~\ref{prog:semaphore} is the same as
Program~\ref{prog:mutex}, but completions have been replaced by
explicit semaphores.

\subsection{Conditions}

\figurelistingdouble {condition.c} {Using condition variables in PM2}
 {prog:condition}

Marcel finally provides conditions variables associated to mutexes,
with a Mesa-style semantics. A thread which signals a condition keeps
on running. One of the threads blocked waiting for this condition is
selected and appended to the queue of the threads ready to run. As a
consequence, \emph{user cannot be guaranteed that a thread which exits
  a wait is immediately executed}. Actually, no hypothesis may be made
about the state of the thread at the time it is eventually
scheduled. This is the reason why it is necessary to encapsulate
waiting commands within \|while| loops: the first action of a thread
which has been signaled is then to retest the condition which
commanded its waiting; if it does not hold, then it goes back to
sleep, waiting again to be signaled.

In Program~\ref{prog:condition}, we have further constrained the
shared counter to take values only between \|MIN_COUNTER| and
\|MAX_COUNTER|. This is done using two condition variables
to control increment and decrement, similarly to a classical
producer-consumer scheme. (We have reverted to direct operations on
the \|counter| variable to enhance readability.) 

A condition is declared using the \|marcel_cond_init| routine. It
takes as arguments the condition and an attribute. As usual, \|NULL|
is a sensible default for the attribute. Waiting on a condition makes
sense \emph{only} within a critical section controlled by some mutex.
The mutex is passed to the routine \|marcel_cond_wait| as an
additional parameter. The very first job of this routine is to acquire
the mutex. In the regular use of condition variables, the waiting
routine is called within the critical section controlled by this very
mutex, so that is it necessarily free. But it is not mandatory to do
so, though the writer cannot see any sensible example of such a
situation at this time... The condition is signaled using the
\|marcel_cond_signal| routine. Observe this does not require any
reference to the controlling mutex. This routine wakes up exactly one
waiting thread, if any exists. Alternatively, the
\|marcel_cond_broadcast| routine wakes up \emph{all} threads waiting
on the given condition. It is also possible to specify a limit on the
time a thread should wait for a condition, using the
\|marcel_cond_timedwait| routine. In this case, the routine returns a
\|ETIMEDOUT| value if the thread has not been signaled within the
specify delay.

\begin{note}
  LB to RN: Please check carefully!
\end{note}

\section{Profiling PM2 programs}
\label{sec:profiling}

\begin{note}
  LB: Yet to do. 
\end{note}

\section{Miscellaneous}

\subsection{Application initialization with PM2}
\label{sec:startupfunc}

\begin{note}
  LB: Yet to do. Describe \|pm2_set_startup_func|?
\end{note}



