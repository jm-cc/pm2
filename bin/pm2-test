#!/usr/bin/env pm2-sh
#-*-sh-*-

# PM2: Parallel Multithreaded Machine
# Copyright (C) 2001 "the PM2 team" (see AUTHORS file)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.


_PM2_TEST_PROGNAME=pm2-test

_ALL_MODULES="`${PM2_ROOT}/bin/pm2-module modules`"

_DIRTY_ORDERED_MODULES="tbx marcel ntbx mad3 nmad pm2"

pm2_test_error() # msg
{
    echo $* >&2
    exit 1
}

pm2_test_error_file() # msg file
{
    echo "----------------------------------------" >&2
    cat $2
    echo "----------------------------------------" >&2
    pm2_test_error $1
}

pm2_test_usage() # exit_code
{
    cat <<EOF
Usage: $_PM2_TEST_PROGNAME { option } { modules }
  option:
    -h,--help      : show this help
    -q,--quiet     : do not be verbose
    -l1,--basic    : run a basic number of tests
    -l2,--normal   : run a reasonable number of tests for each PM2 module (default)
    -l3,--advanced : run a lot of tests to check more advanced features
    -l4,--torture  : check each line of C code to search for hidden bugs ;-)))
    -j N --jobs=N  : pass -j parameter to make so as to speed up compilation
    --coverage     : perform coverage testing (requires GCC, GNU gcov, and Lcov)
    --tests XXX    : specify the tests to be run (by default all the tests of the specified level)
  modules:
    "all" (default) or a subset of "$_ALL_MODULES"
EOF
    exit $1
}

to_be_tested() # module
{
    case " $_to_test " in
	*\ $1\ *)
	    echo "yes"
	    ;;
	*)
	    echo "no"
	    ;;
    esac
}

do_the_test()
{
    test_script="$1"
    file_prefix="/tmp/pm2test_${USER}"
    file_expected="${file_prefix}_expected"
    file_result="${file_prefix}_result"
    file_status="${file_prefix}_status"
    file_filtered="${file_prefix}_filtered"

    nbl=`wc -l < ${file_expected}`
    nbl=`expr $nbl + 0`

    gcov_dir="$(pm2-config --flavor=$flavor --builddir)/coverage/$test_script"

    # Execution
    is_function_defined=$(declare -f prerun_test)
    if [ "$is_function_defined" != "" ] ; then
	prerun_test | sed -e 's/^/..../'
    fi

    if [ "$_coverage" = "yes" ]
    then
	# Remove previous gcov output.
	find "$(pm2-config --flavor=$flavor --builddir)"	\
	  -name \*.gcda -exec rm {} \;
    fi

    echo "Running program $prog..."
    ${PM2_ROOT}/bin/pm2-conf -f $flavor $hosts
    if [ -z "$net" ] ; then
        (${PM2_ROOT}/bin/pm2-load --x11 -f $flavor $prog $args; echo "$?" > $file_status) 2>&1 | tee $file_result | grep '^####'
    else
        protocols=$(echo $net | tr ' ' '\012' | sed 's/^/--protocol /')
        (${PM2_ROOT}/bin/pm2-load --x11 $protocols -f $flavor $prog $args; echo "$?" > $file_status) 2>&1 | tee $file_result | grep '^####'
    fi
    [ `cat $file_status` -eq 0 ] || pm2_test_error_file "Execution of $prog failed" $file_result

    # Le moment de verite
    echo "Checking results..."
    if [ "$sort_output" == "1" ] ; then
        echo "Sorting output"
        sort_command="sort --ignore-case"
    else
        sort_command="cat"
    fi
    if [ "$check_all_lines" == "1" ] ; then
        # will compare all the lines of the output and not only the number
        # of lines present in the expected output file
        head_command="cat"
    else
        # will only compare the number of lines present in the
        # expected output file
        head_command="head -$nbl"
    fi
    grep -v '^#' $file_result | grep -v Puk: | grep -v PadicoTM | grep -v ".ssh.rc" | grep -v "X11 forwarding" | grep -v xauth | $head_command | $sort_command > $file_filtered
    if diff -u $file_expected $file_filtered ; then
	echo "Test ok!"
    else
	pm2_test_error_file "Test $prog failed: unexpected result (see $file_result)" $file_filtered
    fi

    # Coverage testing.
    if [ "$_coverage" = "yes" ]
    then
	# Feed all `.gcda' files through lcov to produce lcov `.info'
	# files.
	echo "collecting gcov output under \`$gcov_dir'..."
	rm -rf "$gcov_dir"
	mkdir -p "$gcov_dir"

        build_dir=$(pm2-config --flavor=$flavor --builddir)
        dirs=$(find $(pm2-config --flavor=$flavor --builddir) -type d)
	for dir in $dirs
	do
	    if [ -d "$dir/obj" ]
	    then
                is_examples=$(echo $dir | grep examples)
                if [ "$is_examples" != "" ]
                then
                    command=$(echo "echo $dir | sed 's:"$build_dir':'$PM2_ROOT/$_m":'")
                else
                    command=$(echo "echo $dir | sed 's:"$build_dir':'$PM2_ROOT":'")
                fi
                base_dir=$(eval $command)
		module_name="$(basename $dir)"

		echo "writing lcov file \`$gcov_dir/$module_name.info'..."
		lcov -c -d "$dir/obj" -b "$base_dir" \
		    > "$gcov_dir/$module_name.info"
	    fi
	done
    fi

    # Destruction des fichiers residuels
    rm -rf ${file_prefix}_*
}

# Programme principal

_init_level=1 # first level to test
_level=2 # normal
_output_redirect=""
_coverage="no"
jobs=""

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
	    pm2_test_usage 0
	    ;;
	-q|--quiet)
	    _output_redirect="> /dev/null 2>&1"
	    shift
	    ;;
	--basic|-l1)
	    _level=1
	    shift
	    ;;
	--normal|-l2)
	    _level=2
	    shift
	    ;;
	--advanced|-l3)
	    _level=3
	    shift
	    ;;
	--torture|-l4)
	    _level=4
	    shift
	    ;;
	--coverage)
	    _coverage=yes
	    shift;;
	-L1)
	    _level=1
	    _init_level=$_level
	    shift
	    ;;
	-L2)
	    _level=2
	    _init_level=$_level
	    shift
	    ;;
	-L3)
	    _level=3
	    _init_level=$_level
	    shift
	    ;;
	-L4)
	    _level=4
	    _init_level=$_level
	    shift
	    ;;
	-L5)
	    _level=5
	    _init_level=$_level
	    shift
	    ;;
	--jobs|-j)
	    jobs="$1 $2"
	    shift
	    shift
	    ;;
	--jobs=*|-j*)
	    jobs=$1
	    shift
	    ;;
        --tests)
            shift
            PM2_TESTS=$1
            shift
            ;;
	--)
	    shift; break
	    ;;
	-*)
	    pm2_test_error "Invalid option: $1"
	    ;;
	*)
	    break
	    ;;
    esac
done

if [ $# -eq 0 -o "$1" = all ] ; then
    _to_test="$_ALL_MODULES"
else
    _to_test=""
    for m in ${@:+"$@"}; do
	case " $_ALL_MODULES " in
	    *\ $m\ *)
		_to_test="${_to_test:+$_to_test }$m"
		;;
	    *)
		pm2_test_error "\"$m\" is not a valid module name"
		;;
	esac
    done
fi

# Reordering of modules
_prefix=""
for _m in $_DIRTY_ORDERED_MODULES ; do
    case " $_to_test " in
	*\ $_m\ *)
	    _prefix="${_prefix:+${_prefix} }$_m"
	    ;;
	*)
	    ;;
    esac
done

_suffix=""
for _m in $_to_test ; do
    case " $_DIRTY_ORDERED_MODULES " in
	*\ $_m\ *)
	    ;;
	*)
	    _suffix="${_suffix:+${_suffix} }$_m"
	    ;;
    esac
done

if [ "$_coverage" = "yes" ]
then
    # XXX: We have to use `CPPFLAGS', not `CFLAGS', because defining
    # `CFLAGS' overrides the makefile-provided `CFLAGS'.
    CPPFLAGS="--coverage $CPPFLAGS"
    LDFLAGS="--coverage $LDFLAGS"
fi

_to_test="$_prefix $_suffix"

rm -rf /tmp/tests_${USER}_database/
mkdir /tmp/tests_${USER}_database/
_l=$_init_level
while [ $_l -le $_level ]; do

    echo "*** Initialising level $_l tests ***"

    for _m in $_to_test ; do

	if [ -d ${PM2_ROOT}/modules/$_m/test ]; then

	    cd ${PM2_ROOT}/modules/$_m/test
	    _tests=`ls test_*.level_$_l 2> /dev/null`
	    if [ -n "$_tests" ]; then

		for _f in $_tests ; do

                    # Affichage
                    _tst_name=`echo $_f | sed -e 's/test_\(.*\).level_.*/\1/g'`

                    is_test_selected=1
                    if [ -n "$PM2_TESTS" ] ; then
                        if [ "$(echo $PM2_TESTS|tr ' ' '\012' | grep $_tst_name)" == "" ] ; then
                            is_test_selected=0
                        fi
                    fi

                    if [ $is_test_selected == 1 ] ; then
                        echo "....Preloading level [$_l], module [$_m], Test [$_tst_name]"

		        # Source
                        . ./$_f

		        # Compilation, execution et verification des resultats
			pm2-flavor get --flavor=$flavor > /dev/null 2>/dev/null
			if [ $? == 1 ] ; then
			    create_test_flavor | sed -e 's/^/..../'
			fi
			appdir2=$(echo $appdir | tr '/' ':')
			echo $prog >> /tmp/tests_${USER}_database/${flavor}-${appdir2}.dat
                    fi

                done

	    fi
	fi
    done
    _l=`expr $_l + 1`
done

shopt -s nullglob
for f in /tmp/tests_${USER}_database/*.dat ; do
    d_filename=$(basename $f .dat)
    d_flavor=$(echo $d_filename | awk -F'-' '{print $1}')
    d_appdir=$(echo $d_filename | sed 's/.*-:/:/' | tr ':' '/')

    CC=${CC:-$(pm2-config --flavor=$d_flavor --cc)}
    file_status="/tmp/pm2test_${USER}_status"

    echo "Compiling flavor \"$d_flavor\"..."
    (CPPFLAGS="$CPPFLAGS" LDFLAGS="$LDFLAGS" ${PM2_MAKE:-make} CC="$CC" FLAVOR=$d_flavor PM2_FLAVOR=$d_flavor $jobs -C $PM2_ROOT $jobs; echo "$?" > $file_status ) | sed -e 's/^/..../'
    [ `cat $file_status` -eq 0 ] || pm2_test_error "Compilation failed"

    d_progs=`cat $f | tr '\012' ' '`
    echo "Compiling applications \"$d_progs\" for flavor \"$d_flavor\"..."
    (CPPFLAGS="$CPPFLAGS" LDFLAGS="$LDFLAGS" ${PM2_MAKE:-make} CC="$CC" FLAVOR=$d_flavor PM2_FLAVOR=$d_flavor $jobs -C $d_appdir $d_progs; echo "$?" > $file_status) | sed -e 's/^/..../'
    [ `cat $file_status` -eq 0 ] || pm2_test_error "Compilation failed"
done

_l=$_init_level
while [ $_l -le $_level ]; do

    echo "*** Performing level $_l tests ***"

    for _m in $_to_test ; do

	if [ -d ${PM2_ROOT}/modules/$_m/test ]; then

	    cd ${PM2_ROOT}/modules/$_m/test
	    _tests=`ls test_*.level_$_l 2> /dev/null`
	    if [ -n "$_tests" ]; then

		for _f in $_tests ; do

                    # Affichage
                    _tst_name=`echo $_f | sed -e 's/test_\(.*\).level_.*/\1/g'`

                    is_test_selected=1
                    if [ -n "$PM2_TESTS" ] ; then
                        if [ "$(echo $PM2_TESTS|tr ' ' '\012' | grep $_tst_name)" == "" ] ; then
                            is_test_selected=0
                        fi
                    fi

                    if [ $is_test_selected == 1 ] ; then
                        echo "Level [$_l], module [$_m], Test [$_tst_name]"

                        # by default, do not sort the output
                        sort_output=0

		        # Source
                        . ./$_f

		        # Compilation, execution et verification des resultats
                        eval do_the_test "$_f" $_output_redirect

                        echo "   [$_tst_name] did succeed."

                    fi

                done

		echo ">>> Level [$_l] tests for module [$_m] did succeed!"
	    fi


	    if [ "$_coverage" = "yes" ]
	    then
		# Enumerate all the lcov-generated `.info' files.
		lcov_options=""
                gcov_dirs=$(find $(pm2-config --flavor=$flavor --builddir) -name coverage -type d)
		for gcov_dir in $gcov_dirs/*
		do
		    if [ -d "$gcov_dir" ]
		    then
			for file in "$gcov_dir"/*.info
			do
			    if [ -s "$file" ]
			    then
				lcov_options="$lcov_options -a $file"
			    fi
			done
		    fi
		done

		lcov_html_report_dir="$(dirname $(pm2-config --flavor=$flavor --builddir))/coverage/$_m"
		rm -rf "$lcov_html_report_dir"
		mkdir -p "$lcov_html_report_dir"

		# Aggregate all the lcov-generated `.info' files.
		lcov_global_info_file="$lcov_html_report_dir/${_m}.info"
		#echo "lcov_options: $lcov_options"
		lcov $lcov_options > "$lcov_global_info_file"

		# Generate the HTML report.
		echo "generating HTML coverage report under \`$lcov_html_report_dir'..."
		genhtml -o "$lcov_html_report_dir" "$lcov_global_info_file" && \
		echo "HTML coverage report available under \`$lcov_html_report_dir'..."
	    fi
	fi
    done

    echo ">>>>>> All Level [$_l] tests did succeed!"

    _l=`expr $_l + 1`
done

# ########## Happy end ##########
echo "         ************************"
echo "         *** Congratulations! ***"
echo "         ************************"

exit 0
