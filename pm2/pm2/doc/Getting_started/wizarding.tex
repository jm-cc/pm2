\section{Wizarding PM2: adavanced features}

\stamp $Id: wizarding.tex,v 1.2 2001/04/12 16:01:00 bouge Exp $

We have gathered in this section some advanced material as a reference
for the advanced user. Beginners should probably skip this section on
a first reading. 

\subsection{Thread synchronization}

PM2 provides a number of POSIX-like synchronization facilities to
synchronize the threads within a node and among remote nodes: locks,
mutexes, semaphores, conditions, barriers. The facilities which are
local to a node are provided by the Marcel thread scheduler. Remote
synchronization facilities are provided by PM2.

\paragraph{Locks}

The lowest level of synchonization is to disable the scheduler
temporarily at the local node. This garantees that the successive
instructions will be issued atomically. This is done using the
\|pm2_freeze|/\|pm2_unfreeze| routines. These are simply wrappers for
two essential Marcel routines respectively called \|lock_task| and
\|unlock_task|. The \|lock_task| routine locks a Marcel thread within
the scheduler, disabling any external interrupt. No other thread
whatsoever can be scheduled until the \|unlock_task| has been called.
These routines may be nested. It is up to the user to guarantee proper
nesting. One has te be uttermost careful that PM2/Marcel provides no
protection against deadlock. Also, locking a tasked within a node
disable any progress of the daemon service threads: no message can be
received, etc. It is up to the user to guarantee that no harm may
result, for instance from overfilling communication buffers.

\figurelistingdouble {freeze.c} {Freezing and unfreezing the scheduler}
{prog:freeze}

Consider Program~\ref{prog:freeze}. The main thread spawns an even
number of threads on the local node. Each even thread increases the
shared variable \|counter| for \|N| times, and each odd thread decreases
it for \|N| times, too. To emphasize that increasing and decreasing a
variable is \emph{not} an atomic operation at the level of machine
code, we have written it explicitely as a Load/Add/Store series of
operation. (Observe that variable \|tmp| has be registered as
\|volatile| to prevent the wise compiler to optimize our
trick!). The expected final value for \|counter| is~0.  Running the
program without the calls to \|pm2_freeze| and \|pm2_unfreeze|
routines produces the following output:
\begin{shell}
ravel% pm2load freeze
Initial value: 0
Creating thread 0
Creating thread 1
Creating thread 2
Creating thread 3
Final value: 776821
[Threads : 5 created, 0 imported (0 cached)]
\end{shell}
It shows that getting interrupted in the middle of the critical section
is a relatively frequent event, which should definitely not be
overlooked by the PM2 programmer! Activated the two calls yields
result~0, as expected.

\paragraph{Mutexes}

\figurelistingdouble {mutex.c} {Using mutexes in PM2}
{prog:mutex}

Freezing is sufficient for most simple purpose, when a (short!)
sequence of actions have to be issued atomically. Yet, this does not
handle the case of sequence where the thread may get temporarily
suspended, at its own request or not. In this case, more sophisticated
facilities have to be used, for instance mutexes (for \emph{mutual
  exclusion}). Consider Program~\ref{prog:mutex}, and assume that for
some reason, the thread should be suspended right in the middle of the
critical section. We simulate this by a call to the \|marcel_yield|
routine, which yields the control back to the scheduler and inserts
back the thread into the ready list. Running the program without any
synchronization facility returns a non-null value, even for a few
iterations. A mutex has to be first initialized using the
\|marcel_mutex_init| routine, with a number of attributes. As usual,
\|NULL| is a sensible default in a first place.  It can afterwards be
acquired and released, respectively with the \|marcel_mutex_lock| and
\|marcel_mutex_unlock| routines.

\paragraph{Semaphores}

\figurelistingdouble {semaphore.c} {Using semaphores in PM2}
{prog:semaphore}


Marcel also provides semaphores. A semaphore can be initialized with
the \|marcel_sem_init| routine with an initial integer value. It can
be taken with \|marcel_sem_P|, and freed with \|marcel_sem_V|, as
probably expected.

In fact, completion are just a simple wrapping for semaphores. On
initializing a completion, a semaphore is initialized, and its address
and native node are stored into a structure. Waiting for a completion
is just issuing a \|marcel_sem_P| on the semaphore.  Signalling
completion includes the following action: if the local node is the
same as the native node, then a call to \|marcel_sem_V| is issued for
the semaphore; otherwise, a RPC request is issued to the native node,
with the the signalling routine as its service and the completion as
its argument. Program~\ref{prog:semaphore} is the same as
Program~\ref{prog:mutex}, but completions have been replaced by
explicit semaphores.

\paragraph{Conditions}

% \figurelistingdouble {condition.c} {Using condition variables in PM2}
% {prog:condition}

\begin{note}
  Yet to be finished... after holidays!
\end{note}




\subsection{Profiling PM2 programs}
\label{sec:profiling}

\section{Miscellaneous}

\subsection{Application initialization with PM2}
\label{sec:startupfunc}

\|pm2_set_startup_func|

